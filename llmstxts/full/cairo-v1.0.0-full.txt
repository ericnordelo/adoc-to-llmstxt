# OpenZeppelin Contracts for Cairo

> OpenZeppelin Contracts written in Cairo for Starknet, a decentralized ZK Rollup.

A library for secure smart contract development written in Cairo for Starknet. This library consists of a set of reusable components to build custom smart contracts, as well as ready-to-deploy presets. You can also find other utilities including interfaces and dispatchers and test utilities that facilitate testing with Starknet Foundry.
// llmstxt-short-description: Overview of the Contracts for Cairo library and its usage

:starknet: https://starkware.co/product/starknet/[Starknet]
:scarb: https://docs.swmansion.com/scarb[Scarb]
:installation: https://docs.swmansion.com/scarb/download.html[this guide]

= Contracts for Cairo

*A library for secure smart contract development* written in Cairo for {starknet}. This library consists of a set of xref:components.adoc[reusable components] to build custom smart contracts, as well as
ready-to-deploy xref:presets.adoc[presets]. You can also find other xref:/api/utilities.adoc[utilities] including xref:interfaces.adoc[interfaces and dispatchers] and xref:/api/testing.adoc[test utilities]
that facilitate testing with Starknet Foundry.

WARNING: This repo contains highly experimental code. Expect rapid iteration. *Use at your own risk.*

NOTE: You can track our roadmap and future milestones in our https://github.com/orgs/OpenZeppelin/projects/29/[Github Project].

== Installation

The library is available as a {scarb} package. Follow {installation} for installing Cairo and Scarb on your machine
before proceeding, and run the following command to check that the installation was successful:

[,bash]
----
$ scarb --version

scarb 2.9.4 (d3be9ebe1 2025-02-19)
cairo: 2.9.4 (https://crates.io/crates/cairo-lang-compiler/2.9.4)
sierra: 1.6.0
----

=== Set up your project

Create an empty directory, and `cd` into it:

[,bash]
----
mkdir my_project/ && cd my_project/
----

Initialize a new Scarb project:

[,bash]
----
scarb init
----

The contents of `my_project/` should now look like this:

[,bash]
----
$ ls

Scarb.toml src
----

=== Install the library

Install the library by declaring it as a dependency in the project's `Scarb.toml` file:

[,text]
----
[dependencies]
openzeppelin = "1.0.0"
----

The previous example would import the entire library. We can also add each package as a separate dependency to
improve the building time by not including modules that won't be used:

[,text]
----
[dependencies]
openzeppelin_access = "1.0.0"
openzeppelin_token = "1.0.0"
----

== Basic usage

This is how it looks to build an ERC20 contract using the xref:erc20.adoc[ERC20 component].
Copy the code into `src/lib.cairo`.

TIP: If you added the entire library as a dependency, use `openzeppelin::token` instead of `openzeppelin_token` for the imports.

[,cairo]
----
#[starknet::contract]
mod MyERC20Token {
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    // ERC20 Mixin
    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc20: ERC20Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC20Event: ERC20Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        name: ByteArray,
        symbol: ByteArray,
        fixed_supply: u256,
        recipient: ContractAddress
    ) {
        self.erc20.initializer(name, symbol);
        self.erc20.mint(recipient, fixed_supply);
    }
}
----

You can now compile it:

[,bash]
----
scarb build
----
// llmstxt-short-description: Interactive generator for Cairo contracts

= Wizard for Cairo
:page-notoc:

Not sure where to start? Use the interactive generator below to bootstrap your
contract and learn about the components offered in OpenZeppelin Contracts for Cairo.


NOTE: We strongly recommend checking the xref:components.adoc[Components] section to understand how to extend from our library.

++++
<script async src="https://wizard.openzeppelin.com/build/embed.js"></script>

<oz-wizard style="display: block; min-height: 40rem;" data-lang="cairo" version="1.0.0"></oz-wizard>
++++
// llmstxt-short-description: Describes how to use the components of the library, including mixins, hooks, initializers, immutable configs and more

= Components

The following documentation provides reasoning and examples on how to use Contracts for Cairo components.

:shamans-post: https://community.starknet.io/t/cairo-components/101136#components-1[Starknet Shamans post]
:cairo-book: https://book.cairo-lang.org/ch99-01-05-00-components.html[Cairo book]

Starknet components are separate modules that contain storage, events, and implementations that can be integrated into a contract.
Components themselves cannot be declared or deployed.
Another way to think of components is that they are abstract modules that must be instantiated.

TIP: For more information on the construction and design of Starknet components, see the {shamans-post} and the {cairo-book}.

== Building a contract

=== Setup

:initializable-component: xref:/security.adoc#initializable[InitializableComponent]
:accessing-storage: xref:accessing_component_storage[Accessing component storage]

The contract should first import the component and declare it with the `component!` macro:

[,cairo]
----
#[starknet::contract]
mod MyContract {
    // Import the component
    use openzeppelin_security::InitializableComponent;

    // Declare the component
    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);
}
----

The `path` argument should be the imported component itself (in this case, {initializable-component}).
The `storage` and `event` arguments are the variable names that will be set in the `Storage` struct and `Event` enum, respectively.
Note that even if the component doesn't define any events, the compiler will still create an empty event enum inside the component module.

[,cairo]
----
#[starknet::contract]
mod MyContract {
    use openzeppelin_security::InitializableComponent;

    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);

    #[storage]
    struct Storage {
        #[substorage(v0)]
        initializable: InitializableComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        InitializableEvent: InitializableComponent::Event
    }
}
----

The `#[substorage(v0)]` attribute must be included for each component in the `Storage` trait.
This allows the contract to have indirect access to the component's storage.
See {accessing-storage} for more on this.

The `#[flat]` attribute for events in the `Event` enum, however, is not required.
For component events, the first key in the event log is the component ID.
Flattening the component event removes it, leaving the event ID as the first key.

=== Implementations

:erc20-component: xref:/api/erc20.adoc#ERC20Component[ERC20Component]
:mixin: xref:/components.adoc#mixins[mixin]

Components come with granular implementations of different interfaces.
This allows contracts to integrate only the implementations that they'll use and avoid unnecessary bloat.
Integrating an implementation looks like this:

[,cairo]
----
mod MyContract {
    use openzeppelin_security::InitializableComponent;

    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);

    (...)

    // Gives the contract access to the implementation methods
    impl InitializableImpl =
        InitializableComponent::InitializableImpl<ContractState>;
}
----

Defining an `impl` gives the contract access to the methods within the implementation from the component.
For example, `is_initialized` is defined in the `InitializableImpl`.
A function on the contract level can expose it like this:

[,cairo]
----
#[starknet::contract]
mod MyContract {
    use openzeppelin_security::InitializableComponent;

    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);

    (...)

    impl InitializableImpl =
        InitializableComponent::InitializableImpl<ContractState>;

    #[external(v0)]
    fn is_initialized(ref self: ContractState) -> bool {
        self.initializable.is_initialized()
    }
}
----

While there's nothing wrong with manually exposing methods like in the previous example, this process can be tedious for implementations with many methods.
Fortunately, a contract can embed implementations which will expose all of the methods of the implementation.
To embed an implementation, add the `#[abi(embed_v0)]` attribute above the `impl`:

[,cairo]
----
#[starknet::contract]
mod MyContract {
    (...)

    // This attribute exposes the methods of the `impl`
    #[abi(embed_v0)]
    impl InitializableImpl =
        InitializableComponent::InitializableImpl<ContractState>;
}
----

`InitializableImpl` defines the `is_initialized` method in the component.
By adding the embed attribute, `is_initialized` becomes a contract entrypoint for `MyContract`.

[TIP]
====
Embeddable implementations, when available in this library's components, are segregated from the internal component implementation which makes it easier to safely expose.
Components also separate granular implementations from {mixin} implementations.
The API documentation design reflects these groupings.
See {erc20-component} as an example which includes:

- *Embeddable Mixin Implementation*
- *Embeddable Implementations*
- *Internal Implementations*
- *Events*
====

=== Mixins

Mixins are impls made of a combination of smaller, more specific impls.
While separating components into granular implementations offers flexibility,
integrating components with many implementations can appear crowded especially if the contract uses all of them.
Mixins simplify this by allowing contracts to embed groups of implementations with a single directive.

Compare the following code blocks to see the benefit of using a mixin when creating an account contract.

==== Account without mixin

[,cairo]
----
component!(path: AccountComponent, storage: account, event: AccountEvent);
component!(path: SRC5Component, storage: src5, event: SRC5Event);

#[abi(embed_v0)]
impl SRC6Impl = AccountComponent::SRC6Impl<ContractState>;
#[abi(embed_v0)]
impl DeclarerImpl = AccountComponent::DeclarerImpl<ContractState>;
#[abi(embed_v0)]
impl DeployableImpl = AccountComponent::DeployableImpl<ContractState>;
#[abi(embed_v0)]
impl PublicKeyImpl = AccountComponent::PublicKeyImpl<ContractState>;
#[abi(embed_v0)]
impl SRC6CamelOnlyImpl = AccountComponent::SRC6CamelOnlyImpl<ContractState>;
#[abi(embed_v0)]
impl PublicKeyCamelImpl = AccountComponent::PublicKeyCamelImpl<ContractState>;
impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;

#[abi(embed_v0)]
impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;
----

==== Account with mixin

[,cairo]
----
component!(path: AccountComponent, storage: account, event: AccountEvent);
component!(path: SRC5Component, storage: src5, event: SRC5Event);

#[abi(embed_v0)]
impl AccountMixinImpl = AccountComponent::AccountMixinImpl<ContractState>;
impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;
----

The rest of the setup for the contract, however, does not change.
This means that component dependencies must still be included in the `Storage` struct and `Event` enum.
Here's a full example of an account contract that embeds the `AccountMixinImpl`:

[,cairo]
----
#[starknet::contract]
mod Account {
    use openzeppelin_account::AccountComponent;
    use openzeppelin_introspection::src5::SRC5Component;

    component!(path: AccountComponent, storage: account, event: AccountEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // This embeds all of the methods from the many AccountComponent implementations
    // and also includes `supports_interface` from `SRC5Impl`
    #[abi(embed_v0)]
    impl AccountMixinImpl = AccountComponent::AccountMixinImpl<ContractState>;
    impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        account: AccountComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        AccountEvent: AccountComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState, public_key: felt252) {
        self.account.initializer(public_key);
    }
}
----

=== Initializers

:ownable-component: xref:/api/access.adoc#OwnableComponent[OwnableComponent]

WARNING: Failing to use a component's `initializer` can result in irreparable contract deployments.
Always read the API documentation for each integrated component.

Some components require some sort of setup upon construction.
Usually, this would be a job for a constructor; however, components themselves cannot implement constructors.
Components instead offer ``initializer``s within their `InternalImpl` to call from the contract's constructor.
Let's look at how a contract would integrate {ownable-component}:

[,cairo]
----
#[starknet::contract]
mod MyContract {
    use openzeppelin_access::ownable::OwnableComponent;
    use starknet::ContractAddress;

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);

    // Instantiate `InternalImpl` to give the contract access to the `initializer`
    impl InternalImpl = OwnableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        ownable: OwnableComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        OwnableEvent: OwnableComponent::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: ContractAddress) {
        // Invoke ownable's `initializer`
        self.ownable.initializer(owner);
    }
}
----

=== Immutable Config

:erc2981-component: xref:/api/token_common.adoc#ERC2981Component[ERC2981Component]
:SRC-107: https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-107.md[SRC-107]

While initializers help set up the component's initial state, some require configuration that may be defined
as constants, saving gas by avoiding the necessity of reading from storage each time the variable needs to be used. The
Immutable Component Config pattern helps with this matter by allowing the implementing contract to define a set of
constants declared in the component, customizing its functionality.

NOTE: The Immutable Component Config standard is defined in the {SRC-107}.

Here's an example of how to use the Immutable Component Config pattern with the {erc2981-component}:

[,cairo]
----
#[starknet::contract]
mod MyContract {
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_token::common::erc2981::ERC2981Component;
    use starknet::contract_address_const;

    component!(path: ERC2981Component, storage: erc2981, event: ERC2981Event);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;

    // Instantiate `InternalImpl` to give the contract access to the `initializer`
    impl InternalImpl = ERC2981Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc2981: ERC2981Component::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC2981Event: ERC2981Component::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    // Define the immutable config
    pub impl ERC2981ImmutableConfig of ERC2981Component::ImmutableConfig {
        const FEE_DENOMINATOR: u128 = 10_000;
    }

    #[constructor]
    fn constructor(ref self: ContractState) {
        let default_receiver = contract_address_const::<'RECEIVER'>();
        let default_royalty_fraction = 1000;
        // Invoke erc2981's `initializer`
        self.erc2981.initializer(default_receiver, default_royalty_fraction);
    }
}
----

==== Default config

Sometimes, components implementing the Immutable Component Config pattern provide a default configuration that can be
directly used without implementing the `ImmutableConfig` trait locally. When provided, this implementation will be named
`DefaultConfig` and will be available in the same module containing the component, as a sibling.

In the following example, the `DefaultConfig` trait is used to define the `FEE_DENOMINATOR` config constant.

[,cairo]
----
#[starknet::contract]
mod MyContract {
    use openzeppelin_introspection::src5::SRC5Component;
    // Bring the DefaultConfig trait into scope
    use openzeppelin_token::common::erc2981::{ERC2981Component, DefaultConfig};
    use starknet::contract_address_const;

    component!(path: ERC2981Component, storage: erc2981, event: ERC2981Event);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;

    // Instantiate `InternalImpl` to give the contract access to the `initializer`
    impl InternalImpl = ERC2981Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        (...)
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        (...)
    }

    #[constructor]
    fn constructor(ref self: ContractState) {
        let default_receiver = contract_address_const::<'RECEIVER'>();
        let default_royalty_fraction = 1000;
        // Invoke erc2981's `initializer`
        self.erc2981.initializer(default_receiver, default_royalty_fraction);
    }
}
----

==== `validate` function

:validate-section: https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-107.md#validate-function[validate section of the SRC-107]

The `ImmutableConfig` trait may also include a `validate` function with a default implementation, which
asserts that the configuration is correct, and must not be overridden by the implementing contract. For more information
on how to use this function, refer to the {validate-section}.

=== Dependencies

:access-component: xref:/api/access.adoc#AccessControlComponent[AccessControlComponent]
:src5-component: xref:/api/introspection.adoc#SRC5Component[SRC5Component]

Some components include dependencies of other components.
Contracts that integrate components with dependencies must also include the component dependency.
For instance, {access-component} depends on {src5-component}.
Creating a contract with `AccessControlComponent` should look like this:

[,cairo]
----
#[starknet::contract]
mod MyContract {
    use openzeppelin_access::accesscontrol::AccessControlComponent;
    use openzeppelin_introspection::src5::SRC5Component;

    component!(path: AccessControlComponent, storage: accesscontrol, event: AccessControlEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // AccessControl
    #[abi(embed_v0)]
    impl AccessControlImpl =
        AccessControlComponent::AccessControlImpl<ContractState>;
    #[abi(embed_v0)]
    impl AccessControlCamelImpl =
        AccessControlComponent::AccessControlCamelImpl<ContractState>;
    impl AccessControlInternalImpl = AccessControlComponent::InternalImpl<ContractState>;

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        accesscontrol: AccessControlComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        AccessControlEvent: AccessControlComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    (...)
}
----

== Customization

:security: xref:security[Security]

WARNING: Customizing implementations and accessing component storage can potentially corrupt the state, bypass security checks, and undermine the component logic.
*Exercise extreme caution*. See {security}.

=== Hooks

:hooks-post: https://fleming-andrew.medium.com/extending-cairo-contracts-with-hooks-c3ca21d1d6b8[Extending Cairo Contracts with Hooks]

Hooks are entrypoints to the business logic of a token component that are accessible at the contract level.
This allows contracts to insert additional behaviors before and/or after token transfers (including mints and burns).
Prior to hooks, extending functionality required contracts to create <<custom_implementations, custom implementations>>.

All token components include a generic hooks trait that include empty default functions.
When creating a token contract, the using contract must create an implementation of the hooks trait.
Suppose an ERC20 contract wanted to include Pausable functionality on token transfers.
The following snippet leverages the `before_update` hook to include this behavior.

[,cairo]
----
#[starknet::contract]
mod MyToken {
    use openzeppelin_security::pausable::PausableComponent::InternalTrait;
    use openzeppelin_security::pausable::PausableComponent;
    use openzeppelin_token::erc20::ERC20Component;
    use starknet::ContractAddress;

    component!(path: ERC20Component, storage: erc20, event: ERC20Event);
    component!(path: PausableComponent, storage: pausable, event: PausableEvent);

    // ERC20 Mixin
    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    #[abi(embed_v0)]
    impl PausableImpl = PausableComponent::PausableImpl<ContractState>;
    impl PausableInternalImpl = PausableComponent::InternalImpl<ContractState>;

    // Create the hooks implementation
    impl ERC20HooksImpl of ERC20Component::ERC20HooksTrait<ContractState> {
        // Occurs before token transfers
        fn before_update(
            ref self: ERC20Component::ComponentState<ContractState>,
            from: ContractAddress,
            recipient: ContractAddress,
            amount: u256
        ) {
            // Access local state from component state
            let contract_state = self.get_contract();
            // Call function from integrated component
            contract_state.pausable.assert_not_paused();
        }

        // Omitting the `after_update` hook because the default behavior
        // is already implemented in the trait
    }

    (...)
}
----

Notice that the `self` parameter expects a component state type.
Instead of passing the component state, the using contract's state can be passed which simplifies the syntax.
The hook then moves the scope up with the Cairo-generated `get_contract` through the `HasComponent` trait (as illustrated with ERC20Component in this example).
From here, the hook can access the using contract's integrated components, storage, and implementations.

Be advised that even if a token contract does not require hooks, the hooks trait must still be implemented.
The using contract may instantiate an empty impl of the trait;
however, the Contracts for Cairo library already provides the instantiated impl to abstract this away from contracts.
The using contract just needs to bring the implementation into scope like this:

[,cairo]
----
#[starknet::contract]
mod MyToken {
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};

    (...)
}
----

TIP: For a more in-depth guide on hooks, see {hooks-post}.

=== Custom implementations

:erc20-component: xref:/api/erc20.adoc#ERC20Component[ERC20Component]
:custom-decimals: xref:/erc20.adoc#customizing_decimals[Customizing decimals]

There are instances where a contract requires different or amended behaviors from a component implementation.
In these scenarios, a contract must create a custom implementation of the interface.
Let's break down a pausable ERC20 contract to see what that looks like.
Here's the setup:

[,cairo]
----
#[starknet::contract]
mod ERC20Pausable {
    use openzeppelin_security::pausable::PausableComponent;
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    // Import the ERC20 interfaces to create custom implementations
    use openzeppelin_token::erc20::interface::{IERC20, IERC20CamelOnly};
    use starknet::ContractAddress;

    component!(path: PausableComponent, storage: pausable, event: PausableEvent);
    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    #[abi(embed_v0)]
    impl PausableImpl = PausableComponent::PausableImpl<ContractState>;
    impl PausableInternalImpl = PausableComponent::InternalImpl<ContractState>;

    // `ERC20MetadataImpl` can keep the embed directive because the implementation
    // will not change
    #[abi(embed_v0)]
    impl ERC20MetadataImpl = ERC20Component::ERC20MetadataImpl<ContractState>;
    // Do not add the embed directive to these implementations because
    // these will be customized
    impl ERC20Impl = ERC20Component::ERC20Impl<ContractState>;
    impl ERC20CamelOnlyImpl = ERC20Component::ERC20CamelOnlyImpl<ContractState>;

    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    (...)
}
----

The first thing to notice is that the contract imports the interfaces of the implementations that will be customized.
These will be used in the next code example.

Next, the contract includes the {erc20-component} implementations; however, `ERC20Impl` and `ERC20CamelOnlyImplt` are *not* embedded.
Instead, we want to expose our custom implementation of an interface.
The following example shows the pausable logic integrated into the ERC20 implementations:

[,cairo]
----
#[starknet::contract]
mod ERC20Pausable {
    (...)

    // Custom ERC20 implementation
    #[abi(embed_v0)]
    impl CustomERC20Impl of IERC20<ContractState> {
        fn transfer(
            ref self: ContractState, recipient: ContractAddress, amount: u256
        ) -> bool {
            // Add the custom logic
            self.pausable.assert_not_paused();
            // Add the original implementation method from `IERC20Impl`
            self.erc20.transfer(recipient, amount)
        }

        fn total_supply(self: @ContractState) -> u256 {
            // This method's behavior does not change from the component
            // implementation, but this method must still be defined.
            // Simply add the original implementation method from `IERC20Impl`
            self.erc20.total_supply()
        }

        (...)
    }

    // Custom ERC20CamelOnly implementation
    #[abi(embed_v0)]
    impl CustomERC20CamelOnlyImpl of IERC20CamelOnly<ContractState> {
        fn totalSupply(self: @ContractState) -> u256 {
            self.erc20.total_supply()
        }

        fn balanceOf(self: @ContractState, account: ContractAddress) -> u256 {
            self.erc20.balance_of(account)
        }

        fn transferFrom(
            ref self: ContractState,
            sender: ContractAddress,
            recipient: ContractAddress,
            amount: u256
        ) -> bool {
            self.pausable.assert_not_paused();
            self.erc20.transfer_from(sender, recipient, amount)
        }
    }
}
----

Notice that in the `CustomERC20Impl`, the `transfer` method integrates `pausable.assert_not_paused` as well as `erc20.transfer` from `PausableImpl` and `ERC20Impl` respectively.
This is why the contract defined the `ERC20Impl` from the component in the previous example.

Creating a custom implementation of an interface must define *all* methods from that interface.
This is true even if the behavior of a method does not change from the component implementation (as `total_supply` exemplifies in this example).

=== Accessing component storage

There may be cases where the contract must read or write to an integrated component's storage.
To do so, use the same syntax as calling an implementation method except replace the name of the method with the storage variable like this:

[,cairo]
----
#[starknet::contract]
mod MyContract {
    use openzeppelin_security::InitializableComponent;

    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);

    #[storage]
    struct Storage {
        #[substorage(v0)]
        initializable: InitializableComponent::Storage
    }

    (...)

    fn write_to_comp_storage(ref self: ContractState) {
        self.initializable.Initializable_initialized.write(true);
    }

    fn read_from_comp_storage(self: @ContractState) -> bool {
        self.initializable.Initializable_initialized.read()
    }
}
----

== Security

The maintainers of OpenZeppelin Contracts for Cairo are mainly concerned with the correctness and security of the code as published in the library.

Customizing implementations and manipulating the component state may break some important assumptions and introduce vulnerabilities.
While we try to ensure the components remain secure in the face of a wide range of potential customizations, this is done in a best-effort manner.
Any and all customizations to the component logic should be carefully reviewed and checked against the source code of the component they are customizing so as to fully understand their impact and guarantee their security. 
// llmstxt-short-description: Lists the presets of the library with their corresponding class hashes

:account-upgradeable: xref:/api/account.adoc#AccountUpgradeable[AccountUpgradeable]
:erc20-upgradeable: xref:/api/erc20.adoc#ERC20Upgradeable[ERC20Upgradeable]
:erc721-upgradeable: xref:/api/erc721.adoc#ERC721Upgradeable[ERC721Upgradeable]
:erc1155-upgradeable: xref:/api/erc1155.adoc#ERC1155Upgradeable[ERC1155Upgradeable]
:eth-account-upgradeable: xref:/api/account.adoc#EthAccountUpgradeable[EthAccountUpgradeable]
:udc: xref:/api/udc.adoc#UniversalDeployer[UniversalDeployer]
:vesting-wallet: xref:/api/finance.adoc#VestingWallet[VestingWallet]
:sierra-class-hashes: https://docs.starknet.io/architecture-and-concepts/smart-contracts/class-hash/[Sierra class hashes]
:starkli: https://book.starkli.rs/introduction[starkli]
:wizard: https://wizard.openzeppelin.com[Wizard for Cairo]


= Presets

include::utils/_class_hashes.adoc[]

Presets are ready-to-deploy contracts provided by the library. Since presets are intended to be very simple
and as generic as possible, there's no support for custom or complex contracts such as `ERC20Pausable` or `ERC721Mintable`.

TIP: For contract customization and combination of modules you can use {wizard}, our code-generation tool.


== Available presets

List of available presets and their corresponding {sierra-class-hashes}.

NOTE: Class hashes were computed using {class-hash-cairo-version}.

|===
| Name | Sierra Class Hash

| `{account-upgradeable}`
| `{AccountUpgradeable-class-hash}`

| `{erc20-upgradeable}`
| `{ERC20Upgradeable-class-hash}`

| `{erc721-upgradeable}`
| `{ERC721Upgradeable-class-hash}`

| `{erc1155-upgradeable}`
| `{ERC1155Upgradeable-class-hash}`

| `{eth-account-upgradeable}`
| `{EthAccountUpgradeable-class-hash}`

| `{udc}`
| `{UniversalDeployer-class-hash}`

| `{vesting-wallet}`
| `{VestingWallet-class-hash}`
|===

TIP: {starkli} class-hash command can be used to compute the class hash from a Sierra artifact.

== Usage

:setup_project: xref:index.adoc#set_up_your_project[setting up a project]
:install_lib: xref:index.adoc#install the_library[installing the Contracts for Cairo library]
:presets_dir: link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/presets/src[presets directory]

These preset contracts are ready-to-deploy which means they should already be declared on the Sepolia network.
Simply deploy the preset class hash and add the appropriate constructor arguments.
Deploying the ERC20Upgradeable preset with {starkli}, for example, will look like this:

[,bash, subs="verbatim,attributes"]
----
starkli deploy {ERC20Upgradeable-class-hash} \
  <CONSTRUCTOR_ARGS> \
  --network="sepolia"
----

If a class hash has yet to be declared, copy/paste the preset contract code and declare it locally.
Start by {setup_project} and {install_lib}.
Copy the target preset contract from the {presets_dir} and paste it in the new project's `src/lib.cairo` like this:

[,cairo]
----
// src/lib.cairo

#[starknet::contract]
mod ERC20Upgradeable {
    use openzeppelin_access::ownable::OwnableComponent;
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use openzeppelin_upgrades::UpgradeableComponent;
    use openzeppelin_upgrades::interface::IUpgradeable;
    use starknet::{ContractAddress, ClassHash};

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);
    component!(path: ERC20Component, storage: erc20, event: ERC20Event);
    component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);

    // Ownable Mixin
    #[abi(embed_v0)]
    impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;
    impl OwnableInternalImpl = OwnableComponent::InternalImpl<ContractState>;

    // ERC20 Mixin
    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    // Upgradeable
    impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        ownable: OwnableComponent::Storage,
        #[substorage(v0)]
        erc20: ERC20Component::Storage,
        #[substorage(v0)]
        upgradeable: UpgradeableComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        OwnableEvent: OwnableComponent::Event,
        #[flat]
        ERC20Event: ERC20Component::Event,
        #[flat]
        UpgradeableEvent: UpgradeableComponent::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        name: ByteArray,
        symbol: ByteArray,
        fixed_supply: u256,
        recipient: ContractAddress,
        owner: ContractAddress
    ) {
        self.ownable.initializer(owner);
        self.erc20.initializer(name, symbol);
        self.erc20.mint(recipient, fixed_supply);
    }

    #[abi(embed_v0)]
    impl UpgradeableImpl of IUpgradeable<ContractState> {
        fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {
            self.ownable.assert_only_owner();
            self.upgradeable.upgrade(new_class_hash);
        }
    }
}
----

Next, compile the contract.

[,bash]
----
scarb build
----

Finally, declare the preset.

[,bash]
----
starkli declare target/dev/my_project_ERC20Upgradeable.contract_class.json \
  --network="sepolia"
----
// llmstxt-short-description: Describes the design choices behind the interfaces and dispatchers of the library

:great-interface-migration: link:https://community.starknet.io/t/the-great-interface-migration/92107[Great Interface Migration]

= Interfaces and Dispatchers

This section describes the interfaces OpenZeppelin Contracts for Cairo offer, and explains the design choices behind them.

Interfaces can be found in the module tree under the `interface` submodule, such as `token::erc20::interface`. For example:

```cairo
use openzeppelin_token::erc20::interface::IERC20;
```

or

```cairo
use openzeppelin_token::erc20::interface::ERC20ABI;
```

NOTE: For simplicity, we'll use ERC20 as example but the same concepts apply to other modules.

== Interface traits

The library offers three types of traits to implement or interact with contracts:

=== Standard traits

These are associated with a predefined interface such as a standard.
This includes only the functions defined in the interface, and is the standard way to interact with a compliant contract.

```cairo
#[starknet::interface]
pub trait IERC20<TState> {
    fn total_supply(self: @TState) -> u256;
    fn balance_of(self: @TState, account: ContractAddress) -> u256;
    fn allowance(self: @TState, owner: ContractAddress, spender: ContractAddress) -> u256;
    fn transfer(ref self: TState, recipient: ContractAddress, amount: u256) -> bool;
    fn transfer_from(
        ref self: TState, sender: ContractAddress, recipient: ContractAddress, amount: u256
    ) -> bool;
    fn approve(ref self: TState, spender: ContractAddress, amount: u256) -> bool;
}
```

=== ABI traits

They describe a contract's complete interface. This is useful to interface with a preset contract offered by this library, such as the ERC20 preset that includes functions from different traits such as `IERC20` and `IERC20Camel`.

NOTE: The library offers an ABI trait for most components, providing all external function signatures
even when most of the time all of them don't need to be implemented at the same time. This can be helpful when interacting with a contract implementing the component, instead of defining a new dispatcher.

```cairo
#[starknet::interface]
pub trait ERC20ABI<TState> {
    // IERC20
    fn total_supply(self: @TState) -> u256;
    fn balance_of(self: @TState, account: ContractAddress) -> u256;
    fn allowance(self: @TState, owner: ContractAddress, spender: ContractAddress) -> u256;
    fn transfer(ref self: TState, recipient: ContractAddress, amount: u256) -> bool;
    fn transfer_from(
        ref self: TState, sender: ContractAddress, recipient: ContractAddress, amount: u256
    ) -> bool;
    fn approve(ref self: TState, spender: ContractAddress, amount: u256) -> bool;

    // IERC20Metadata
    fn name(self: @TState) -> ByteArray;
    fn symbol(self: @TState) -> ByteArray;
    fn decimals(self: @TState) -> u8;

    // IERC20CamelOnly
    fn totalSupply(self: @TState) -> u256;
    fn balanceOf(self: @TState, account: ContractAddress) -> u256;
    fn transferFrom(
        ref self: TState, sender: ContractAddress, recipient: ContractAddress, amount: u256
    ) -> bool;
}
```

=== Dispatcher traits

:interacting-with-another-contract: https://book.cairo-lang.org/ch15-02-interacting-with-another-contract.html[Interacting with another contract]

Traits annotated with `#[starknet::interface]` automatically generate a dispatcher that can be used to interact with contracts that implement the given interface. They can be imported by appending the `Dispatcher` and `DispatcherTrait` suffixes to the trait name, like this:

```cairo
use openzeppelin_token::erc20::interface::{IERC20Dispatcher, IERC20DispatcherTrait};
```

Other types of dispatchers are also auto-generated from the annotated trait. See the
{interacting-with-another-contract} section of the Cairo book for more information.

NOTE: In the example, the `IERC20Dispatcher` is the one used to interact with contracts, but the
`IERC20DispatcherTrait` needs to be in scope for the functions to be available.

== Dual interfaces

WARNING: `camelCase` functions are deprecated and maintained only for Backwards Compatibility.
It's recommended to only use `snake_case` interfaces with contracts and components. The `camelCase` functions will be removed in
future versions.

Following the {great-interface-migration} plan, we added `snake_case` functions to all of our preexisting `camelCase` contracts with the goal of eventually dropping support for the latter.

In short, the library offers two types of interfaces and utilities to handle them:

1. `camelCase` interfaces, which are the ones we've been using so far.
2. `snake_case` interfaces, which are the ones we're migrating to.

This means that currently most of our contracts implement _dual interfaces_. For example, the ERC20 preset contract exposes `transferFrom`, `transfer_from`, `balanceOf`, `balance_of`, etc.

NOTE: Dual interfaces are available for all external functions present in previous versions of OpenZeppelin Contracts for Cairo (https://github.com/OpenZeppelin/cairo-contracts/releases/tag/v0.6.1[v0.6.1] and below).

=== `IERC20`

The default version of the ERC20 interface trait exposes `snake_case` functions:

```cairo
#[starknet::interface]
pub trait IERC20<TState> {
    fn name(self: @TState) -> ByteArray;
    fn symbol(self: @TState) -> ByteArray;
    fn decimals(self: @TState) -> u8;
    fn total_supply(self: @TState) -> u256;
    fn balance_of(self: @TState, account: ContractAddress) -> u256;
    fn allowance(self: @TState, owner: ContractAddress, spender: ContractAddress) -> u256;
    fn transfer(ref self: TState, recipient: ContractAddress, amount: u256) -> bool;
    fn transfer_from(
        ref self: TState, sender: ContractAddress, recipient: ContractAddress, amount: u256
    ) -> bool;
    fn approve(ref self: TState, spender: ContractAddress, amount: u256) -> bool;
}
```

=== `IERC20Camel`

On top of that, the library also offers a `camelCase` version of the same interface:

```cairo
#[starknet::interface]
pub trait IERC20Camel<TState> {
    fn name(self: @TState) -> ByteArray;
    fn symbol(self: @TState) -> ByteArray;
    fn decimals(self: @TState) -> u8;
    fn totalSupply(self: @TState) -> u256;
    fn balanceOf(self: @TState, account: ContractAddress) -> u256;
    fn allowance(self: @TState, owner: ContractAddress, spender: ContractAddress) -> u256;
    fn transfer(ref self: TState, recipient: ContractAddress, amount: u256) -> bool;
    fn transferFrom(
        ref self: TState, sender: ContractAddress, recipient: ContractAddress, amount: u256
    ) -> bool;
    fn approve(ref self: TState, spender: ContractAddress, amount: u256) -> bool;
}
```
// llmstxt-short-description: Guide describing the process of counterfactual deployments in Starknet

:foundry: https://foundry-rs.github.io/starknet-foundry/starknet/account.html[Starknet Foundry]
:starkli: https://book.starkli.rs/accounts#account-deployment[Starkli]

= Counterfactual deployments

A counterfactual contract is a contract we can interact with even before actually deploying it on-chain.
For example, we can send funds or assign privileges to a contract that doesn't yet exist.
Why? Because deployments in Starknet are deterministic, allowing us to predict the address where our contract will be deployed.
We can leverage this property to make a contract pay for its own deployment by simply sending funds in advance. We call this a counterfactual deployment.

This process can be described with the following steps:

TIP: For testing this flow you can check the {foundry} or the {starkli} guides for deploying accounts.

1. Deterministically precompute the `contract_address` given a `class_hash`, `salt`, and constructor `calldata`.
Note that the `class_hash` must be previously declared for the deployment to succeed.

2. Send funds to the `contract_address`. Usually you will estimate the fee of the transaction first. Existing
tools usually do this for you.

3. Send a `DeployAccount` type transaction to the network.

4. The protocol will then validate the transaction with the `\\__validate_deploy__` entrypoint of the contract to be deployed.

5. If the validation succeeds, the protocol will charge the fee and then register the contract as deployed.

NOTE: Although this method is very popular to deploy accounts, this works for any kind of contract.

== Deployment validation

To be counterfactually deployed, the deploying contract must implement the `\\__validate_deploy__` entrypoint,
called by the protocol when a `DeployAccount` transaction is sent to the network.

[,cairo]
----
trait IDeployable {
    /// Must return 'VALID' when the validation is successful.
    fn __validate_deploy__(
        class_hash: felt252, contract_address_salt: felt252, public_key: felt252
    ) -> felt252;
}
----
// llmstxt-short-description: Guide describing the SNIP12 standard and how to implement it in Cairo

:snip12: https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md[SNIP12]
:eip712: https://eips.ethereum.org/EIPS/eip-712[EIP712]
:erc20: xref:/api/erc20.adoc#ERC20[ERC20]
:erc20-component: xref:/api/erc20.adoc#ERC20Component[ERC20Component]

= SNIP12 and Typed Messages

Similar to {eip712}, {snip12} is a standard for secure off-chain signature verification on Starknet.
It provides a way to hash and sign generic typed structs rather than just strings. When building decentralized
applications, usually you might need to sign a message with complex data. The purpose of signature verification
is then to ensure that the received message was indeed signed by the expected signer, and it hasn't been tampered with.

OpenZeppelin Contracts for Cairo provides a set of utilities to make the implementation of this standard
as easy as possible, and in this guide we will walk you through the process of generating the hashes of typed messages
using these utilities for on-chain signature verification. For that, let's build an example with a custom {erc20} contract
adding an extra `transfer_with_signature` method.

WARNING: This is an educational example, and it is not intended to be used in production environments.

== CustomERC20

Let's start with a basic ERC20 contract leveraging the {erc20-component}, and let's add the new function.
Note that some declarations are omitted for brevity. The full example will be available at the end of the guide.

[,cairo]
----
#[starknet::contract]
mod CustomERC20 {
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    (...)

    #[constructor]
    fn constructor(
        ref self: ContractState,
        initial_supply: u256,
        recipient: ContractAddress
    ) {
        self.erc20.initializer("MyToken", "MTK");
        self.erc20.mint(recipient, initial_supply);
    }

    #[external(v0)]
    fn transfer_with_signature(
        ref self: ContractState,
        recipient: ContractAddress,
        amount: u256,
        nonce: felt252,
        expiry: u64,
        signature: Array<felt252>
    ) {
        (...)
    }
}
----

The `transfer_with_signature` function will allow a user to transfer tokens to another account by providing a signature.
The signature will be generated off-chain, and it will be used to verify the message on-chain. Note that the message
we need to verify is a struct with the following fields:

- `recipient`: The address of the recipient.
- `amount`: The amount of tokens to transfer.
- `nonce`: A unique number to prevent replay attacks.
- `expiry`: The timestamp when the signature expires.

Note that generating the hash of this message on-chain is a requirement to verify the signature, because if we accept
the message as a parameter, it could be easily tampered with.

== Generating the Typed Message Hash

:snip: https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md#how-to-work-with-each-type[SNIP]

To generate the hash of the message, we need to follow these steps:

=== 1. Define the message struct.

In this particular example, the message struct looks like this:

[,cairo]
----
struct Message {
    recipient: ContractAddress,
    amount: u256,
    nonce: felt252,
    expiry: u64
}
----

=== 2. Get the message type hash.

This is the `starknet_keccak(encode_type(message))` as defined in the {snip}.

In this case it can be computed as follows:

[,cairo]
----
// Since there's no u64 type in SNIP-12, we use u128 for `expiry` in the type hash generation.
let message_type_hash = selector!(
    "\"Message\"(\"recipient\":\"ContractAddress\",\"amount\":\"u256\",\"nonce\":\"felt\",\"expiry\":\"u128\")\"u256\"(\"low\":\"u128\",\"high\":\"u128\")"
);
----

which is the same as:

[,cairo]
----
let message_type_hash = 0x28bf13f11bba405c77ce010d2781c5903cbed100f01f72fcff1664f98343eb6;
----

NOTE: In practice it's better to compute the type hash off-chain and hardcode it in the contract, since it is a constant value.

=== 3. Implement the `StructHash` trait for the struct.

You can import the trait from: `openzeppelin_utils::snip12::StructHash`. And this implementation
is nothing more than the encoding of the message as defined in the {snip}.

[,cairo]
----
use core::hash::{HashStateExTrait, HashStateTrait};
use core::poseidon::PoseidonTrait;
use openzeppelin_utils::snip12::StructHash;
use starknet::ContractAddress;

const MESSAGE_TYPE_HASH: felt252 =
    0x28bf13f11bba405c77ce010d2781c5903cbed100f01f72fcff1664f98343eb6;

#[derive(Copy, Drop, Hash)]
struct Message {
    recipient: ContractAddress,
    amount: u256,
    nonce: felt252,
    expiry: u64
}

impl StructHashImpl of StructHash<Message> {
    fn hash_struct(self: @Message) -> felt252 {
        let hash_state = PoseidonTrait::new();
        hash_state.update_with(MESSAGE_TYPE_HASH).update_with(*self).finalize()
    }
}
----

=== 4. Implement the `SNIP12Metadata` trait.

This implementation determines the values of the domain separator. Only the `name` and `version` fields are required
because the `chain_id` is obtained on-chain, and the `revision` is hardcoded to `1`.

[,cairo]
----
use openzeppelin_utils::snip12::SNIP12Metadata;

impl SNIP12MetadataImpl of SNIP12Metadata {
    fn name() -> felt252 { 'DAPP_NAME' }
    fn version() -> felt252 { 'v1' }
}
----

In the above example, no storage reads are required which avoids unnecessary extra gas costs, but in
some cases we may need to read from storage to get the domain separator values. This can be accomplished even when
the trait is not bounded to the ContractState, like this:

[,cairo]
----
use openzeppelin_utils::snip12::SNIP12Metadata;

impl SNIP12MetadataImpl of SNIP12Metadata {
    fn name() -> felt252 {
        let state = unsafe_new_contract_state();

        // Some logic to get the name from storage
        state.erc20.name().at(0).unwrap().into()
    }

    fn version() -> felt252 { 'v1' }
}
----

=== 5. Generate the hash.

The final step is to use the `OffchainMessageHashImpl` implementation to generate the hash of the message
using the `get_message_hash` function. The implementation is already available as a utility.

[,cairo]
----
use core::hash::{HashStateExTrait, HashStateTrait};
use core::poseidon::PoseidonTrait;
use openzeppelin_utils::snip12::{SNIP12Metadata, StructHash, OffchainMessageHash};
use starknet::ContractAddress;

const MESSAGE_TYPE_HASH: felt252 =
    0x28bf13f11bba405c77ce010d2781c5903cbed100f01f72fcff1664f98343eb6;

#[derive(Copy, Drop, Hash)]
struct Message {
    recipient: ContractAddress,
    amount: u256,
    nonce: felt252,
    expiry: u64
}

impl StructHashImpl of StructHash<Message> {
    fn hash_struct(self: @Message) -> felt252 {
        let hash_state = PoseidonTrait::new();
        hash_state.update_with(MESSAGE_TYPE_HASH).update_with(*self).finalize()
    }
}

impl SNIP12MetadataImpl of SNIP12Metadata {
    fn name() -> felt252 {
        'DAPP_NAME'
    }
    fn version() -> felt252 {
        'v1'
    }
}

fn get_hash(
    account: ContractAddress, recipient: ContractAddress, amount: u256, nonce: felt252, expiry: u64
) -> felt252 {
    let message = Message { recipient, amount, nonce, expiry };
    message.get_message_hash(account)
}
----

TIP: The expected parameter for the `get_message_hash` function is the address of account that signed the message.

== Full Implementation

:isrc6_dispatcher: xref:/api/account#ISRC6
:nonces: xref:/api/utilities#NoncesComponent

Finally, the full implementation of the `CustomERC20` contract looks like this:

NOTE: We are using the {isrc6_dispatcher}[`ISRC6Dispatcher`] to verify the signature,
and the {nonces}[`NoncesComponent`] to handle nonces to prevent replay attacks.

[,cairo]
----
use core::hash::{HashStateExTrait, HashStateTrait};
use core::poseidon::PoseidonTrait;
use openzeppelin_utils::snip12::{SNIP12Metadata, StructHash, OffchainMessageHash};
use starknet::ContractAddress;

const MESSAGE_TYPE_HASH: felt252 =
    0x28bf13f11bba405c77ce010d2781c5903cbed100f01f72fcff1664f98343eb6;

#[derive(Copy, Drop, Hash)]
struct Message {
    recipient: ContractAddress,
    amount: u256,
    nonce: felt252,
    expiry: u64
}

impl StructHashImpl of StructHash<Message> {
    fn hash_struct(self: @Message) -> felt252 {
        let hash_state = PoseidonTrait::new();
        hash_state.update_with(MESSAGE_TYPE_HASH).update_with(*self).finalize()
    }
}

#[starknet::contract]
mod CustomERC20 {
    use openzeppelin_account::interface::{ISRC6Dispatcher, ISRC6DispatcherTrait};
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use openzeppelin_utils::cryptography::nonces::NoncesComponent;
    use starknet::ContractAddress;

    use super::{Message, OffchainMessageHash, SNIP12Metadata};

    component!(path: ERC20Component, storage: erc20, event: ERC20Event);
    component!(path: NoncesComponent, storage: nonces, event: NoncesEvent);

    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    #[abi(embed_v0)]
    impl NoncesImpl = NoncesComponent::NoncesImpl<ContractState>;
    impl NoncesInternalImpl = NoncesComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc20: ERC20Component::Storage,
        #[substorage(v0)]
        nonces: NoncesComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC20Event: ERC20Component::Event,
        #[flat]
        NoncesEvent: NoncesComponent::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState, initial_supply: u256, recipient: ContractAddress) {
        self.erc20.initializer("MyToken", "MTK");
        self.erc20.mint(recipient, initial_supply);
    }

    /// Required for hash computation.
    impl SNIP12MetadataImpl of SNIP12Metadata {
        fn name() -> felt252 {
            'CustomERC20'
        }
        fn version() -> felt252 {
            'v1'
        }
    }

    #[external(v0)]
    fn transfer_with_signature(
        ref self: ContractState,
        recipient: ContractAddress,
        amount: u256,
        nonce: felt252,
        expiry: u64,
        signature: Array<felt252>
    ) {
        assert(starknet::get_block_timestamp() <= expiry, 'Expired signature');
        let owner = starknet::get_caller_address();

        // Check and increase nonce
        self.nonces.use_checked_nonce(owner, nonce);

        // Build hash for calling `is_valid_signature`
        let message = Message { recipient, amount, nonce, expiry };
        let hash = message.get_message_hash(owner);

        let is_valid_signature_felt = ISRC6Dispatcher { contract_address: owner }
            .is_valid_signature(hash, signature);

        // Check either 'VALID' or true for backwards compatibility
        let is_valid_signature = is_valid_signature_felt == starknet::VALIDATED
            || is_valid_signature_felt == 1;
        assert(is_valid_signature, 'Invalid signature');

        // Transfer tokens
        self.erc20._transfer(owner, recipient, amount);
    }
}
----
// llmstxt-short-description: Describes different forms of access control, including ownership and role-based access

:ownable-cairo: xref:api/access.adoc#OwnableComponent[OwnableComponent]
:sn_keccak: https://docs.starknet.io/architecture-and-concepts/cryptography/#starknet_keccak[sn_keccak]

= Access

Access control--that is, "who is allowed to do this thing"—is incredibly important in the world of smart contracts.
The access control of your contract may govern who can mint tokens, vote on proposals, freeze transfers, and many other things.
It is therefore critical to understand how you implement it, lest someone else
https://blog.openzeppelin.com/on-the-parity-wallet-multisig-hack-405a8c12e8f7/[steals your whole system].

== Ownership and `Ownable`

The most common and basic form of access control is the concept of ownership: there's an account that is the `owner`
of a contract and can do administrative tasks on it.
This approach is perfectly reasonable for contracts that have a single administrative user.

OpenZeppelin Contracts for Cairo provides {ownable-cairo} for implementing ownership in your contracts.

=== Usage

Integrating this component into a contract first requires assigning an owner.
The implementing contract's constructor should set the initial owner by passing the owner's address to Ownable's
xref:/api/access.adoc#OwnableComponent-initializer[`initializer`] like this:

[,cairo]
----
#[starknet::contract]
mod MyContract {
    use openzeppelin_access::ownable::OwnableComponent;
    use starknet::ContractAddress;

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);

    // Ownable Mixin
    #[abi(embed_v0)]
    impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;
    impl InternalImpl = OwnableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        ownable: OwnableComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        OwnableEvent: OwnableComponent::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: ContractAddress) {
        // Set the initial owner of the contract
        self.ownable.initializer(owner);
    }

    (...)
}
----

To restrict a function's access to the owner only, add in the `assert_only_owner` method:

[,cairo]
----
#[starknet::contract]
mod MyContract {
    (...)

    #[external(v0)]
    fn only_owner_allowed(ref self: ContractState) {
        // This function can only be called by the owner
        self.ownable.assert_only_owner();

        (...)
    }
}
----

=== Interface

This is the full interface of the `OwnableMixinImpl` implementation:

[,cairo]
----
#[starknet::interface]
pub trait OwnableABI {
    // IOwnable
    fn owner() -> ContractAddress;
    fn transfer_ownership(new_owner: ContractAddress);
    fn renounce_ownership();

    // IOwnableCamelOnly
    fn transferOwnership(newOwner: ContractAddress);
    fn renounceOwnership();
}
----

Ownable also lets you:

- `transfer_ownership` from the owner account to a new one, and
- `renounce_ownership` for the owner to relinquish this administrative privilege, a common pattern
after an initial stage with centralized administration is over.

WARNING: Removing the owner altogether will mean that administrative tasks that are protected by `assert_only_owner`
will no longer be callable!

=== Two step transfer

The component also offers a more robust way of transferring ownership via the
xref:/api/access.adoc#OwnableTwoStepImpl[OwnableTwoStepImpl] implementation. A two step transfer mechanism helps
to prevent unintended and irreversible owner transfers. Simply replace the `OwnableMixinImpl`
with its respective two step variant:

[,cairo]
----
#[abi(embed_v0)]
impl OwnableTwoStepMixinImpl = OwnableComponent::OwnableTwoStepMixinImpl<ContractState>;
----

[#interface-twostep]
==== Interface

This is the full interface of the two step `OwnableTwoStepMixinImpl` implementation:

[,cairo]
----
#[starknet::interface]
pub trait OwnableTwoStepABI {
    // IOwnableTwoStep
    fn owner() -> ContractAddress;
    fn pending_owner() -> ContractAddress;
    fn accept_ownership();
    fn transfer_ownership(new_owner: ContractAddress);
    fn renounce_ownership();

    // IOwnableTwoStepCamelOnly
    fn pendingOwner() -> ContractAddress;
    fn acceptOwnership();
    fn transferOwnership(newOwner: ContractAddress);
    fn renounceOwnership();
}
----

== Role-Based `AccessControl`

:access-control: xref:api/access.adoc#AccessControlComponent[AccessControl]

While the simplicity of ownership can be useful for simple systems or quick prototyping, different levels of
authorization are often needed. You may want for an account to have permission to ban users from a system, but not
create new tokens. https://en.wikipedia.org/wiki/Role-based_access_control[Role-Based Access Control (RBAC)] offers
flexibility in this regard.

In essence, we will be defining multiple roles, each allowed to perform different sets of actions.
An account may have, for example, 'moderator', 'minter' or 'admin' roles, which you will then check for
instead of simply using xref:/api/access.adoc#OwnableComponent-assert_only_owner[`assert_only_owner`]. This check can be enforced through xref:/api/access.adoc#AccessControlComponent-assert_only_role[`assert_only_role`].
Separately, you will be able to define rules for how accounts can be granted a role, have it revoked, and more.

Most software uses access control systems that are role-based: some users are regular users, some may be supervisors
or managers, and a few will often have administrative privileges.

=== Usage

For each role that you want to define, you will create a new _role identifier_ that is used to grant, revoke, and
check if an account has that role. See xref:#creating_role_identifiers[Creating role identifiers] for information
on creating identifiers.

Here's a simple example of implementing {access-control} on a portion of an ERC20 token contract which defines
and sets a 'minter' role:

[,cairo]
----
const MINTER_ROLE: felt252 = selector!("MINTER_ROLE");

#[starknet::contract]
mod MyContract {
    use openzeppelin_access::accesscontrol::AccessControlComponent;
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use starknet::ContractAddress;
    use super::MINTER_ROLE;

    component!(path: AccessControlComponent, storage: accesscontrol, event: AccessControlEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);
    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    // AccessControl
    #[abi(embed_v0)]
    impl AccessControlImpl =
        AccessControlComponent::AccessControlImpl<ContractState>;
    impl AccessControlInternalImpl = AccessControlComponent::InternalImpl<ContractState>;

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;

    // ERC20
    #[abi(embed_v0)]
    impl ERC20Impl = ERC20Component::ERC20Impl<ContractState>;
    #[abi(embed_v0)]
    impl ERC20MetadataImpl = ERC20Component::ERC20MetadataImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        accesscontrol: AccessControlComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage,
        #[substorage(v0)]
        erc20: ERC20Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        AccessControlEvent: AccessControlComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event,
        #[flat]
        ERC20Event: ERC20Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        name: ByteArray,
        symbol: ByteArray,
        initial_supply: u256,
        recipient: ContractAddress,
        minter: ContractAddress
    ) {
        // ERC20-related initialization
        self.erc20.initializer(name, symbol);
        self.erc20.mint(recipient, initial_supply);

        // AccessControl-related initialization
        self.accesscontrol.initializer();
        self.accesscontrol._grant_role(MINTER_ROLE, minter);
    }

    /// This function can only be called by a minter.
    #[external(v0)]
    fn mint(ref self: ContractState, recipient: ContractAddress, amount: u256) {
        self.accesscontrol.assert_only_role(MINTER_ROLE);
        self.erc20.mint(recipient, amount);
    }
}
----

CAUTION: Make sure you fully understand how {access-control} works before
using it on your system, or copy-pasting the examples from this guide.

While clear and explicit, this isn't anything we wouldn't have been able to achieve with
xref:api/access.adoc#OwnableComponent[Ownable]. Where {access-control} shines the most is in scenarios where granular
permissions are required, which can be implemented by defining _multiple_ roles.

Let's augment our ERC20 token example by also defining a 'burner' role, which lets accounts destroy tokens:

[,cairo]
----
const MINTER_ROLE: felt252 = selector!("MINTER_ROLE");
const BURNER_ROLE: felt252 = selector!("BURNER_ROLE");

#[starknet::contract]
mod MyContract {
    use openzeppelin_access::accesscontrol::AccessControlComponent;
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use starknet::ContractAddress;
    use super::{MINTER_ROLE, BURNER_ROLE};

    component!(path: AccessControlComponent, storage: accesscontrol, event: AccessControlEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);
    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    // AccessControl
    #[abi(embed_v0)]
    impl AccessControlImpl =
        AccessControlComponent::AccessControlImpl<ContractState>;
    impl AccessControlInternalImpl = AccessControlComponent::InternalImpl<ContractState>;

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;

    // ERC20
    #[abi(embed_v0)]
    impl ERC20Impl = ERC20Component::ERC20Impl<ContractState>;
    #[abi(embed_v0)]
    impl ERC20MetadataImpl = ERC20Component::ERC20MetadataImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        accesscontrol: AccessControlComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage,
        #[substorage(v0)]
        erc20: ERC20Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        AccessControlEvent: AccessControlComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event,
        #[flat]
        ERC20Event: ERC20Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        name: ByteArray,
        symbol: ByteArray,
        initial_supply: u256,
        recipient: ContractAddress,
        minter: ContractAddress,
        burner: ContractAddress
    ) {
        // ERC20-related initialization
        self.erc20.initializer(name, symbol);
        self.erc20.mint(recipient, initial_supply);

        // AccessControl-related initialization
        self.accesscontrol.initializer();
        self.accesscontrol._grant_role(MINTER_ROLE, minter);
        self.accesscontrol._grant_role(BURNER_ROLE, burner);
    }

    /// This function can only be called by a minter.
    #[external(v0)]
    fn mint(ref self: ContractState, recipient: ContractAddress, amount: u256) {
        self.accesscontrol.assert_only_role(MINTER_ROLE);
        self.erc20.mint(recipient, amount);
    }

    /// This function can only be called by a burner.
    #[external(v0)]
    fn burn(ref self: ContractState, account: ContractAddress, amount: u256) {
        self.accesscontrol.assert_only_role(BURNER_ROLE);
        self.erc20.burn(account, amount);
    }
}
----

So clean!
By splitting concerns this way, more granular levels of permission may be implemented than were possible with the
simpler ownership approach to access control. Limiting what each component of a system is able to do is known
as the https://en.wikipedia.org/wiki/Principle_of_least_privilege[principle of least privilege], and is a good
security practice. Note that each account may still have more than one role, if so desired.

=== Granting and revoking roles

The ERC20 token example above uses xref:api/access.adoc#AccessControlComponent-_grant_role[`_grant_role`],
an `internal` function that is useful when programmatically assigning
roles (such as during construction). But what if we later want to grant the 'minter' role to additional accounts?

By default, *accounts with a role cannot grant it or revoke it from other accounts*: all having a role does is making
the xref:api/access.adoc#AccessControlComponent-assert_only_role[`assert_only_role`] check pass. To grant and revoke roles dynamically, you will need help from the role's _admin_.

Every role has an associated admin role, which grants permission to call the
xref:api/access.adoc#AccessControlComponent-grant_role[`grant_role`] and
xref:api/access.adoc#AccessControlComponent-revoke_role[`revoke_role`] functions.
A role can be granted or revoked by using these if the calling account has the corresponding admin role.
Multiple roles may have the same admin role to make management easier.
A role's admin can even be the same role itself, which would cause accounts with that role to be able
to also grant and revoke it.

This mechanism can be used to create complex permissioning structures resembling organizational charts, but it also
provides an easy way to manage simpler applications. `AccessControl` includes a special role with the role identifier
of `0`, called `DEFAULT_ADMIN_ROLE`, which acts as the *default admin role for all roles*.
An account with this role will be able to manage any other role, unless
xref:api/access.adoc#AccessControlComponent-set_role_admin[`set_role_admin`] is used to select a new admin role.

Let's take a look at the ERC20 token example, this time taking advantage of the default admin role:

[,cairo]
----
const MINTER_ROLE: felt252 = selector!("MINTER_ROLE");
const BURNER_ROLE: felt252 = selector!("BURNER_ROLE");

#[starknet::contract]
mod MyContract {
    use openzeppelin_access::accesscontrol::AccessControlComponent;
    use openzeppelin_access::accesscontrol::DEFAULT_ADMIN_ROLE;
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use starknet::ContractAddress;
    use super::{MINTER_ROLE, BURNER_ROLE};

    component!(path: AccessControlComponent, storage: accesscontrol, event: AccessControlEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);
    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    // AccessControl
    #[abi(embed_v0)]
    impl AccessControlImpl =
        AccessControlComponent::AccessControlImpl<ContractState>;
    impl AccessControlInternalImpl = AccessControlComponent::InternalImpl<ContractState>;

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;

    // ERC20
    #[abi(embed_v0)]
    impl ERC20Impl = ERC20Component::ERC20Impl<ContractState>;
    #[abi(embed_v0)]
    impl ERC20MetadataImpl = ERC20Component::ERC20MetadataImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    (...)

    #[constructor]
    fn constructor(
        ref self: ContractState,
        name: ByteArray,
        symbol: ByteArray,
        initial_supply: u256,
        recipient: ContractAddress,
        admin: ContractAddress
    ) {
        // ERC20-related initialization
        self.erc20.initializer(name, symbol);
        self.erc20.mint(recipient, initial_supply);

        // AccessControl-related initialization
        self.accesscontrol.initializer();
        self.accesscontrol._grant_role(DEFAULT_ADMIN_ROLE, admin);
    }

    /// This function can only be called by a minter.
    #[external(v0)]
    fn mint(ref self: ContractState, recipient: ContractAddress, amount: u256) {
        self.accesscontrol.assert_only_role(MINTER_ROLE);
        self.erc20.mint(recipient, amount);
    }

    /// This function can only be called by a burner.
    #[external(v0)]
    fn burn(ref self: ContractState, account: ContractAddress, amount: u256) {
        self.accesscontrol.assert_only_role(BURNER_ROLE);
        self.erc20.burn(account, amount);
    }
}
----

TIP: The `grant_role` and `revoke_role` functions are automatically exposed as `external` functions
from the `AccessControlImpl` by leveraging the `#[abi(embed_v0)]` annotation.

Note that, unlike the previous examples, no accounts are granted the 'minter' or 'burner' roles.
However, because those roles' admin role is the default admin role, and that role was granted to the 'admin', that
same account can call `grant_role` to give minting or burning permission, and `revoke_role` to remove it.

Dynamic role allocation is often a desirable property, for example in systems where trust in a participant may vary
over time. It can also be used to support use cases such as https://en.wikipedia.org/wiki/Know_your_customer[KYC],
where the list of role-bearers may not be known up-front, or may be prohibitively expensive to include in a single transaction.

=== Creating role identifiers

In the Solidity implementation of AccessControl, contracts generally refer to the
https://docs.soliditylang.org/en/latest/units-and-global-variables.html?highlight=keccak256#mathematical-and-cryptographic-functions[keccak256 hash]
of a role as the role identifier.

For example:

[,cairo]
----
bytes32 public constant SOME_ROLE = keccak256("SOME_ROLE")
----

These identifiers take up 32 bytes (256 bits).

Cairo field elements (`felt252`) store a maximum of 252 bits.
With this discrepancy, this library maintains an agnostic stance on how contracts should create identifiers.
Some ideas to consider:

* Use {sn_keccak} instead.
* Use Cairo friendly hashing algorithms like Poseidon, which are implemented in the
https://github.com/starkware-libs/cairo/blob/main/corelib/src/poseidon.cairo[Cairo corelib].

TIP: The `selector!` macro can be used to compute {sn_keccak} in Cairo.

=== Interface

This is the full interface of the `AccessControlMixinImpl` implementation:

[,cairo]
----
#[starknet::interface]
pub trait AccessControlABI {
    // IAccessControl
    fn has_role(role: felt252, account: ContractAddress) -> bool;
    fn get_role_admin(role: felt252) -> felt252;
    fn grant_role(role: felt252, account: ContractAddress);
    fn revoke_role(role: felt252, account: ContractAddress);
    fn renounce_role(role: felt252, account: ContractAddress);

    // IAccessControlCamel
    fn hasRole(role: felt252, account: ContractAddress) -> bool;
    fn getRoleAdmin(role: felt252) -> felt252;
    fn grantRole(role: felt252, account: ContractAddress);
    fn revokeRole(role: felt252, account: ContractAddress);
    fn renounceRole(role: felt252, account: ContractAddress);

    // ISRC5
    fn supports_interface(interface_id: felt252) -> bool;
}
----

`AccessControl` also lets you `renounce_role` from the calling account.
The method expects an account as input as an extra security measure, to ensure you are
not renouncing a role from an unintended account.
// llmstxt-short-description: API of the AccessControl and Ownable components, which provide access control mechanisms for Cairo contracts

:github-icon: pass:[<svg class="icon"><use href="#github-icon"/></svg>]
:AccessControl: xref:AccessControlComponent[AccessControl]
:Ownable: xref:OwnableComponent[Ownable]
:src5: https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md[SRC5]
:inner-src5: xref:api/introspection.adoc#ISRC5[SRC5 ID]
:set_role_admin: xref:#AccessControlComponent-set_role_admin[set_role_admin]

= Access Control

include::../utils/_common.adoc[]

This crate provides ways to restrict who can access the functions of a contract or when they can do it.

- {Ownable} is a simple mechanism with a single "owner" role that can be assigned to a single account.
This mechanism can be useful in simple scenarios, but fine grained access needs are likely to outgrow it.
- {AccessControl} provides a general role based access control mechanism. Multiple hierarchical roles can be created and
assigned each to multiple accounts.

== Authorization

[.contract]
[[OwnableComponent]]
=== `++OwnableComponent++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/access/src/ownable/ownable.cairo[{github-icon},role=heading-link]

```cairo
use openzeppelin_access::ownable::OwnableComponent;
```

`Ownable` provides a basic access control mechanism where an account
 (an owner) can be granted exclusive access to specific functions.

This module includes the internal `assert_only_owner` to restrict a function to be used only by the owner.

[.contract-index#OwnableComponent-Mixin-Impl]
.{mixin-impls}

--
.OwnableMixinImpl

* xref:#OwnableComponent-Embeddable-Impls-OwnableImpl[`++OwnableImpl++`]
* xref:#OwnableComponent-Embeddable-Impls-OwnableCamelOnlyImpl[`++OwnableCamelOnlyImpl++`]

.OwnableTwoStepMixinImpl

* xref:#OwnableComponent-Embeddable-Impls-OwnableTwoStepImpl[`++OwnableTwoStepImpl++`]
* xref:#OwnableComponent-Embeddable-Impls-OwnableTwoStepCamelOnlyImpl[`++OwnableTwoStepCamelOnlyImpl++`]
--

[.contract-index#OwnableComponent-Embeddable-Impls]
.Embeddable Implementations
--
[.sub-index#OwnableComponent-Embeddable-Impls-OwnableImpl]
.OwnableImpl

* xref:OwnableComponent-owner[`++owner(self)++`]
* xref:OwnableComponent-transfer_ownership[`++transfer_ownership(self, new_owner)++`]
* xref:OwnableComponent-renounce_ownership[`++renounce_ownership(self)++`]

[.sub-index#OwnableComponent-Embeddable-Impls-OwnableTwoStepImpl]
.OwnableTwoStepImpl

* xref:OwnableComponent-two-step-owner[`++owner(self)++`]
* xref:OwnableComponent-two-step-pending_owner[`++pending_owner(self)++`]
* xref:OwnableComponent-two-step-accept_ownership[`++accept_ownership(self)++`]
* xref:OwnableComponent-two-step-transfer_ownership[`++transfer_ownership(self, new_owner)++`]
* xref:OwnableComponent-two-step-renounce_ownership[`++renounce_ownership(self)++`]

[.sub-index#OwnableComponent-Embeddable-Impls-OwnableCamelOnlyImpl]
.OwnableCamelOnlyImpl

* xref:OwnableComponent-transferOwnership[`++transferOwnership(self, newOwner)++`]
* xref:OwnableComponent-renounceOwnership[`++renounceOwnership(self)++`]

[.sub-index#OwnableComponent-Embeddable-Impls-OwnableTwoStepCamelOnlyImpl]
.OwnableTwoStepCamelOnlyImpl

* xref:OwnableComponent-two-step-pendingOwner[`++pendingOwner(self)++`]
* xref:OwnableComponent-two-step-acceptOwnership[`++acceptOwnership(self)++`]
* xref:OwnableComponent-two-step-transferOwnership[`++transferOwnership(self, new_owner)++`]
* xref:OwnableComponent-two-step-renounceOwnership[`++renounceOwnership(self)++`]
--

[.contract-index]
.Internal Implementations
--
.InternalImpl

* xref:OwnableComponent-initializer[`++initializer(self, owner)++`]
* xref:OwnableComponent-assert_only_owner[`++assert_only_owner(self)++`]
* xref:OwnableComponent-_transfer_ownership[`++_transfer_ownership(self, new_owner)++`]
* xref:OwnableComponent-_propose_owner[`++_propose_owner(self, new_owner)++`]
--

[.contract-index]
.Events
--
* xref:OwnableComponent-OwnershipTransferStarted[`++OwnershipTransferStarted(previous_owner, new_owner)++`]
* xref:OwnableComponent-OwnershipTransferred[`++OwnershipTransferred(previous_owner, new_owner)++`]
--

[#OwnableComponent-Embeddable-Functions]
==== Embeddable functions

[.contract-item]
[[OwnableComponent-owner]]
==== `[.contract-item-name]#++owner++#++(self: @ContractState) → ContractAddress++` [.item-kind]#external#
// tag::owner[]
Returns the address of the current owner.
// end::owner[]

[.contract-item]
[[OwnableComponent-transfer_ownership]]
==== `[.contract-item-name]#++transfer_ownership++#++(ref self: ContractState, new_owner: ContractAddress)++` [.item-kind]#external#

Transfers ownership of the contract to a new account (`new_owner`).
Can only be called by the current owner.

Emits an xref:OwnableComponent-OwnershipTransferred[OwnershipTransferred] event.

[.contract-item]
[[OwnableComponent-renounce_ownership]]
==== `[.contract-item-name]#++renounce_ownership++#++(ref self: ContractState)++` [.item-kind]#external#
// tag::renounce_ownership[]
Leaves the contract without owner. It will not be possible to call
`assert_only_owner` functions anymore. Can only be called by the current owner.

NOTE: Renouncing ownership will leave the contract without an owner,
thereby removing any functionality that is only available to the owner.
//end::renounce_ownership[]

[#OwnableComponent-Embeddable-Functions-Two-Step]
==== Embeddable functions (two step transfer)

[.contract-item]
[[OwnableComponent-two-step-owner]]
==== `[.contract-item-name]#++owner++#++(self: @ContractState) → ContractAddress++` [.item-kind]#external#
include::./access.adoc[tag=owner]

[.contract-item]
[[OwnableComponent-two-step-pending_owner]]
==== `[.contract-item-name]#++pending_owner++#++(self: @ContractState) → ContractAddress++` [.item-kind]#external#

Returns the address of the pending owner.

[.contract-item]
[[OwnableComponent-two-step-accept_ownership]]
==== `[.contract-item-name]#++accept_ownership++#++(ref self: ContractState)++` [.item-kind]#external#

Transfers ownership of the contract to the pending owner.
Can only be called by the pending owner.
Resets pending owner to zero address.

Emits an xref:OwnableComponent-OwnershipTransferred[OwnershipTransferred] event.

[.contract-item]
[[OwnableComponent-two-step-transfer_ownership]]
==== `[.contract-item-name]#++transfer_ownership++#++(ref self: ContractState, new_owner: ContractAddress)++` [.item-kind]#external#

Starts the two step ownership transfer process, by setting the pending owner. Setting `new_owner` to the zero address is allowed, this can be used to cancel an initiated ownership transfer.

Can only be called by the current owner.

Emits an xref:OwnableComponent-OwnershipTransferStarted[OwnershipTransferStarted] event.

[.contract-item]
[[OwnableComponent-two-step-renounce_ownership]]
==== `[.contract-item-name]#++renounce_ownership++#++(ref self: ContractState)++` [.item-kind]#external#
include::./access.adoc[tag=renounce_ownership]

[.contract-item]
[[OwnableComponent-transferOwnership]]
==== `[.contract-item-name]#++transferOwnership++#++(ref self: ContractState, newOwner: ContractAddress)++` [.item-kind]#external#

See xref:OwnableComponent-transfer_ownership[transfer_ownership].

[.contract-item]
[[OwnableComponent-renounceOwnership]]
==== `[.contract-item-name]#++renounceOwnership++#++(ref self: ContractState)++` [.item-kind]#external#

See xref:OwnableComponent-renounce_ownership[renounce_ownership].

[.contract-item]
[[OwnableComponent-two-step-pendingOwner]]
==== `[.contract-item-name]#++pendingOwner++#++(self: @ContractState)++` [.item-kind]#external#

See xref:OwnableComponent-two-step-pending_owner[pending_owner].

[.contract-item]
[[OwnableComponent-two-step-acceptOwnership]]
==== `[.contract-item-name]#++acceptOwnership++#++(self: @ContractState)++` [.item-kind]#external#

See xref:OwnableComponent-two-step-accept_ownership[accept_ownership].

[.contract-item]
[[OwnableComponent-two-step-transferOwnership]]
==== `[.contract-item-name]#++transferOwnership++#++(self: @ContractState)++` [.item-kind]#external#

See xref:OwnableComponent-two-step-transfer_ownership[transfer_ownership].

[.contract-item]
[[OwnableComponent-two-step-renounceOwnership]]
==== `[.contract-item-name]#++renounceOwnership++#++(self: @ContractState)++` [.item-kind]#external#

See xref:OwnableComponent-two-step-renounce_ownership[renounce_ownership].

[#OwnableComponent-Internal-Functions]
==== Internal functions

[.contract-item]
[[OwnableComponent-initializer]]
==== `[.contract-item-name]#++initializer++#++(ref self: ContractState, owner: ContractAddress)++` [.item-kind]#internal#

Initializes the contract and sets `owner` as the initial owner.

Requirements:

- `owner` cannot be the zero address.

Emits an xref:OwnableComponent-OwnershipTransferred[OwnershipTransferred] event.

[.contract-item]
[[OwnableComponent-assert_only_owner]]
==== `[.contract-item-name]#++assert_only_owner++#++(self: @ContractState)++` [.item-kind]#internal#

Panics if called by any account other than the owner.

[.contract-item]
[[OwnableComponent-_transfer_ownership]]
==== `[.contract-item-name]#++_transfer_ownership++#++(ref self: ContractState, new_owner: ContractAddress)++` [.item-kind]#internal#

Transfers ownership of the contract to a new account (`new_owner`).
Internal function without access restriction.

Emits an xref:OwnableComponent-OwnershipTransferred[OwnershipTransferred] event.

[.contract-item]
[[OwnableComponent-_propose_owner]]
==== `[.contract-item-name]#++_propose_owner++#++(ref self: ContractState, new_owner: ContractAddress)++` [.item-kind]#internal#

Sets a new pending owner in a two step transfer.

Internal function without access restriction.

Emits an xref:OwnableComponent-OwnershipTransferStarted[OwnershipTransferStarted] event.

[#OwnableComponent-Events]
==== Events

[.contract-item]
[[OwnableComponent-OwnershipTransferStarted]]
==== `[.contract-item-name]#++OwnershipTransferStarted++#++(previous_owner: ContractAddress, new_owner: ContractAddress)++` [.item-kind]#event#

Emitted when the pending owner is updated.

[.contract-item]
[[OwnableComponent-OwnershipTransferred]]
==== `[.contract-item-name]#++OwnershipTransferred++#++(previous_owner: ContractAddress, new_owner: ContractAddress)++` [.item-kind]#event#

Emitted when the ownership is transferred.

[.contract]
[[IAccessControl]]
=== `++IAccessControl++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/access/src/accesscontrol/interface.cairo[{github-icon},role=heading-link]

:grant_role: xref:#IAccessControl-grant_role[grant_role]
:revoke_role: xref:#IAccessControl-revoke_role[revoke_role]
:RoleGranted: xref:#IAccessControl-RoleGranted[RoleGranted]
:RoleRevoked: xref:#IAccessControl-RoleRevoked[RoleRevoked]
:RoleAdminChanged: xref:#IAccessControl-RoleAdminChanged[RoleAdminChanged]

```cairo
use openzeppelin_access::accesscontrol::interface::IAccessControl;
```

External interface of AccessControl.

[.contract-index]
.{inner-src5}
--
0x23700be02858dbe2ac4dc9c9f66d0b6b0ed81ec7f970ca6844500a56ff61751
--

[.contract-index]
.Functions
--
* xref:IAccessControl-has_role[`++has_role(role, account)++`]
* xref:IAccessControl-get_role_admin[`++get_role_admin(role)++`]
* xref:IAccessControl-grant_role[`++grant_role(role, account)++`]
* xref:IAccessControl-revoke_role[`++revoke_role(role, account)++`]
* xref:IAccessControl-renounce_role[`++renounce_role(role, account)++`]
--

[.contract-index]
.Events
--
* xref:IAccessControl-RoleAdminChanged[`++RoleAdminChanged(role, previous_admin_role, new_admin_role)++`]
* xref:IAccessControl-RoleGranted[`++RoleGranted(role, account, sender)++`]
* xref:IAccessControl-RoleRevoked[`++RoleRevoked(role, account, sender)++`]

--

[#IAccessControl-Functions]
==== Functions

[.contract-item]
[[IAccessControl-has_role]]
==== `[.contract-item-name]#++has_role++#++(role: felt252, account: ContractAddress) → bool++` [.item-kind]#external#

Returns `true` if `account` has been granted `role`.

[.contract-item]
[[IAccessControl-get_role_admin]]
==== `[.contract-item-name]#++get_role_admin++#++(role: felt252) → felt252++` [.item-kind]#external#

Returns the admin role that controls `role`. See {grant_role} and
{revoke_role}.

To change a role's admin, use {set_role_admin}.

[.contract-item]
[[IAccessControl-grant_role]]
==== `[.contract-item-name]#++grant_role++#++(role: felt252, account: ContractAddress)++` [.item-kind]#external#

Grants `role` to `account`.

If `account` had not been already granted `role`, emits a {RoleGranted}
event.

Requirements:

- the caller must have ``role``'s admin role.

[.contract-item]
[[IAccessControl-revoke_role]]
==== `[.contract-item-name]#++revoke_role++#++(role: felt252, account: ContractAddress)++` [.item-kind]#external#

Revokes `role` from `account`.

If `account` had been granted `role`, emits a {RoleRevoked} event.

Requirements:

- the caller must have ``role``'s admin role.

[.contract-item]
[[IAccessControl-renounce_role]]
==== `[.contract-item-name]#++renounce_role++#++(role: felt252, account: ContractAddress)++` [.item-kind]#external#

Revokes `role` from the calling account.

Roles are often managed via {grant_role} and {revoke_role}. This function's
purpose is to provide a mechanism for accounts to lose their privileges
if they are compromised (such as when a trusted device is misplaced).

If the calling account had been granted `role`, emits a {RoleRevoked}
event.

Requirements:

- the caller must be `account`.

[#IAccessControl-Events]
==== Events

[.contract-item]
[[IAccessControl-RoleAdminChanged]]
==== `[.contract-item-name]#++RoleAdminChanged++#++(role: felt252, previous_admin_role: ContractAddress, new_admin_role: ContractAddress)++` [.item-kind]#event#

Emitted when `new_admin_role` is set as ``role``'s admin role, replacing `previous_admin_role`

`DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
{RoleAdminChanged} not being emitted signaling this.

[.contract-item]
[[IAccessControl-RoleGranted]]
==== `[.contract-item-name]#++RoleGranted++#++(role: felt252, account: ContractAddress, sender: ContractAddress)++` [.item-kind]#event#

Emitted when `account` is granted `role`.

`sender` is the account that originated the contract call, an admin role
bearer.

[.contract-item]
[[IAccessControl-RoleRevoked]]
==== `[.contract-item-name]#++RoleRevoked++#++(role: felt252, account: ContractAddress, sender: ContractAddress)++` [.item-kind]#event#

Emitted when `account` is revoked `role`.

`sender` is the account that originated the contract call:

- if using `revoke_role`, it is the admin role bearer.
- if using `renounce_role`, it is the role bearer (i.e. `account`).

[.contract]
[[AccessControlComponent]]
=== `++AccessControlComponent++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/access/src/accesscontrol/accesscontrol.cairo[{github-icon},role=heading-link]

:assert_only_role: xref:#AccessControlComponent-assert_only_role
:grant_role: xref:#AccessControlComponent-grant_role[grant_role]
:revoke_role: xref:#AccessControlComponent-revoke_role[revoke_role]

```cairo
use openzeppelin_access::accesscontrol::AccessControlComponent;
```

Component that allows contracts to implement role-based access control mechanisms.
Roles are referred to by their `felt252` identifier:

```cairo
const MY_ROLE: felt252 = selector!("MY_ROLE");
```

Roles can be used to represent a set of permissions. To restrict access to a
function call, use {assert_only_role}[`assert_only_role`]:

```cairo
(...)

#[external(v0)]
fn foo(ref self: ContractState) {
    self.accesscontrol.assert_only_role(MY_ROLE);

    // Do something
}
```

Roles can be granted and revoked dynamically via the {grant_role} and
{revoke_role} functions. Each role has an associated admin role, and only
accounts that have a role's admin role can call {grant_role} and {revoke_role}.

By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
that only accounts with this role will be able to grant or revoke other
roles. More complex role relationships can be created by using
{set_role_admin}.

WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
grant and revoke this role. Extra precautions should be taken to secure
accounts that have been granted it.

[.contract-index#AccessControl-Mixin-Impl]
.{mixin-impls}

--
.AccessControlMixinImpl

* xref:#AccessControlComponent-Embeddable-Impls-AccessControlImpl[`++AccessControlImpl++`]
* xref:#AccessControlComponent-Embeddable-Impls-AccessControlCamelImpl[`++AccessControlCamelImpl++`]
* xref:api/introspection.adoc#SRC5Component-Embeddable-Impls[`++SRC5Impl++`]
--

[.contract-index#AccessControlComponent-Embeddable-Impls]
.Embeddable Implementations
--
[.sub-index#AccessControlComponent-Embeddable-Impls-AccessControlImpl]
.AccessControlImpl

* xref:#AccessControlComponent-has_role[`++has_role(self, role, account)++`]
* xref:#AccessControlComponent-get_role_admin[`++get_role_admin(self, role)++`]
* xref:#AccessControlComponent-grant_role[`++grant_role(self, role, account)++`]
* xref:#AccessControlComponent-revoke_role[`++revoke_role(self, role, account)++`]
* xref:#AccessControlComponent-renounce_role[`++renounce_role(self, role, account)++`]

[.sub-index#AccessControlComponent-Embeddable-Impls-AccessControlCamelImpl]
.AccessControlCamelImpl

* xref:#AccessControlComponent-hasRole[`++hasRole(self, role, account)++`]
* xref:#AccessControlComponent-getRoleAdmin[`++getRoleAdmin(self, role)++`]
* xref:#AccessControlComponent-grantRole[`++grantRole(self, role, account)++`]
* xref:#AccessControlComponent-revokeRole[`++revokeRole(self, role, account)++`]
* xref:#AccessControlComponent-renounceRole[`++renounceRole(self, role, account)++`]

.SRC5Impl
* xref:api/introspection.adoc#ISRC5-supports_interface[`supports_interface(self, interface_id: felt252)`]
--

[.contract-index]
.Internal Implementations
--
.InternalImpl

* xref:#AccessControlComponent-initializer[`++initializer(self)++`]
* xref:#AccessControlComponent-assert_only_role[`++assert_only_role(self, role)++`]
* xref:#AccessControlComponent-set_role_admin[`++set_role_admin(self, role, admin_role)++`]
* xref:#AccessControlComponent-_grant_role[`++_grant_role(self, role, account)++`]
* xref:#AccessControlComponent-_revoke_role[`++_revoke_role(self, role, account)++`]
--

[.contract-index]
.Events
--
.IAccessControl
* xref:#AccessControlComponent-RoleAdminChanged[`++RoleAdminChanged(role, previous_admin_role, new_admin_role)++`]
* xref:#AccessControlComponent-RoleGranted[`++RoleGranted(role, account, sender)++`]
* xref:#AccessControlComponent-RoleRevoked[`++RoleRevoked(role, account, sender)++`]
--

[#AccessControlComponent-Embeddable-Functions]
==== Embeddable functions

[.contract-item]
[[AccessControlComponent-has_role]]
==== `[.contract-item-name]#++has_role++#++(self: @ContractState, role: felt252, account: ContractAddress) → bool++` [.item-kind]#external#

Returns `true` if `account` has been granted `role`.

[.contract-item]
[[AccessControlComponent-get_role_admin]]
==== `[.contract-item-name]#++get_role_admin++#++(self: @ContractState, role: felt252) → felt252++` [.item-kind]#external#

Returns the admin role that controls `role`. See {grant_role} and
{revoke_role}.

To change a role's admin, use {set_role_admin}.

[.contract-item]
[[AccessControlComponent-grant_role]]
==== `[.contract-item-name]#++grant_role++#++(ref self: ContractState, role: felt252, account: ContractAddress)++` [.item-kind]#external#

Grants `role` to `account`.

If `account` had not been already granted `role`, emits a {RoleGranted}
event.

Requirements:

- the caller must have ``role``'s admin role.

May emit a {RoleGranted} event.

[.contract-item]
[[AccessControlComponent-revoke_role]]
==== `[.contract-item-name]#++revoke_role++#++(ref self: ContractState, role: felt252, account: ContractAddress)++` [.item-kind]#external#

Revokes `role` from `account`.

If `account` had been granted `role`, emits a {RoleRevoked} event.

Requirements:

- the caller must have ``role``'s admin role.

May emit a {RoleRevoked} event.

[.contract-item]
[[AccessControlComponent-renounce_role]]
==== `[.contract-item-name]#++renounce_role++#++(ref self: ContractState, role: felt252, account: ContractAddress)++` [.item-kind]#external#

Revokes `role` from the calling account.

Roles are often managed via {grant_role} and {revoke_role}. This function's
purpose is to provide a mechanism for accounts to lose their privileges
if they are compromised (such as when a trusted device is misplaced).

If the calling account had been revoked `role`, emits a {RoleRevoked}
event.

Requirements:

- the caller must be `account`.

May emit a {RoleRevoked} event.

[.contract-item]
[[AccessControlComponent-supports_interface]]
==== `[.contract-item-name]#++supports_interface++#++(self: @ContractState, interface_id: felt252) → bool++` [.item-kind]#external#

See xref:api/introspection.adoc#ISRC5-supports_interface[ISRC5::supports_interface].

[.contract-item]
[[AccessControlComponent-hasRole]]
==== `[.contract-item-name]#++hasRole++#++(self: @ContractState, role: felt252, account: ContractAddress) → bool++` [.item-kind]#external#

See xref:AccessControlComponent-has_role[has_role].

[.contract-item]
[[AccessControlComponent-getRoleAdmin]]
==== `[.contract-item-name]#++getRoleAdmin++#++(self: @ContractState, role: felt252) → felt252++` [.item-kind]#external#

See xref:AccessControlComponent-get_role_admin[get_role_admin].

[.contract-item]
[[AccessControlComponent-grantRole]]
==== `[.contract-item-name]#++grantRole++#++(ref self: ContractState, role: felt252, account: ContractAddress)++` [.item-kind]#external#

See xref:AccessControlComponent-grant_role[grant_role].

[.contract-item]
[[AccessControlComponent-revokeRole]]
==== `[.contract-item-name]#++revokeRole++#++(ref self: ContractState, role: felt252, account: ContractAddress)++` [.item-kind]#external#

See xref:AccessControlComponent-revoke_role[revoke_role].

[.contract-item]
[[AccessControlComponent-renounceRole]]
==== `[.contract-item-name]#++renounceRole++#++(ref self: ContractState, role: felt252, account: ContractAddress)++` [.item-kind]#external#

See xref:AccessControlComponent-renounce_role[renounce_role].

[#AccessControlComponent-Internal-Functions]
==== Internal functions

[.contract-item]
[[AccessControlComponent-initializer]]
==== `[.contract-item-name]#++initializer++#++(ref self: ContractState)++` [.item-kind]#internal#

Initializes the contract by registering the xref:#IAccessControl[IAccessControl] interface ID.

[.contract-item]
[[AccessControlComponent-assert_only_role]]
==== `[.contract-item-name]#++assert_only_role++#++(self: @ContractState, role: felt252)++` [.item-kind]#internal#

Panics if called by any account without the given `role`.

[.contract-item]
[[AccessControlComponent-set_role_admin]]
==== `[.contract-item-name]#++set_role_admin++#++(ref self: ContractState, role: felt252, admin_role: felt252)++` [.item-kind]#internal#

Sets `admin_role` as ``role``'s admin role.

Internal function without access restriction.

Emits a {RoleAdminChanged} event.

[.contract-item]
[[AccessControlComponent-_grant_role]]
==== `[.contract-item-name]#++_grant_role++#++(ref self: ContractState, role: felt252, account: ContractAddress)++` [.item-kind]#internal#

Grants `role` to `account`.

Internal function without access restriction.

May emit a {RoleGranted} event.

[.contract-item]
[[AccessControlComponent-_revoke_role]]
==== `[.contract-item-name]#++_revoke_role++#++(ref self: ContractState, role: felt252, account: ContractAddress)++` [.item-kind]#internal#

Revokes `role` from `account`.

Internal function without access restriction.

May emit a {RoleRevoked} event.

[#AccessControlComponent-Events]
==== Events

[.contract-item]
[[AccessControlComponent-RoleAdminChanged]]
==== `[.contract-item-name]#++RoleAdminChanged++#++(role: felt252, previous_admin_role: ContractAddress, new_admin_role: ContractAddress)++` [.item-kind]#event#

See xref:IAccessControl-RoleAdminChanged[IAccessControl::RoleAdminChanged].

[.contract-item]
[[AccessControlComponent-RoleGranted]]
==== `[.contract-item-name]#++RoleGranted++#++(role: felt252, account: ContractAddress, sender: ContractAddress)++` [.item-kind]#event#

See xref:IAccessControl-RoleGranted[IAccessControl::RoleGranted].

[.contract-item]
[[AccessControlComponent-RoleRevoked]]
==== `[.contract-item-name]#++RoleRevoked++#++(role: felt252, account: ContractAddress, sender: ContractAddress)++` [.item-kind]#event#

See xref:IAccessControl-RoleRevoked[IAccessControl::RoleRevoked].
// llmstxt-short-description: Describes the Accounts modules key features and its usage

:snip-5: https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md
:snip-6: https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-6.md
:counterfactual: xref:/guides/deployment.adoc[counterfactual deployments]

= Accounts

Unlike Ethereum where accounts are derived from a private key, all Starknet accounts are contracts. This means there's no Externally Owned Account (EOA)
concept on Starknet.

Instead, the network features native account abstraction and signature validation happens at the contract level.

For a general overview of account abstraction, see
https://docs.starknet.io/architecture-and-concepts/accounts/introduction/[Starknet's documentation].
A more detailed discussion on the topic can be found in
https://community.starknet.io/t/starknet-account-abstraction-model-part-1/781[Starknet Shaman's forum].

TIP: For detailed information on the usage and implementation check the xref:/api/account.adoc[API Reference] section.

== What is an account?

Accounts in Starknet are smart contracts, and so they can be deployed and interacted
with like any other contract, and can be extended to implement any custom logic. However, an account is a special type
of contract that is used to validate and execute transactions. For this reason, it must implement a set of entrypoints
that the protocol uses for this execution flow. The {snip-6}[SNIP-6] proposal defines a standard interface for accounts,
supporting this execution flow and interoperability with DApps in the ecosystem.

=== ISRC6 Interface

[,cairo]
----
/// Represents a call to a target contract function.
struct Call {
    to: ContractAddress,
    selector: felt252,
    calldata: Span<felt252>
}

/// Standard Account Interface
#[starknet::interface]
pub trait ISRC6 {
    /// Executes a transaction through the account.
    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;

    /// Asserts whether the transaction is valid to be executed.
    fn __validate__(calls: Array<Call>) -> felt252;

    /// Asserts whether a given signature for a given hash is valid.
    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;
}
----

WARNING: The `calldata` member of the `Call` struct in the accounts has been updated to `Span<felt252>` for optimization
purposes, but the interface ID remains the same for backwards compatibility. This inconsistency will be fixed in future releases.

{snip-6}[SNIP-6] adds the `is_valid_signature` method. This method is not used by the protocol, but it's useful for
DApps to verify the validity of signatures, supporting features like Sign In with Starknet.

SNIP-6 also defines that compliant accounts must implement the SRC5 interface following {snip-5}[SNIP-5], as
a mechanism for detecting whether a contract is an account or not through introspection.

=== ISRC5 Interface

[,cairo]
----
/// Standard Interface Detection
#[starknet::interface]
pub trait ISRC5 {
    /// Queries if a contract implements a given interface.
    fn supports_interface(interface_id: felt252) -> bool;
}
----

{snip-6}[SNIP-6] compliant accounts must return `true` when queried for the ISRC6 interface ID.

Even though these interfaces are not enforced by the protocol, it's recommended to implement them for enabling
interoperability with the ecosystem.

=== Protocol-level methods

The Starknet protocol uses a few entrypoints for abstracting the accounts. We already mentioned the first two
as part of the ISRC6 interface, and both are required for enabling accounts to be used for executing transactions. The rest are optional:

1. `\\__validate__` verifies the validity of the transaction to be executed. This is usually used to validate signatures,
but the entrypoint implementation can be customized to feature any validation mechanism https://docs.starknet.io/architecture-and-concepts/accounts/account-functions/#limitations_of_validation[with some limitations].

2. `\\__execute__` executes the transaction if the validation is successful.

3. `\\__validate_declare__` optional entrypoint similar to `\\__validate__` but for transactions
meant to declare other contracts.

4. `\\__validate_deploy__` optional entrypoint similar to `\\__validate__` but meant for {counterfactual}.

NOTE: Although these entrypoints are available to the protocol for its regular transaction flow, they can also be called like any other method.

== Starknet Account

:stark-curve: https://docs.starknet.io/architecture-and-concepts/cryptography/#stark-curve
:account-component: xref:/api/account.adoc#AccountComponent[AccountComponent]
:src5-component: xref:/api/introspection.adoc#SRC5Component[SRC5Component]

Starknet native account abstraction pattern allows for the creation of custom accounts with different validation schemes, but
usually most account implementations validate transactions using the {stark-curve}[Stark curve] which is the most efficient way
of validating signatures since it is a STARK-friendly curve.

OpenZeppelin Contracts for Cairo provides {account-component} for implementing this validation scheme.

=== Usage

Constructing an account contract requires integrating both {account-component} and {src5-component}. The contract should also set up the constructor to initialize the public key that will be used as the account's signer. Here’s an example of a basic contract:

[,cairo]
----
#[starknet::contract(account)]
mod MyAccount {
    use openzeppelin_account::AccountComponent;
    use openzeppelin_introspection::src5::SRC5Component;

    component!(path: AccountComponent, storage: account, event: AccountEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // Account Mixin
    #[abi(embed_v0)]
    impl AccountMixinImpl = AccountComponent::AccountMixinImpl<ContractState>;
    impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        account: AccountComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        AccountEvent: AccountComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState, public_key: felt252) {
        self.account.initializer(public_key);
    }
}
----

=== Interface

This is the full interface of the `AccountMixinImpl` implementation:

[,cairo]
----
#[starknet::interface]
pub trait AccountABI {
    // ISRC6
    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;
    fn __validate__(calls: Array<Call>) -> felt252;
    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;

    // ISRC5
    fn supports_interface(interface_id: felt252) -> bool;

    // IDeclarer
    fn __validate_declare__(class_hash: felt252) -> felt252;

    // IDeployable
    fn __validate_deploy__(
        class_hash: felt252, contract_address_salt: felt252, public_key: felt252
    ) -> felt252;

    // IPublicKey
    fn get_public_key() -> felt252;
    fn set_public_key(new_public_key: felt252, signature: Span<felt252>);

    // ISRC6CamelOnly
    fn isValidSignature(hash: felt252, signature: Array<felt252>) -> felt252;

    // IPublicKeyCamel
    fn getPublicKey() -> felt252;
    fn setPublicKey(newPublicKey: felt252, signature: Span<felt252>);
}
----

== Ethereum Account

:secp256k1-curve: https://en.bitcoin.it/wiki/Secp256k1
:eth-account-component: xref:/api/account.adoc#EthAccountComponent[EthAccountComponent]

Besides the Stark-curve account, OpenZeppelin Contracts for Cairo also offers Ethereum-flavored accounts that use the {secp256k1-curve}[secp256k1] curve for signature validation.
For this the {eth-account-component} must be used.

=== Usage

Constructing a secp256k1 account contract also requires integrating both {eth-account-component} and {src5-component}.
The contract should also set up the constructor to initialize the public key that will be used as the account's signer.
Here’s an example of a basic contract:

[,cairo]
----
#[starknet::contract(account)]
mod MyEthAccount {
    use openzeppelin_account::EthAccountComponent;
    use openzeppelin_account::interface::EthPublicKey;
    use openzeppelin_introspection::src5::SRC5Component;
    use starknet::ClassHash;

    component!(path: EthAccountComponent, storage: eth_account, event: EthAccountEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // EthAccount Mixin
    #[abi(embed_v0)]
    impl EthAccountMixinImpl =
        EthAccountComponent::EthAccountMixinImpl<ContractState>;
    impl EthAccountInternalImpl = EthAccountComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        eth_account: EthAccountComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        EthAccountEvent: EthAccountComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState, public_key: EthPublicKey) {
        self.eth_account.initializer(public_key);
    }
}
----

=== Interface

This is the full interface of the `EthAccountMixinImpl` implementation:

[,cairo]
----
#[starknet::interface]
pub trait EthAccountABI {
    // ISRC6
    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;
    fn __validate__(calls: Array<Call>) -> felt252;
    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;

    // ISRC5
    fn supports_interface(interface_id: felt252) -> bool;

    // IDeclarer
    fn __validate_declare__(class_hash: felt252) -> felt252;

    // IEthDeployable
    fn __validate_deploy__(
        class_hash: felt252, contract_address_salt: felt252, public_key: EthPublicKey
    ) -> felt252;

    // IEthPublicKey
    fn get_public_key() -> EthPublicKey;
    fn set_public_key(new_public_key: EthPublicKey, signature: Span<felt252>);

    // ISRC6CamelOnly
    fn isValidSignature(hash: felt252, signature: Array<felt252>) -> felt252;

    // IEthPublicKeyCamel
    fn getPublicKey() -> EthPublicKey;
    fn setPublicKey(newPublicKey: EthPublicKey, signature: Span<felt252>);
}

----

== Deploying an account

In Starknet there are two ways of deploying smart contracts: using the `deploy_syscall` and doing
counterfactual deployments.
The former can be easily done with the xref:udc.adoc[Universal Deployer Contract (UDC)], a contract that
wraps and exposes the `deploy_syscall` to provide arbitrary deployments through regular contract calls.
But if you don't have an account to invoke it, you will probably want to use the latter.

To do counterfactual deployments, you need to implement another protocol-level entrypoint named
`\\__validate_deploy__`. Check the {counterfactual} guide to learn how.

== Sending transactions

Let's now explore how to send transactions through these accounts.

=== Starknet Account

:custom-account-setup: https://foundry-rs.github.io/starknet-foundry/starknet/account.html#custom-account-contract[custom account setup]
:sncast-version: https://github.com/foundry-rs/starknet-foundry/releases/tag/v0.23.0[v0.23.0]

First, let's take the example account we created before and deploy it:

```[,cairo]
#[starknet::contract(account)]
mod MyAccount {
    use openzeppelin_account::AccountComponent;
    use openzeppelin_introspection::src5::SRC5Component;

    component!(path: AccountComponent, storage: account, event: AccountEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // Account Mixin
    #[abi(embed_v0)]
    impl AccountMixinImpl = AccountComponent::AccountMixinImpl<ContractState>;
    impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        account: AccountComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        AccountEvent: AccountComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState, public_key: felt252) {
        self.account.initializer(public_key);
    }
}
```

To deploy the account variant, compile the contract and declare the class hash because custom accounts are likely not declared.
This means that you'll need an account already deployed.

Next, create the account JSON with Starknet Foundry's {custom-account-setup} and include the `--class-hash` flag with the declared class hash.
The flag enables custom account variants.

NOTE: The following examples use `sncast` {sncast-version}.

```[,bash]
$ sncast \
  --url http://127.0.0.1:5050 \
  account create \
  --name my-custom-account \
  --class-hash 0x123456...
```

This command will output the precomputed contract address and the recommended `max-fee`.
To counterfactually deploy the account, send funds to the address and then deploy the custom account.

```[,bash]
$ sncast \
  --url http://127.0.0.1:5050 \
  account deploy \
  --name my-custom-account
```

Once the account is deployed, set the `--account` flag with the custom account name to send transactions from that account.

```[,bash]
$ sncast \
  --account my-custom-account \
  --url http://127.0.0.1:5050 \
  invoke \
  --contract-address 0x123... \
  --function "some_function" \
  --calldata 1 2 3
```

=== Ethereum Account

:starknetjs: https://www.starknetjs.com/[StarknetJS]
:starknetjs-commit: https://github.com/starknet-io/starknet.js/commit/d002baea0abc1de3ac6e87a671f3dec3757437b3[d002baea0abc1de3ac6e87a671f3dec3757437b3]

First, let's take the example account we created before and deploy it:

```[,cairo]
#[starknet::contract(account)]
mod MyEthAccount {
    use openzeppelin_account::EthAccountComponent;
    use openzeppelin_account::interface::EthPublicKey;
    use openzeppelin_introspection::src5::SRC5Component;

    component!(path: EthAccountComponent, storage: eth_account, event: EthAccountEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // EthAccount Mixin
    #[abi(embed_v0)]
    impl EthAccountMixinImpl =
        EthAccountComponent::EthAccountMixinImpl<ContractState>;
    impl EthAccountInternalImpl = EthAccountComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        eth_account: EthAccountComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        EthAccountEvent: EthAccountComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState, public_key: EthPublicKey) {
        self.eth_account.initializer(public_key);
    }
}
```

Special tooling is required in order to deploy and send transactions with an Ethereum-flavored account contract.
The following examples utilize the {starknetjs} library.

Compile and declare the contract on the target network.
Next, precompute the EthAccount contract address using the declared class hash.

NOTE: The following examples use unreleased features from StarknetJS (`starknetjs@next`) at commit {starknetjs-commit}.

```[,javascript]
import * as dotenv from 'dotenv';
import { CallData, EthSigner, hash } from 'starknet';
import { ABI as ETH_ABI } from '../abis/eth_account.js';
dotenv.config();

// Calculate EthAccount address
const ethSigner = new EthSigner(process.env.ETH_PRIVATE_KEY);
const ethPubKey = await ethSigner.getPubKey();
const ethAccountClassHash = '<ETH_ACCOUNT_CLASS_HASH>';
const ethCallData = new CallData(ETH_ABI);
const ethAccountConstructorCalldata = ethCallData.compile('constructor', {
    public_key: ethPubKey
})
const salt = '0x12345';
const deployerAddress = '0x0';
const ethContractAddress = hash.calculateContractAddressFromHash(
    salt,
    ethAccountClassHash,
    ethAccountConstructorCalldata,
    deployerAddress
);
console.log('Pre-calculated EthAccount address: ', ethContractAddress);
```

Send funds to the pre-calculated EthAccount address and deploy the contract.

```[,javascript]
import * as dotenv from 'dotenv';
import { Account, CallData, EthSigner, RpcProvider, stark } from 'starknet';
import { ABI as ETH_ABI } from '../abis/eth_account.js';
dotenv.config();

// Prepare EthAccount
const provider = new RpcProvider({ nodeUrl: process.env.API_URL });
const ethSigner = new EthSigner(process.env.ETH_PRIVATE_KEY);
const ethPubKey = await ethSigner.getPubKey();
const ethAccountAddress = '<ETH_ACCOUNT_ADDRESS>'
const ethAccount = new Account(provider, ethAccountAddress, ethSigner);

// Prepare payload
const ethAccountClassHash = '<ETH_ACCOUNT_CLASS_HASH>'
const ethCallData = new CallData(ETH_ABI);
const ethAccountConstructorCalldata = ethCallData.compile('constructor', {
    public_key: ethPubKey
})
const salt = '0x12345';
const deployPayload = {
    classHash: ethAccountClassHash,
    constructorCalldata: ethAccountConstructorCalldata,
    addressSalt: salt,
};

// Deploy
const { suggestedMaxFee: feeDeploy } = await ethAccount.estimateAccountDeployFee(deployPayload);
const { transaction_hash, contract_address } = await ethAccount.deployAccount(
    deployPayload,
    { maxFee: stark.estimatedFeeToMaxFee(feeDeploy, 100) }
);
await provider.waitForTransaction(transaction_hash);
console.log('EthAccount deployed at: ', contract_address);
```

Once deployed, connect the EthAccount instance to the target contract which enables calls to come from the EthAccount.
Here's what an ERC20 transfer from an EthAccount looks like.

```[,javascript]
import * as dotenv from 'dotenv';
import { Account, RpcProvider, Contract, EthSigner } from 'starknet';
dotenv.config();

// Prepare EthAccount
const provider = new RpcProvider({ nodeUrl: process.env.API_URL });
const ethSigner = new EthSigner(process.env.ETH_PRIVATE_KEY);
const ethAccountAddress = '<ETH_ACCOUNT_CONTRACT_ADDRESS>'
const ethAccount = new Account(provider, ethAccountAddress, ethSigner);

// Prepare target contract
const erc20 = new Contract(compiledErc20.abi, erc20Address, provider);

// Connect EthAccount with the target contract
erc20.connect(ethAccount);

// Execute ERC20 transfer
const transferCall = erc20.populate('transfer', {
    recipient: recipient.address,
    amount: 50n
});
const tx = await erc20.transfer(
    transferCall.calldata, { maxFee: 900_000_000_000_000 }
);
await provider.waitForTransaction(tx.transaction_hash);
```
// llmstxt-short-description: API of the Account and EthAccount components, which provide components to implement account contracts that can be used for interacting with the network

:github-icon: pass:[<svg class="icon"><use href="#github-icon"/></svg>]
:snip6: https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-6.md[SNIP-6]
:snip9: https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-9.md[SNIP-9]
:snip12: https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md[SNIP-12]
:inner-src5: xref:api/introspection.adoc#ISRC5[SRC5 ID]

= Account

This crate provides components to implement account contracts that can be used for interacting with the network.

== Core

include::../utils/_common.adoc[]

[.contract]
[[ISRC6]]
=== `++ISRC6++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/account/src/interface.cairo[{github-icon},role=heading-link]

```cairo
use openzeppelin_account::interface::ISRC6;
```

Interface of the SRC6 Standard Account as defined in the {snip6}.

[.contract-index]
.{inner-src5}
--
0x2ceccef7f994940b3962a6c67e0ba4fcd37df7d131417c604f91e03caecc1cd
--

[.contract-index]
.Functions
--
* xref:#ISRC6-\\__execute__[`++__execute__(calls)++`]
* xref:#ISRC6-\\__validate__[`++__validate__(calls)++`]
* xref:#ISRC6-is_valid_signature[`++is_valid_signature(hash, signature)++`]
--

[#ISRC6-Functions]
==== Functions

[.contract-item]
[[ISRC6-__execute__]]
==== `[.contract-item-name]#++__execute__++#++(calls: Array<Call>) → Array<Span<felt252>>++` [.item-kind]#external#

Executes the list of calls as a transaction after validation.

Returns an array with each call's output.

NOTE: The `Call` struct is defined in https://github.com/starkware-libs/cairo/blob/main/corelib/src/starknet/account.cairo#L3[corelib].

[.contract-item]
[[ISRC6-__validate__]]
==== `[.contract-item-name]#++__validate__++#++(calls: Array<Call>) → felt252++` [.item-kind]#external#

Validates a transaction before execution.

Returns the short string `'VALID'` if valid, otherwise it reverts.

[.contract-item]
[[ISRC6-is_valid_signature]]
==== `[.contract-item-name]#++is_valid_signature++#++(hash: felt252, signature: Array<felt252>) → felt252++` [.item-kind]#external#

Validates whether a signature is valid or not for the given message hash.

Returns the short string `'VALID'` if valid, otherwise it reverts.

[.contract]
[[AccountComponent]]
=== `++AccountComponent++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/account/src/account.cairo[{github-icon},role=heading-link]

:OwnerAdded: xref:AccountComponent-OwnerAdded[OwnerAdded]
:OwnerRemoved: xref:AccountComponent-OwnerRemoved[OwnerRemoved]
:starknet-curve: https://docs.starknet.io/architecture-and-concepts/cryptography/#stark-curve[Starknet curve]

```cairo
use openzeppelin_account::AccountComponent;
```
Account component implementing xref:ISRC6[`ISRC6`] for signatures over the {starknet-curve}.

NOTE: {src5-component-required-note}

[.contract-index#AccountComponent-Embeddable-Mixin-Impl]
.{mixin-impls}

--
.AccountMixinImpl

* xref:#AccountComponent-Embeddable-Impls-SRC6Impl[`++SRC6Impl++`]
* xref:#AccountComponent-Embeddable-Impls-DeclarerImpl[`++DeclarerImpl++`]
* xref:#AccountComponent-Embeddable-Impls-DeployableImpl[`++DeployableImpl++`]
* xref:#AccountComponent-Embeddable-Impls-PublicKeyImpl[`++PublicKeyImpl++`]
* xref:#AccountComponent-Embeddable-Impls-SRC6CamelOnlyImpl[`++SRC6CamelOnlyImpl++`]
* xref:#AccountComponent-Embeddable-Impls-PublicKeyCamelImpl[`++PublicKeyCamelImpl++`]
* xref:api/introspection.adoc#SRC5Component-Embeddable-Impls[`++SRC5Impl++`]
--

[.contract-index#AccountComponent-Embeddable-Impls]
.Embeddable Implementations
--
[.sub-index#AccountComponent-Embeddable-Impls-SRC6Impl]
.SRC6Impl

* xref:#AccountComponent-\\__execute__[`++__execute__(self, calls)++`]
* xref:#AccountComponent-\\__validate__[`++__validate__(self, calls)++`]
* xref:#AccountComponent-is_valid_signature[`++is_valid_signature(self, hash, signature)++`]

[.sub-index#AccountComponent-Embeddable-Impls-DeclarerImpl]
.DeclarerImpl

* xref:#AccountComponent-\\__validate_declare__[`++__validate_declare__(self, class_hash)++`]

[.sub-index#AccountComponent-Embeddable-Impls-DeployableImpl]
.DeployableImpl

* xref:#AccountComponent-\\__validate_deploy__[`++__validate_deploy__(self, hash, signature)++`]

[.sub-index#AccountComponent-Embeddable-Impls-PublicKeyImpl]
.PublicKeyImpl

* xref:#AccountComponent-get_public_key[`++get_public_key(self)++`]
* xref:#AccountComponent-set_public_key[`++set_public_key(self, new_public_key, signature)++`]

[.sub-index#AccountComponent-Embeddable-Impls-SRC6CamelOnlyImpl]
.SRC6CamelOnlyImpl

* xref:#AccountComponent-isValidSignature[`++isValidSignature(self, hash, signature)++`]

[.sub-index#AccountComponent-Embeddable-Impls-PublicKeyCamelImpl]
.PublicKeyCamelImpl

* xref:#AccountComponent-getPublicKey[`++getPublicKey(self)++`]
* xref:#AccountComponent-setPublicKey[`++setPublicKey(self, newPublicKey, signature)++`]

.SRC5Impl
* xref:api/introspection.adoc#ISRC5-supports_interface[`supports_interface(self, interface_id: felt252)`]
--

[.contract-index]
.Internal Implementations
--
.InternalImpl

* xref:#AccountComponent-initializer[`++initializer(self, public_key)++`]
* xref:#AccountComponent-assert_only_self[`++assert_only_self(self)++`]
* xref:#AccountComponent-assert_valid_new_owner[`++assert_valid_new_owner(self, current_owner, new_owner, signature)++`]
* xref:#AccountComponent-validate_transaction[`++validate_transaction(self)++`]
* xref:#AccountComponent-_set_public_key[`++_set_public_key(self, new_public_key)++`]
* xref:#AccountComponent-_is_valid_signature[`++_is_valid_signature(self, hash, signature)++`]
--

[.contract-index]
.Events
--
* xref:#AccountComponent-OwnerAdded[`++OwnerAdded(new_owner_guid)++`]
* xref:#AccountComponent-OwnerRemoved[`++OwnerRemoved(removed_owner_guid)++`]
--

[#AccountComponent-Embeddable-Functions]
==== Embeddable functions

[.contract-item]
[[AccountComponent-__execute__]]
==== `[.contract-item-name]#++__execute__++#++(self: @ContractState, calls: Array<Call>) → Array<Span<felt252>>++` [.item-kind]#external#

See xref:ISRC6-\\__execute__[ISRC6::\\__execute__].

[.contract-item]
[[AccountComponent-__validate__]]
==== `[.contract-item-name]#++__validate__++#++(self: @ContractState, calls: Array<Call>) → felt252++` [.item-kind]#external#

See xref:ISRC6-\\__validate__[ISRC6::\\__validate__].

[.contract-item]
[[AccountComponent-is_valid_signature]]
==== `[.contract-item-name]#++is_valid_signature++#++(self: @ContractState, hash: felt252, signature: Array<felt252>) → felt252++` [.item-kind]#external#

See xref:ISRC6-is_valid_signature[ISRC6::is_valid_signature].

[.contract-item]
[[AccountComponent-__validate_declare__]]
==== `[.contract-item-name]#++__validate_declare__++#++(self: @ContractState, class_hash: felt252) → felt252++` [.item-kind]#external#

Validates a https://docs.starknet.io/architecture-and-concepts/network-architecture/transactions/#declare-transaction[`Declare` transaction].

Returns the short string `'VALID'` if valid, otherwise it reverts.

[.contract-item]
[[AccountComponent-__validate_deploy__]]
==== `[.contract-item-name]#++__validate_deploy__++#++(self: @ContractState, class_hash: felt252, contract_address_salt: felt252, public_key: felt252) → felt252++` [.item-kind]#external#

Validates a https://docs.starknet.io/architecture-and-concepts/network-architecture/transactions/#deploy_account_transaction[`DeployAccount` transaction].
See xref:/guides/deployment.adoc[Counterfactual Deployments].

Returns the short string `'VALID'` if valid, otherwise it reverts.

[.contract-item]
[[AccountComponent-get_public_key]]
==== `[.contract-item-name]#++get_public_key++#++(self: @ContractState)++ → felt252` [.item-kind]#external#

Returns the current public key of the account.

[.contract-item]
[[AccountComponent-set_public_key]]
==== `[.contract-item-name]#++set_public_key++#++(ref self: ContractState, new_public_key: felt252, signature: Span<felt252>)++` [.item-kind]#external#

Sets a new public key for the account. Only accessible by the account calling itself through `\\__execute__`.

Requirements:

- The caller must be the contract itself.
- The signature must be valid for the new owner.

Emits both an {OwnerRemoved} and an {OwnerAdded} event.

[NOTE]
====
The message to be signed is computed in Cairo as follows:

```javascript
let message_hash = PoseidonTrait::new()
        .update_with('StarkNet Message')
        .update_with('accept_ownership')
        .update_with(get_contract_address())
        .update_with(current_owner)
        .finalize();
```
====

[.contract-item]
[[AccountComponent-isValidSignature]]
==== `[.contract-item-name]#++isValidSignature++#++(self: @ContractState, hash: felt252, signature: Array<felt252>) → felt252++` [.item-kind]#external#

See xref:ISRC6-is_valid_signature[ISRC6::is_valid_signature].

[.contract-item]
[[AccountComponent-getPublicKey]]
==== `[.contract-item-name]#++getPublicKey++#++(self: @ContractState)++ → felt252` [.item-kind]#external#

See xref:AccountComponent-get_public_key[get_public_key].

[.contract-item]
[[AccountComponent-setPublicKey]]
==== `[.contract-item-name]#++setPublicKey++#++(ref self: ContractState, newPublicKey: felt252, signature: Span<felt252>)++` [.item-kind]#external#

See xref:AccountComponent-set_public_key[set_public_key].

[#AccountComponent-Internal-Functions]
==== Internal functions

[.contract-item]
[[AccountComponent-initializer]]
==== `[.contract-item-name]#++initializer++#++(ref self: ComponentState, public_key: felt252)++` [.item-kind]#internal#

Initializes the account with the given public key, and registers the `ISRC6` interface ID.

Emits an {OwnerAdded} event.

[.contract-item]
[[AccountComponent-assert_only_self]]
==== `[.contract-item-name]#++assert_only_self++#++(self: @ComponentState)++` [.item-kind]#internal#

Validates that the caller is the account itself. Otherwise it reverts.

[.contract-item]
[[AccountComponent-assert_valid_new_owner]]
==== `[.contract-item-name]#++assert_valid_new_owner++#++(self: @ComponentState, current_owner: felt252, new_owner: felt252, signature: Span<felt252>)++` [.item-kind]#internal#

Validates that `new_owner` accepted the ownership of the contract through a signature.

Requirements:

- `signature` must be valid for the new owner.

WARNING: This function assumes that `current_owner` is the current owner of the contract, and
does not validate this assumption.

[.contract-item]
[[AccountComponent-validate_transaction]]
==== `[.contract-item-name]#++validate_transaction++#++(self: @ComponentState)++ → felt252` [.item-kind]#internal#

Validates a transaction signature from the
https://github.com/starkware-libs/cairo/blob/main/corelib/src/starknet/info.cairo#L61[global context].

Returns the short string `'VALID'` if valid, otherwise it reverts.

[.contract-item]
[[AccountComponent-_set_public_key]]
==== `[.contract-item-name]#++_set_public_key++#++(ref self: ComponentState, new_public_key: felt252)++` [.item-kind]#internal#

Set the public key without validating the caller.

Emits an {OwnerAdded} event.

CAUTION: The usage of this method outside the `set_public_key` function is discouraged.

[.contract-item]
[[AccountComponent-_is_valid_signature]]
==== `[.contract-item-name]#++_is_valid_signature++#++(self: @ComponentState, hash: felt252, signature: Span<felt252>)++ → bool` [.item-kind]#internal#

Validates the provided `signature` for the `hash`, using the account's current public key.

[#AccountComponent-Events]
==== Events

[.contract-item]
[[AccountComponent-OwnerAdded]]
==== `[.contract-item-name]#++OwnerAdded++#++(new_owner_guid: felt252)++` [.item-kind]#event#

Emitted when a `public_key` is added.

[.contract-item]
[[AccountComponent-OwnerRemoved]]
==== `[.contract-item-name]#++OwnerRemoved++#++(removed_owner_guid: felt252)++` [.item-kind]#event#

Emitted when a `public_key` is removed.

[.contract]
[[EthAccountComponent]]
=== `++EthAccountComponent++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/account/src/eth_account.cairo[{github-icon},role=heading-link]

:OwnerAdded: xref:EthAccountComponent-OwnerAdded[OwnerAdded]
:OwnerRemoved: xref:EthAccountComponent-OwnerRemoved[OwnerRemoved]
:secp256k1-curve: https://en.bitcoin.it/wiki/Secp256k1[Secp256k1 curve]

```cairo
use openzeppelin_account::eth_account::EthAccountComponent;
```
Account component implementing xref:ISRC6[`ISRC6`] for signatures over the {secp256k1-curve}.

NOTE: {src5-component-required-note}

NOTE: The `EthPublicKey` type is an alias for `starknet::secp256k1::Secp256k1Point`.

[.contract-index#EthAccountComponent-Embeddable-Mixin-Impl]
.{mixin-impls}

--
.EthAccountMixinImpl

* xref:#EthAccountComponent-Embeddable-Impls-SRC6Impl[`++SRC6Impl++`]
* xref:#EthAccountComponent-Embeddable-Impls-DeclarerImpl[`++DeclarerImpl++`]
* xref:#EthAccountComponent-Embeddable-Impls-DeployableImpl[`++DeployableImpl++`]
* xref:#EthAccountComponent-Embeddable-Impls-PublicKeyImpl[`++PublicKeyImpl++`]
* xref:#EthAccountComponent-Embeddable-Impls-SRC6CamelOnlyImpl[`++SRC6CamelOnlyImpl++`]
* xref:#EthAccountComponent-Embeddable-Impls-PublicKeyCamelImpl[`++PublicKeyCamelImpl++`]
* xref:api/introspection.adoc#SRC5Component-Embeddable-Impls[`++SRC5Impl++`]
--

[.contract-index#EthAccountComponent-Embeddable-Impls]
.Embeddable Implementations
--
[.sub-index#EthAccountComponent-Embeddable-Impls-SRC6Impl]
.SRC6Impl

* xref:#EthAccountComponent-\\__execute__[`++__execute__(self, calls)++`]
* xref:#EthAccountComponent-\\__validate__[`++__validate__(self, calls)++`]
* xref:#EthAccountComponent-is_valid_signature[`++is_valid_signature(self, hash, signature)++`]

[.sub-index#EthAccountComponent-Embeddable-Impls-DeclarerImpl]
.DeclarerImpl

* xref:#EthAccountComponent-\\__validate_declare__[`++__validate_declare__(self, class_hash)++`]

[.sub-index#EthAccountComponent-Embeddable-Impls-DeployableImpl]
.DeployableImpl

* xref:#EthAccountComponent-\\__validate_deploy__[`++__validate_deploy__(self, hash, signature)++`]

[.sub-index#EthAccountComponent-Embeddable-Impls-PublicKeyImpl]
.PublicKeyImpl

* xref:#EthAccountComponent-get_public_key[`++get_public_key(self)++`]
* xref:#EthAccountComponent-set_public_key[`++set_public_key(self, new_public_key, signature)++`]

[.sub-index#EthAccountComponent-Embeddable-Impls-SRC6CamelOnlyImpl]
.SRC6CamelOnlyImpl

* xref:#EthAccountComponent-isValidSignature[`++isValidSignature(self, hash, signature)++`]

[.sub-index#EthAccountComponent-Embeddable-Impls-PublicKeyCamelImpl]
.PublicKeyCamelImpl

* xref:#EthAccountComponent-getPublicKey[`++getPublicKey(self)++`]
* xref:#EthAccountComponent-setPublicKey[`++setPublicKey(self, newPublicKey, signature)++`]

.SRC5Impl
* xref:api/introspection.adoc#ISRC5-supports_interface[`supports_interface(self, interface_id: felt252)`]
--

[.contract-index]
.Internal Implementations
--
.InternalImpl

* xref:#EthAccountComponent-initializer[`++initializer(self, public_key)++`]
* xref:#EthAccountComponent-assert_only_self[`++assert_only_self(self)++`]
* xref:#EthAccountComponent-assert_valid_new_owner[`++assert_valid_new_owner(self, current_owner, new_owner, signature)++`]
* xref:#EthAccountComponent-validate_transaction[`++validate_transaction(self)++`]
* xref:#EthAccountComponent-_set_public_key[`++_set_public_key(self, new_public_key)++`]
* xref:#EthAccountComponent-_is_valid_signature[`++_is_valid_signature(self, hash, signature)++`]
--

[.contract-index]
.Events
--
* xref:#EthAccountComponent-OwnerAdded[`++OwnerAdded(new_owner_guid)++`]
* xref:#EthAccountComponent-OwnerRemoved[`++OwnerRemoved(removed_owner_guid)++`]
--

[#EthAccountComponent-Embeddable-Functions]
==== Embeddable functions

[.contract-item]
[[EthAccountComponent-__execute__]]
==== `[.contract-item-name]#++__execute__++#++(self: @ContractState, calls: Array<Call>) → Array<Span<felt252>>++` [.item-kind]#external#

See xref:ISRC6-\\__execute__[ISRC6::\\__execute__].

[.contract-item]
[[EthAccountComponent-__validate__]]
==== `[.contract-item-name]#++__validate__++#++(self: @ContractState, calls: Array<Call>) → felt252++` [.item-kind]#external#

See xref:ISRC6-\\__validate__[ISRC6::\\__validate__].

[.contract-item]
[[EthAccountComponent-is_valid_signature]]
==== `[.contract-item-name]#++is_valid_signature++#++(self: @ContractState, hash: felt252, signature: Array<felt252>) → felt252++` [.item-kind]#external#

See xref:ISRC6-is_valid_signature[ISRC6::is_valid_signature].

[.contract-item]
[[EthAccountComponent-__validate_declare__]]
==== `[.contract-item-name]#++__validate_declare__++#++(self: @ContractState, class_hash: felt252) → felt252++` [.item-kind]#external#

Validates a https://docs.starknet.io/architecture-and-concepts/network-architecture/transactions/#declare-transaction[`Declare` transaction].

Returns the short string `'VALID'` if valid, otherwise it reverts.

[.contract-item]
[[EthAccountComponent-__validate_deploy__]]
==== `[.contract-item-name]#++__validate_deploy__++#++(self: @ContractState, class_hash: felt252, contract_address_salt: felt252, public_key: EthPublicKey) → felt252++` [.item-kind]#external#

Validates a https://docs.starknet.io/architecture-and-concepts/network-architecture/transactions/#deploy_account_transaction[`DeployAccount` transaction].
See xref:/guides/deployment.adoc[Counterfactual Deployments].

Returns the short string `'VALID'` if valid, otherwise it reverts.

[.contract-item]
[[EthAccountComponent-get_public_key]]
==== `[.contract-item-name]#++get_public_key++#++(self: @ContractState)++ → EthPublicKey` [.item-kind]#external#

Returns the current public key of the account.

[.contract-item]
[[EthAccountComponent-set_public_key]]
==== `[.contract-item-name]#++set_public_key++#++(ref self: ContractState, new_public_key: EthPublicKey, signature: Span<felt252>)++` [.item-kind]#external#

Sets a new public key for the account. Only accessible by the account calling itself through `\\__execute__`.

Requirements:

- The caller must be the contract itself.
- The signature must be valid for the new owner.

Emits both an {OwnerRemoved} and an {OwnerAdded} event.

[NOTE]
====
The message to be signed is computed in Cairo as follows:
```javascript
let message_hash = PoseidonTrait::new()
        .update_with('StarkNet Message')
        .update_with('accept_ownership')
        .update_with(get_contract_address())
        .update_with(current_owner.get_coordinates().unwrap_syscall())
        .finalize();
```
====

[.contract-item]
[[EthAccountComponent-isValidSignature]]
==== `[.contract-item-name]#++isValidSignature++#++(self: @ContractState, hash: felt252, signature: Array<felt252>) → felt252++` [.item-kind]#external#

See xref:ISRC6-is_valid_signature[ISRC6::is_valid_signature].

[.contract-item]
[[EthAccountComponent-getPublicKey]]
==== `[.contract-item-name]#++getPublicKey++#++(self: @ContractState)++ → EthPublicKey` [.item-kind]#external#

See xref:EthAccountComponent-get_public_key[get_public_key].

[.contract-item]
[[EthAccountComponent-setPublicKey]]
==== `[.contract-item-name]#++setPublicKey++#++(ref self: ContractState, newPublicKey: EthPublicKey, signature: Span<felt252>)++` [.item-kind]#external#

See xref:EthAccountComponent-set_public_key[set_public_key].

[#EthAccountComponent-Internal-Functions]
==== Internal functions

[.contract-item]
[[EthAccountComponent-initializer]]
==== `[.contract-item-name]#++initializer++#++(ref self: ComponentState, public_key: EthPublicKey)++` [.item-kind]#internal#

Initializes the account with the given public key, and registers the `ISRC6` interface ID.

Emits an {OwnerAdded} event.

[.contract-item]
[[EthAccountComponent-assert_only_self]]
==== `[.contract-item-name]#++assert_only_self++#++(self: @ComponentState)++` [.item-kind]#internal#

Validates that the caller is the account itself. Otherwise it reverts.

[.contract-item]
[[EthAccountComponent-assert_valid_new_owner]]
==== `[.contract-item-name]#++assert_valid_new_owner++#++(self: @ComponentState, current_owner: EthPublicKey, new_owner: EthPublicKey, signature: Span<felt252>)++` [.item-kind]#internal#

Validates that `new_owner` accepted the ownership of the contract through a signature.

Requirements:

- The signature must be valid for the `new_owner`.

WARNING: This function assumes that `current_owner` is the current owner of the contract, and
does not validate this assumption.

[.contract-item]
[[EthAccountComponent-validate_transaction]]
==== `[.contract-item-name]#++validate_transaction++#++(self: @ComponentState)++ → felt252` [.item-kind]#internal#

Validates a transaction signature from the
https://github.com/starkware-libs/cairo/blob/main/corelib/src/starknet/info.cairo#L61[global context].

Returns the short string `'VALID'` if valid, otherwise it reverts.

[.contract-item]
[[EthAccountComponent-_set_public_key]]
==== `[.contract-item-name]#++_set_public_key++#++(ref self: ComponentState, new_public_key: EthPublicKey)++` [.item-kind]#internal#

Set the public key without validating the caller.

Emits an {OwnerAdded} event.

CAUTION: The usage of this method outside the `set_public_key` function is discouraged.

[.contract-item]
[[EthAccountComponent-_is_valid_signature]]
==== `[.contract-item-name]#++_is_valid_signature++#++(self: @ComponentState, hash: felt252, signature: Span<felt252>)++ → bool` [.item-kind]#internal#

Validates the provided `signature` for the `hash`, using the account's current public key.

[#EthAccountComponent-Events]
==== Events

NOTE: The `guid` is computed as the hash of the public key, using the poseidon hash function.

[.contract-item]
[[EthAccountComponent-OwnerAdded]]
==== `[.contract-item-name]#++OwnerAdded++#++(new_owner_guid: felt252)++` [.item-kind]#event#

Emitted when a `public_key` is added.

[.contract-item]
[[EthAccountComponent-OwnerRemoved]]
==== `[.contract-item-name]#++OwnerRemoved++#++(removed_owner_guid: felt252)++` [.item-kind]#event#

Emitted when a `public_key` is removed.

== Extensions

[.contract]
[[ISRC9_V2]]
=== `++ISRC9_V2++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/account/src/extensions/src9/interface.cairo[{github-icon},role=heading-link]

```cairo
use openzeppelin_account::extensions::src9::ISRC9_V2;
```

Interface of the SRC9 Standard as defined in the {snip9}.

[.contract-index]
.{inner-src5}
--
0x1d1144bb2138366ff28d8e9ab57456b1d332ac42196230c3a602003c89872
--

[.contract-index]
.Functions
--
* xref:#ISRC9_V2-execute_from_outside_v2[`++execute_from_outside_v2(outside_execution, signature)++`]
* xref:#ISRC9_V2-is_valid_outside_execution_nonce[`++is_valid_outside_execution_nonce(nonce)++`]
--

[#ISRC9_V2-Functions]
==== Functions

[.contract-item]
[[ISRC9_V2-execute_from_outside_v2]]
==== `[.contract-item-name]#++execute_from_outside_v2++#++(outside_execution: OutsideExecution, signature: Span<felt252>,) → Array<Span<felt252>>++` [.item-kind]#external#

Allows anyone to submit a transaction on behalf of the account as long as they have the relevant signatures.

This method allows reentrancy. A call to `\\__execute__` or `execute_from_outside_v2` can trigger
another nested transaction to `execute_from_outside_v2` thus the implementation MUST verify
that the provided `signature` matches the hash of `outside_execution` and that `nonce` was
not already used.

The implementation should expect version to be set to 2 in the domain separator.

Arguments:

- `outside_execution` - The parameters of the transaction to execute.
- `signature` - A valid signature on the {snip12} message encoding of `outside_execution`.

[.contract-item]
[[ISRC9_V2-is_valid_outside_execution_nonce]]
==== `[.contract-item-name]#++is_valid_outside_execution_nonce++#++(nonce: felt252) → bool++` [.item-kind]#external#

Get the status of a given nonce. `true` if the nonce is available to use.

[.contract]
[[SRC9Component]]
=== `++SRC9Component++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/account/src/extensions/src9/src9.cairo[{github-icon},role=heading-link]

```cairo
use openzeppelin_account::extensions::SRC9Component;
```

OutsideExecution component implementing xref:ISRC9_V2[`ISRC9_V2`].

NOTE: This component is signature-agnostic, meaning it can be integrated into any account contract, as long as the
account implements the ISRC6 interface.

[.contract-index#SRC9Component-Embeddable-Impls]
.Embeddable Implementations
--
[.sub-index#SRC9Component-Embeddable-Impls-OutsideExecutionV2Impl]
.OutsideExecutionV2Impl

* xref:#SRC9Component-execute_from_outside_v2[`++execute_from_outside_v2(self, outside_execution, signature)++`]
* xref:#SRC9Component-is_valid_outside_execution_nonce[`++is_valid_outside_execution_nonce(self, nonce)++`]
--

[.contract-index]
.Internal Implementations
--
.InternalImpl

* xref:#SRC9Component-initializer[`++initializer(self)++`]
--

[#SRC9Component-Embeddable-Functions]
==== Embeddable functions

[.contract-item]
[[SRC9Component-execute_from_outside_v2]]
==== `[.contract-item-name]#++execute_from_outside_v2++#++(ref self: ContractState, outside_execution: OutsideExecution, signature: Span<felt252>) → Array<Span<felt252>>++` [.item-kind]#external#

Allows anyone to submit a transaction on behalf of the account as long as they
have the relevant signatures.

This method allows reentrancy. A call to `\\__execute__` or `execute_from_outside_v2` can
trigger another nested transaction to `execute_from_outside_v2`. This implementation
verifies that the provided `signature` matches the hash of `outside_execution` and that
`nonce` was not already used.

Arguments:

- `outside_execution` - The parameters of the transaction to execute.
- `signature` - A valid signature on the {snip12} message encoding of
`outside_execution`.

Requirements:

- The caller must be the `outside_execution.caller` unless 'ANY_CALLER' is used.
- The current time must be within the `outside_execution.execute_after` and `outside_execution.execute_before` span.
- The `outside_execution.nonce` must not be used before.
- The `signature` must be valid.

[.contract-item]
[[SRC9Component-is_valid_outside_execution_nonce]]
==== `[.contract-item-name]#++is_valid_outside_execution_nonce++#++(self: @ContractState, nonce: felt252) → bool++` [.item-kind]#external#

Returns the status of a given nonce. `true` if the nonce is available to use.

[#SRC9Component-Internal-Functions]
==== Internal functions

[.contract-item]
[[SRC9Component-initializer]]
==== `[.contract-item-name]#++initializer++#++(ref self: ComponentState)++` [.item-kind]#internal#

Initializes the account by registering the `ISRC9_V2` interface ID.

== Presets

[.contract]
[[AccountUpgradeable]]
=== `++AccountUpgradeable++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/presets/src/account.cairo[{github-icon},role=heading-link]

```cairo
use openzeppelin_presets::AccountUpgradeable;
```

Upgradeable account which can change its public key and declare, deploy, or call
contracts. Supports outside execution by implementing xref:#SRC9Component[SRC9].

include::../utils/_class_hashes.adoc[]

[.contract-index]
.{presets-page}
--
{AccountUpgradeable-class-hash}
--

[.contract-index]
.Constructor
--
* xref:#AccountUpgradeable-constructor[`++constructor(self, public_key)++`]
--

[.contract-index]
.Embedded Implementations
--
.AccountComponent
* xref:#AccountComponent-Embeddable-Mixin-Impl[`++AccountMixinImpl++`]

.SRC9Component
* xref:#SRC9Component-Embeddable-Impls-OutsideExecutionV2Impl[`++OutsideExecutionV2Impl++`]
--

[.contract-index]
.External Functions
--
* xref:#AccountUpgradeable-upgrade[`++upgrade(self, new_class_hash)++`]
--

[#AccountUpgradeable-constructor-section]
==== Constructor

[.contract-item]
[[AccountUpgradeable-constructor]]
==== `[.contract-item-name]#++constructor++#++(ref self: ContractState, public_key: felt252)++` [.item-kind]#constructor#

Sets the account `public_key` and registers the interfaces the contract supports.

[#AccountUpgradeable-external-functions]
==== External functions

[.contract-item]
[[AccountUpgradeable-upgrade]]
==== `[.contract-item-name]#++upgrade++#++(ref self: ContractState, new_class_hash: ClassHash)++` [.item-kind]#external#

Upgrades the contract to a new implementation given by `new_class_hash`.

Requirements:

- The caller is the account contract itself.
- `new_class_hash` cannot be zero.

[.contract]
[[EthAccountUpgradeable]]
=== `++EthAccountUpgradeable++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/presets/src/eth_account.cairo[{github-icon},role=heading-link]

```cairo
use openzeppelin_presets::EthAccountUpgradeable;
```

Upgradeable account which can change its public key and declare, deploy, or call contracts, using Ethereum
signing keys. Supports outside execution by implementing xref:#SRC9Component[SRC9].

NOTE: The `EthPublicKey` type is an alias for `starknet::secp256k1::Secp256k1Point`.

include::../utils/_class_hashes.adoc[]

[.contract-index]
.{presets-page}
--
{EthAccountUpgradeable-class-hash}
--

[.contract-index]
.Constructor
--
* xref:#EthAccountUpgradeable-constructor[`++constructor(self, public_key)++`]
--

[.contract-index]
.Embedded Implementations
--
.EthAccountComponent
* xref:#EthAccountComponent-Embeddable-Mixin-Impl[`++EthAccountMixinImpl++`]

.SRC9Component
* xref:#SRC9Component-Embeddable-Impls-OutsideExecutionV2Impl[`++OutsideExecutionV2Impl++`]
--

[.contract-index]
.External Functions
--
* xref:#EthAccountUpgradeable-upgrade[`++upgrade(self, new_class_hash)++`]
--

[#EthAccountUpgradeable-constructor-section]
==== Constructor

[.contract-item]
[[EthAccountUpgradeable-constructor]]
==== `[.contract-item-name]#++constructor++#++(ref self: ContractState, public_key: EthPublicKey)++` [.item-kind]#constructor#

Sets the account `public_key` and registers the interfaces the contract supports.

[#EthAccountUpgradeable-external-functions]
==== External functions

[.contract-item]
[[EthAccountUpgradeable-upgrade]]
==== `[.contract-item-name]#++upgrade++#++(ref self: ContractState, new_class_hash: ClassHash)++` [.item-kind]#external#

Upgrades the contract to a new implementation given by `new_class_hash`.

Requirements:

- The caller is the account contract itself.
- `new_class_hash` cannot be zero.
// llmstxt-short-description: Describes the Finance module key components and its usage

= Finance

:vesting-component: xref:api/finance.adoc#VestingComponent[VestingComponent]
:vesting-schedule: xref:api/finance.adoc#VestingComponent-Vesting-Schedule[VestingSchedule]
:ownable-component: xref:api/access.adoc#OwnableComponent[OwnableComponent]
:linear-vesting-schedule: xref:api/finance.adoc#LinearVestingSchedule[LinearVestingSchedule]
:calculate_vested_amount: xref:api/finance.adoc#VestingComponent-calculate_vested_amount[calculate_vested_amount]

This module includes primitives for financial systems.

[[vesting_component]]
== Vesting component

The {vesting-component} manages the gradual release of ERC-20 tokens to a designated beneficiary based on a predefined vesting schedule. 
The implementing contract must implement the {ownable-component}, where the contract owner is regarded as the vesting beneficiary. 
This structure allows ownership rights of both the contract and the vested tokens to be assigned and transferred.

NOTE: Any assets transferred to this contract will follow the vesting schedule as if they were locked from the beginning of the vesting period. 
As a result, if the vesting has already started, a portion of the newly transferred tokens may become immediately releasable.

NOTE: By setting the duration to 0, it's possible to configure this contract to behave like an asset timelock that holds tokens 
for a beneficiary until a specified date.

[[vesting_schedule]]
=== Vesting schedule

The {vesting-schedule} trait defines the logic for calculating the vested amount based on a given timestamp. This 
logic is not part of the {vesting-component}, so any contract implementing the {vesting-component} must provide its own 
implementation of the {vesting-schedule} trait.

NOTE: There's a ready-made implementation of the {vesting-schedule} trait available named {linear-vesting-schedule}. 
It incorporates a cliff period by returning 0 vested amount until the cliff ends. After the cliff, the vested amount 
is calculated as directly proportional to the time elapsed since the beginning of the vesting schedule.

=== Usage

The contract must integrate {vesting-component} and {ownable-component} as dependencies. The contract's constructor 
should initialize both components. Core vesting parameters, such as `beneficiary`, `start`, `duration` 
and `cliff_duration`, are passed as arguments to the constructor and set at the time of deployment.

The implementing contract must provide an implementation of the {vesting-schedule} trait. This can be achieved either by importing 
a ready-made {linear-vesting-schedule} implementation or by defining a custom one.

Here’s an example of a simple vesting wallet contract with a {linear-vesting-schedule}, where the vested amount 
is calculated as being directly proportional to the time elapsed since the start of the vesting period.

[,cairo]
----
#[starknet::contract]
mod LinearVestingWallet {
    use openzeppelin_access::ownable::OwnableComponent;
    use openzeppelin_finance::vesting::{VestingComponent, LinearVestingSchedule};
    use starknet::ContractAddress;

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);
    component!(path: VestingComponent, storage: vesting, event: VestingEvent);

    #[abi(embed_v0)]
    impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;
    impl OwnableInternalImpl = OwnableComponent::InternalImpl<ContractState>;

    #[abi(embed_v0)]
    impl VestingImpl = VestingComponent::VestingImpl<ContractState>;
    impl VestingInternalImpl = VestingComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        ownable: OwnableComponent::Storage,
        #[substorage(v0)]
        vesting: VestingComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        OwnableEvent: OwnableComponent::Event,
        #[flat]
        VestingEvent: VestingComponent::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        beneficiary: ContractAddress,
        start: u64,
        duration: u64,
        cliff_duration: u64
    ) {
        self.ownable.initializer(beneficiary);
        self.vesting.initializer(start, duration, cliff_duration);
    }
}
----

A vesting schedule will often follow a custom formula. In such cases, the {vesting-schedule} trait is useful. 
To support a custom vesting schedule, the contract must provide an implementation of the 
{calculate_vested_amount} function based on the desired formula.

NOTE: When using a custom {vesting-schedule} implementation, the {linear-vesting-schedule} must be excluded from the imports.

NOTE: If there are additional parameters required for calculations, which are stored in the contract's storage, you can access them using `self.get_contract()`.

Here’s an example of a vesting wallet contract with a custom {vesting-schedule} implementation, where tokens 
are vested in a number of steps.

[,cairo]
----
#[starknet::contract]
mod StepsVestingWallet {
    use openzeppelin_access::ownable::OwnableComponent;
    use openzeppelin_finance::vesting::VestingComponent::VestingScheduleTrait;
    use openzeppelin_finance::vesting::VestingComponent;
    use starknet::ContractAddress;
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);
    component!(path: VestingComponent, storage: vesting, event: VestingEvent);

    #[abi(embed_v0)]
    impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;
    impl OwnableInternalImpl = OwnableComponent::InternalImpl<ContractState>;

    #[abi(embed_v0)]
    impl VestingImpl = VestingComponent::VestingImpl<ContractState>;
    impl VestingInternalImpl = VestingComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        total_steps: u64,
        #[substorage(v0)]
        ownable: OwnableComponent::Storage,
        #[substorage(v0)]
        vesting: VestingComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        OwnableEvent: OwnableComponent::Event,
        #[flat]
        VestingEvent: VestingComponent::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        total_steps: u64,
        beneficiary: ContractAddress,
        start: u64,
        duration: u64,
        cliff: u64,
    ) {
        self.total_steps.write(total_steps);
        self.ownable.initializer(beneficiary);
        self.vesting.initializer(start, duration, cliff);
    }

    impl VestingSchedule of VestingScheduleTrait<ContractState> {
        fn calculate_vested_amount(
            self: @VestingComponent::ComponentState<ContractState>,
            token: ContractAddress,
            total_allocation: u256,
            timestamp: u64,
            start: u64,
            duration: u64,
            cliff: u64,
        ) -> u256 {
            if timestamp < cliff {
                0
            } else if timestamp >= start + duration {
                total_allocation
            } else {
                let total_steps = self.get_contract().total_steps.read();
                let vested_per_step = total_allocation / total_steps.into();
                let step_duration = duration / total_steps;
                let current_step = (timestamp - start) / step_duration;
                let vested_amount = vested_per_step * current_step.into();
                vested_amount
            }
        }
    }
}
----

=== Interface

Here is the full interface of a standard contract implementing the vesting functionality:

[,cairo]
----
#[starknet::interface]
pub trait VestingABI<TState> {
    // IVesting
    fn start(self: @TState) -> u64;
    fn cliff(self: @TState) -> u64;
    fn duration(self: @TState) -> u64;
    fn end(self: @TState) -> u64;
    fn released(self: @TState, token: ContractAddress) -> u256;
    fn releasable(self: @TState, token: ContractAddress) -> u256;
    fn vested_amount(self: @TState, token: ContractAddress, timestamp: u64) -> u256;
    fn release(ref self: TState, token: ContractAddress) -> u256;

    // IOwnable
    fn owner(self: @TState) -> ContractAddress;
    fn transfer_ownership(ref self: TState, new_owner: ContractAddress);
    fn renounce_ownership(ref self: TState);

    // IOwnableCamelOnly
    fn transferOwnership(ref self: TState, newOwner: ContractAddress);
    fn renounceOwnership(ref self: TState);
}
----

// llmstxt-short-description: API of the Finance module, including the Vesting component and linear vesting schedule implementation

:github-icon: pass:[<svg class="icon"><use href="#github-icon"/></svg>]
:vesting-component: xref:VestingComponent[VestingComponent]
:ownable-component: xref:api/access.adoc#OwnableComponent[OwnableComponent]
:vesting-schedule: xref:api/finance.adoc#VestingComponent-Vesting-Schedule[VestingSchedule]
:AmountReleased: xref:IVesting-AmountReleased[AmountReleased]

= Finance

This crate includes primitives for financial systems.

== Vesting

[.contract]
[[IVesting]]
=== `++IVesting++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/finance/src/vesting/interface.cairo[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_finance::vesting::interface::IVesting;
```

Common interface for contracts implementing the vesting functionality.

[.contract-index]
.Functions
--
* xref:#IVesting-start[`++start()++`]
* xref:#IVesting-cliff[`++cliff()++`]
* xref:#IVesting-duration[`++duration()++`]
* xref:#IVesting-end[`++end()++`]
* xref:#IVesting-released[`++released(token)++`]
* xref:#IVesting-releasable[`++releasable(token)++`]
* xref:#IVesting-vested_amount[`++vested_amount(token, timestamp)++`]
* xref:#IVesting-release[`++release(token)++`]
--

[.contract-index]
.Events
--
* xref:#IVesting-AmountReleased[`++AmountReleased(token, amount)++`]
--

[#IVesting-Functions]
==== Functions

[.contract-item]
[[IVesting-start]]
==== `[.contract-item-name]#++start++#++() → u64++` [.item-kind]#external#

Returns the timestamp marking the beginning of the vesting period.

[.contract-item]
[[IVesting-cliff]]
==== `[.contract-item-name]#++cliff++#++() → u64++` [.item-kind]#external#

Returns the timestamp marking the end of the cliff period.

[.contract-item]
[[IVesting-duration]]
==== `[.contract-item-name]#++duration++#++() → u64++` [.item-kind]#external#

Returns the total duration of the vesting period.

[.contract-item]
[[IVesting-end]]
==== `[.contract-item-name]#++end++#++() → u64++` [.item-kind]#external#

Returns the timestamp marking the end of the vesting period.

[.contract-item]
[[IVesting-released]]
==== `[.contract-item-name]#++released++#++(token: ContractAddress) → u256++` [.item-kind]#external#

Returns the already released amount for a given `token`.

[.contract-item]
[[IVesting-releasable]]
==== `[.contract-item-name]#++releasable++#++(token: ContractAddress) → u256++` [.item-kind]#external#

Returns the amount of a given `token` that can be released at the time of the call.

[.contract-item]
[[IVesting-vested_amount]]
==== `[.contract-item-name]#++vested_amount++#++(token: ContractAddress, timestamp: u64) → u256++` [.item-kind]#external#

Returns the total vested amount of a specified `token` at a given `timestamp`.

[.contract-item]
[[IVesting-release]]
==== `[.contract-item-name]#++release++#++(token: ContractAddress) → u256++` [.item-kind]#external#

Releases the amount of a given `token` that has already vested and returns that amount.

May emit an {AmountReleased} event.

[#IVesting-Events]
==== Events

[.contract-item]
[[IVesting-AmountReleased]]
==== `[.contract-item-name]#++AmountReleased++#++(token: ContractAddress, amount: u256)++` [.item-kind]#event#

Emitted when vested tokens are released to the beneficiary.

[.contract]
[[VestingComponent]]
=== `++VestingComponent++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/finance/src/vesting/vesting.cairo[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_finance::vesting::VestingComponent;
```

Vesting component implementing the xref:IVesting[`IVesting`] interface.

[.contract-index]
.Vesting Schedule Trait Implementations
--
.functions
* xref:#VestingComponent-calculate_vested_amount[`++calculate_vested_amount(self, token, total_allocation, 
timestamp, start, duration, cliff)++`]
--

[.contract-index#VestingComponent-Embeddable-Impls]
.Embeddable Implementations
--
[.sub-index#VestingComponent-Embeddable-Impls-VestingImpl]
.VestingImpl
* xref:#VestingComponent-start[`++start(self)++`]
* xref:#VestingComponent-cliff[`++cliff(self)++`]
* xref:#VestingComponent-duration[`++duration(self)++`]
* xref:#VestingComponent-end[`++end(self)++`]
* xref:#VestingComponent-released[`++released(self, token)++`]
* xref:#VestingComponent-releasable[`++releasable(self, token)++`]
* xref:#VestingComponent-vested_amount[`++vested_amount(self, token, timestamp)++`]
* xref:#VestingComponent-release[`++release(self, token)++`]
--

[.contract-index]
.Internal implementations
--
.InternalImpl
* xref:#VestingComponent-initializer[`++initializer(self, start, duration, cliff_duration)++`]
* xref:#VestingComponent-resolve_vested_amount[`++resolve_vested_amount(self, token, timestamp)++`]
--

[#VestingComponent-Vesting-Schedule]
==== VestingSchedule trait

A trait that defines the logic for calculating the vested amount based on a given timestamp.

NOTE: You can read more about the trait's purpose and how to use it xref:finance.adoc#vesting_schedule[here].

[.contract-item]
[[VestingComponent-calculate_vested_amount]]
==== `[.contract-item-name]#++calculate_vested_amount++#++(self: @ContractState, token: ContractAddress, total_allocation: u256, timestamp: u64, start: u64, duration: u64, cliff: u64) → u256++` [.item-kind]#internal#

Calculates and returns the vested amount at a given `timestamp` based on the core vesting parameters.

[#VestingComponent-Functions]
==== Functions

[.contract-item]
[[VestingComponent-start]]
==== `[.contract-item-name]#++start++#++(self: @ContractState) → u64++` [.item-kind]#external#

Returns the timestamp marking the beginning of the vesting period.

[.contract-item]
[[VestingComponent-cliff]]
==== `[.contract-item-name]#++cliff++#++(self: @ContractState) → u64++` [.item-kind]#external#

Returns the timestamp marking the end of the cliff period.

[.contract-item]
[[VestingComponent-duration]]
==== `[.contract-item-name]#++duration++#++(self: @ContractState) → u64++` [.item-kind]#external#

Returns the total duration of the vesting period.

[.contract-item]
[[VestingComponent-end]]
==== `[.contract-item-name]#++end++#++(self: @ContractState) → u64++` [.item-kind]#external#

Returns the timestamp marking the end of the vesting period.

[.contract-item]
[[VestingComponent-released]]
==== `[.contract-item-name]#++released++#++(self: @ContractState, token: ContractAddress) → u256++` [.item-kind]#external#

Returns the already released amount for a given `token`.

[.contract-item]
[[VestingComponent-releasable]]
==== `[.contract-item-name]#++releasable++#++(self: @ContractState, token: ContractAddress) → u256++` [.item-kind]#external#

Returns the amount of a given `token` that can be released at the time of the call.

[.contract-item]
[[VestingComponent-vested_amount]]
==== `[.contract-item-name]#++vested_amount++#++(self: @ContractState, token: ContractAddress, timestamp: u64) → u256++` [.item-kind]#external#

Returns the total vested amount of a specified `token` at a given `timestamp`.

[.contract-item]
[[VestingComponent-release]]
==== `[.contract-item-name]#++release++#++(ref self: ContractState, token: ContractAddress) → u256++` [.item-kind]#external#

Releases the amount of a given `token` that has already vested and returns that amount.

NOTE: If the releasable amount is zero, this function won't emit the event
or attempt to transfer the tokens.

Requirements:

- `transfer` call to the `token` must return `true` indicating a successful transfer.

May emit an {AmountReleased} event.

[#VestingComponent-Internal-Functions]
==== Internal functions

[.contract-item]
[[VestingComponent-initializer]]
==== `[.contract-item-name]#++initializer++#++(ref self: ContractState, start: u64, duration: u64, cliff_duration: u64)++` [.item-kind]#internal#

Initializes the component by setting the vesting `start`, `duration` and `cliff_duration`. To prevent 
reinitialization, this should only be used inside of a contract's constructor.

Requirements:

- `cliff_duration` must be less than or equal to `duration`.

[.contract-item]
[[VestingComponent-resolve_vested_amount]]
==== `[.contract-item-name]#++resolve_vested_amount++#++(self: @ContractState, token: ContractAddress, timestamp: u64) → u256++` [.item-kind]#internal#

Returns the vested amount that's calculated using the {vesting-schedule} trait implementation.

[.contract]
[[LinearVestingSchedule]]
=== `++LinearVestingSchedule++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/finance/src/vesting/vesting.cairo[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_finance::vesting::LinearVestingSchedule;
```

Defines the logic for calculating the vested amount, incorporating a cliff period.
It returns 0 before the cliff ends. After the cliff period, the vested amount returned
is directly proportional to the time passed since the start of the vesting schedule.

== Presets

[.contract]
[[VestingWallet]]
=== `++VestingWallet++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/presets/src/vesting.cairo[{github-icon},role=heading-link]

```cairo
use openzeppelin::presets::VestingWallet;
```

A non-upgradable contract leveraging {vesting-component} and {ownable-component}.

NOTE: The contract is intentionally designed to be non-upgradable to ensure that neither the vesting initiator
nor the vesting beneficiary can modify the vesting schedule without the consent of the other party.

include::../utils/_class_hashes.adoc[]

[.contract-index]
.{presets-page}
--
{VestingWallet-class-hash}
--

[.contract-index]
.Constructor
--
* xref:#VestingWallet-constructor[`++constructor(self, beneficiary, start, duration, cliff_duration)++`]
--

[.contract-index]
.Embedded Implementations
--
.VestingComponent

* xref:#VestingComponent-Embeddable-Impls-VestingImpl[`++VestingImpl++`]

.OwnableComponent

* xref:/api/access.adoc#OwnableComponent-Mixin-Impl[`++OwnableMixinImpl++`]
--

[#VestingWallet-constructor-section]
==== Constructor

[.contract-item]
[[VestingWallet-constructor]]
==== `[.contract-item-name]#++constructor++#++(ref self: ContractState, beneficiary: ContractAddress, start: u64, duration: u64, cliff_duration: u64)++` [.item-kind]#constructor#

Initializes the vesting component by setting the vesting `start`, `duration` and `cliff_duration`. Assigns `beneficiary` as the contract owner and the vesting beneficiary.

Requirements:

- `cliff_duration` must be less than or equal to `duration`.
// llmstxt-short-description: Describes the Governor component and extensions logic and usage

= Governor

:votes-component: xref:api/governance.adoc#VotesComponent[VotesComponent]
:governor-component: xref:api/governance.adoc#GovernorComponent[GovernorComponent]
:access-control: xref:access.adoc#role_based_accesscontrol[AccessControl]
:timelock-controller: xref:governance/timelock.adoc[TimelockController]
:ivotes: xref:api/governance.adoc#IVotes[IVotes]

include::../utils/_common.adoc[]

Decentralized protocols are in constant evolution from the moment they are publicly released. Often,
the initial team retains control of this evolution in the first stages, but eventually delegates it
to a community of stakeholders. The process by which this community makes decisions is called
on-chain governance, and it has become a central component of decentralized protocols, fueling
varied decisions such as parameter tweaking, smart contract upgrades, integrations with other
protocols, treasury management, grants, etc.

This governance protocol is generally implemented in a special-purpose contract called “Governor”. In
OpenZeppelin Contracts for Cairo, we set out to build a modular system of Governor components where different
requirements can be accommodated by implementing specific traits. You will find the most common requirements out of the box,
but writing additional ones is simple, and we will be adding new features as requested by the community in future releases.

== Usage and setup

=== Token

The voting power of each account in our governance setup will be determined by an ERC20 or an ERC721 token. The token has
to implement the {votes-component} extension. This extension will keep track of historical balances so that voting power
is retrieved from past snapshots rather than current balance, which is an important protection that prevents double voting.

If your project already has a live token that does not include Votes and is not upgradeable, you can wrap it in a
governance token by using a wrapper. This will allow token holders to participate in governance by wrapping their tokens 1-to-1.

NOTE: The library currently does not include a wrapper for tokens, but it will be added in a future release.

NOTE: Currently, the clock mode is fixed to block timestamps, since the Votes component uses the block timestamp to track
checkpoints. We plan to add support for more flexible clock modes in Votes in a future release, allowing to use, for example,
block numbers instead.

=== Governor

We will initially build a Governor without a timelock. The core logic is given by the {governor-component}, but we
still need to choose:

1) how voting power is determined,

2) how many votes are needed for quorum,

3) what options people have when casting a vote and how those votes are counted, and

4) the execution mechanism that should be used.

Each of these aspects is customizable by writing your own extensions,
or more easily choosing one from the library.

:GovernorVotes: xref:api/governance.adoc#GovernorVotesComponent[GovernorVotes]
:GovernorVotesQuorumFraction: xref:api/governance.adoc#GovernorVotesQuorumFractionComponent[GovernorVotesQuorumFraction]
:GovernorCountingSimple: xref:api/governance.adoc#GovernorCountingSimpleComponent[GovernorCountingSimple]
:GovernorCoreExecution: xref:api/governance.adoc#GovernorCoreExecutionComponent[GovernorCoreExecution]
:GovernorSettings: xref:api/governance.adoc#GovernorSettingsComponent[GovernorSettings]
:GovernorTimelockExecution: xref:api/governance.adoc#GovernorTimelockExecutionComponent[GovernorTimelockExecution]
:GovernorSettingsTrait: xref:api/governance.adoc#GovernorComponent[GovernorSettingsTrait]

**For 1)** we will use the {GovernorVotes} extension, which hooks to an {ivotes} instance to determine the voting power
of an account based on the token balance they hold when a proposal becomes active.
This module requires the address of the token to be passed as an argument to the initializer.

**For 2)** we will use {GovernorVotesQuorumFraction}. This works together with the {ivotes} instance to define the quorum as a
percentage of the total supply at the block when a proposal’s voting power is retrieved. This requires an initializer
parameter to set the percentage besides the votes token address. Most Governors nowadays use 4%. Since the quorum denominator
is 1000 for precision, we initialize the module with a numerator of 40, resulting in a 4% quorum (40/1000 = 0.04 or 4%).

**For 3)** we will use {GovernorCountingSimple}, an extension that offers 3 options to voters: For, Against, and Abstain,
and where only For and Abstain votes are counted towards quorum.

**For 4)** we will use {GovernorCoreExecution}, an extension that allows proposal execution directly through the governor.

NOTE: Another option is {GovernorTimelockExecution}. An example can be found in the next section.

Besides these, we also need an implementation for the {GovernorSettingsTrait} defining the voting delay, voting period,
and proposal threshold. While we can use the {GovernorSettings} extension which allows to set these parameters by the
governor itself, we will implement the trait locally in the contract and set the voting delay, voting period,
and proposal threshold as constant values.

__voting_delay__: How long after a proposal is created should voting power be fixed. A large voting delay gives
users time to unstake tokens if necessary.

__voting_period__: How long does a proposal remain open to votes.

NOTE: These parameters are specified in the unit defined in the token’s clock, which is for now always timestamps.

__proposal_threshold__: This restricts proposal creation to accounts who have enough voting power.

An implementation of `GovernorComponent::ImmutableConfig` is also required. For the example below, we have used
the `DefaultConfig`. Check the {immutable-config} guide for more details.

The last missing step is to add an `SNIP12Metadata` implementation used to retrieve the name and version of the governor.

[, cairo]
----
#[starknet::contract]
mod MyGovernor {
    use openzeppelin_governance::governor::GovernorComponent::InternalTrait as GovernorInternalTrait;
    use openzeppelin_governance::governor::extensions::GovernorVotesQuorumFractionComponent::InternalTrait;
    use openzeppelin_governance::governor::extensions::{
        GovernorVotesQuorumFractionComponent, GovernorCountingSimpleComponent,
        GovernorCoreExecutionComponent,
    };
    use openzeppelin_governance::governor::{GovernorComponent, DefaultConfig};
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_utils::cryptography::snip12::SNIP12Metadata;
    use starknet::ContractAddress;

    pub const VOTING_DELAY: u64 = 86400; // 1 day
    pub const VOTING_PERIOD: u64 = 604800; // 1 week
    pub const PROPOSAL_THRESHOLD: u256 = 10;
    pub const QUORUM_NUMERATOR: u256 = 40; // 4%

    component!(path: GovernorComponent, storage: governor, event: GovernorEvent);
    component!(
        path: GovernorVotesQuorumFractionComponent,
        storage: governor_votes,
        event: GovernorVotesEvent
    );
    component!(
        path: GovernorCountingSimpleComponent,
        storage: governor_counting_simple,
        event: GovernorCountingSimpleEvent
    );
    component!(
        path: GovernorCoreExecutionComponent,
        storage: governor_core_execution,
        event: GovernorCoreExecutionEvent
    );
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // Governor
    #[abi(embed_v0)]
    impl GovernorImpl = GovernorComponent::GovernorImpl<ContractState>;

    // Extensions external
    #[abi(embed_v0)]
    impl QuorumFractionImpl =
        GovernorVotesQuorumFractionComponent::QuorumFractionImpl<ContractState>;

    // Extensions internal
    impl GovernorQuorumImpl = GovernorVotesQuorumFractionComponent::GovernorQuorum<ContractState>;
    impl GovernorVotesImpl = GovernorVotesQuorumFractionComponent::GovernorVotes<ContractState>;
    impl GovernorCountingSimpleImpl =
        GovernorCountingSimpleComponent::GovernorCounting<ContractState>;
    impl GovernorCoreExecutionImpl =
        GovernorCoreExecutionComponent::GovernorExecution<ContractState>;

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        pub governor: GovernorComponent::Storage,
        #[substorage(v0)]
        pub governor_votes: GovernorVotesQuorumFractionComponent::Storage,
        #[substorage(v0)]
        pub governor_counting_simple: GovernorCountingSimpleComponent::Storage,
        #[substorage(v0)]
        pub governor_core_execution: GovernorCoreExecutionComponent::Storage,
        #[substorage(v0)]
        pub src5: SRC5Component::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        GovernorEvent: GovernorComponent::Event,
        #[flat]
        GovernorVotesEvent: GovernorVotesQuorumFractionComponent::Event,
        #[flat]
        GovernorCountingSimpleEvent: GovernorCountingSimpleComponent::Event,
        #[flat]
        GovernorCoreExecutionEvent: GovernorCoreExecutionComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event,
    }

    #[constructor]
    fn constructor(ref self: ContractState, votes_token: ContractAddress) {
        self.governor.initializer();
        self.governor_votes.initializer(votes_token, QUORUM_NUMERATOR);
    }

    //
    // SNIP12 Metadata
    //

    pub impl SNIP12MetadataImpl of SNIP12Metadata {
        fn name() -> felt252 {
            'DAPP_NAME'
        }

        fn version() -> felt252 {
            'DAPP_VERSION'
        }
    }

    //
    // Locally implemented extensions
    //

    pub impl GovernorSettings of GovernorComponent::GovernorSettingsTrait<ContractState> {
        /// See `GovernorComponent::GovernorSettingsTrait::voting_delay`.
        fn voting_delay(self: @GovernorComponent::ComponentState<ContractState>) -> u64 {
            VOTING_DELAY
        }

        /// See `GovernorComponent::GovernorSettingsTrait::voting_period`.
        fn voting_period(self: @GovernorComponent::ComponentState<ContractState>) -> u64 {
            VOTING_PERIOD
        }

        /// See `GovernorComponent::GovernorSettingsTrait::proposal_threshold`.
        fn proposal_threshold(self: @GovernorComponent::ComponentState<ContractState>) -> u256 {
            PROPOSAL_THRESHOLD
        }
    }
}
----

=== Timelock

It is good practice to add a timelock to governance decisions. This allows users to exit the system if they disagree
with a decision before it is executed. We will use OpenZeppelin’s {timelock-controller} in combination with the
GovernorTimelockExecution extension.

IMPORTANT: When using a timelock, it is the timelock that will execute proposals and thus the timelock that should
hold any funds, ownership, and access control roles.

TimelockController uses an {access-control} setup that we need to understand in order to set up roles.

The Proposer role is in charge of queueing operations: this is the role the Governor instance must be granted,
and it MUST be the only proposer (and canceller) in the system.

The Executor role is in charge of executing already available operations: we can assign this role to the special
zero address to allow anyone to execute (if operations can be particularly time sensitive, the Governor should be made Executor instead).

The Canceller role is in charge of canceling operations: the Governor instance must be granted this role,
and it MUST be the only canceller in the system.

Lastly, there is the Admin role, which can grant and revoke the two previous roles: this is a very sensitive role that will be granted automatically to the timelock itself, and optionally to a second account, which can be used for ease of setup but should promptly renounce the role.

The following example uses the GovernorTimelockExecution extension, together with GovernorSettings, and uses a
fixed quorum value instead of a percentage:

[, cairo]
----
#[starknet::contract]
pub mod MyTimelockedGovernor {
    use openzeppelin_governance::governor::GovernorComponent::InternalTrait as GovernorInternalTrait;
    use openzeppelin_governance::governor::extensions::GovernorSettingsComponent::InternalTrait as GovernorSettingsInternalTrait;
    use openzeppelin_governance::governor::extensions::GovernorTimelockExecutionComponent::InternalTrait as GovernorTimelockExecutionInternalTrait;
    use openzeppelin_governance::governor::extensions::GovernorVotesComponent::InternalTrait as GovernorVotesInternalTrait;
    use openzeppelin_governance::governor::extensions::{
        GovernorVotesComponent, GovernorSettingsComponent, GovernorCountingSimpleComponent,
        GovernorTimelockExecutionComponent
    };
    use openzeppelin_governance::governor::{GovernorComponent, DefaultConfig};
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_utils::cryptography::snip12::SNIP12Metadata;
    use starknet::ContractAddress;

    pub const VOTING_DELAY: u64 = 86400; // 1 day
    pub const VOTING_PERIOD: u64 = 604800; // 1 week
    pub const PROPOSAL_THRESHOLD: u256 = 10;
    pub const QUORUM: u256 = 100_000_000;

    component!(path: GovernorComponent, storage: governor, event: GovernorEvent);
    component!(path: GovernorVotesComponent, storage: governor_votes, event: GovernorVotesEvent);
    component!(
        path: GovernorSettingsComponent, storage: governor_settings, event: GovernorSettingsEvent
    );
    component!(
        path: GovernorCountingSimpleComponent,
        storage: governor_counting_simple,
        event: GovernorCountingSimpleEvent
    );
    component!(
        path: GovernorTimelockExecutionComponent,
        storage: governor_timelock_execution,
        event: GovernorTimelockExecutionEvent
    );
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // Governor
    #[abi(embed_v0)]
    impl GovernorImpl = GovernorComponent::GovernorImpl<ContractState>;

    // Extensions external
    #[abi(embed_v0)]
    impl VotesTokenImpl = GovernorVotesComponent::VotesTokenImpl<ContractState>;
    #[abi(embed_v0)]
    impl GovernorSettingsAdminImpl =
        GovernorSettingsComponent::GovernorSettingsAdminImpl<ContractState>;
    #[abi(embed_v0)]
    impl TimelockedImpl =
        GovernorTimelockExecutionComponent::TimelockedImpl<ContractState>;

    // Extensions internal
    impl GovernorVotesImpl = GovernorVotesComponent::GovernorVotes<ContractState>;
    impl GovernorSettingsImpl = GovernorSettingsComponent::GovernorSettings<ContractState>;
    impl GovernorCountingSimpleImpl =
        GovernorCountingSimpleComponent::GovernorCounting<ContractState>;
    impl GovernorTimelockExecutionImpl =
        GovernorTimelockExecutionComponent::GovernorExecution<ContractState>;

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        pub governor: GovernorComponent::Storage,
        #[substorage(v0)]
        pub governor_votes: GovernorVotesComponent::Storage,
        #[substorage(v0)]
        pub governor_settings: GovernorSettingsComponent::Storage,
        #[substorage(v0)]
        pub governor_counting_simple: GovernorCountingSimpleComponent::Storage,
        #[substorage(v0)]
        pub governor_timelock_execution: GovernorTimelockExecutionComponent::Storage,
        #[substorage(v0)]
        pub src5: SRC5Component::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        GovernorEvent: GovernorComponent::Event,
        #[flat]
        GovernorVotesEvent: GovernorVotesComponent::Event,
        #[flat]
        GovernorSettingsEvent: GovernorSettingsComponent::Event,
        #[flat]
        GovernorCountingSimpleEvent: GovernorCountingSimpleComponent::Event,
        #[flat]
        GovernorTimelockExecutionEvent: GovernorTimelockExecutionComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event,
    }

    #[constructor]
    fn constructor(
        ref self: ContractState, votes_token: ContractAddress, timelock_controller: ContractAddress
    ) {
        self.governor.initializer();
        self.governor_votes.initializer(votes_token);
        self.governor_settings.initializer(VOTING_DELAY, VOTING_PERIOD, PROPOSAL_THRESHOLD);
        self.governor_timelock_execution.initializer(timelock_controller);
    }

    //
    // SNIP12 Metadata
    //

    pub impl SNIP12MetadataImpl of SNIP12Metadata {
        fn name() -> felt252 {
            'DAPP_NAME'
        }

        fn version() -> felt252 {
            'DAPP_VERSION'
        }
    }

    //
    // Locally implemented extensions
    //

    impl GovernorQuorum of GovernorComponent::GovernorQuorumTrait<ContractState> {
        /// See `GovernorComponent::GovernorQuorumTrait::quorum`.
        fn quorum(self: @GovernorComponent::ComponentState<ContractState>, timepoint: u64) -> u256 {
            QUORUM
        }
    }
}
----

== Interface

This is the full interface of the `Governor` implementation:
[source,cairo]
----
#[starknet::interface]
pub trait IGovernor<TState> {
    fn name(self: @TState) -> felt252;
    fn version(self: @TState) -> felt252;
    fn COUNTING_MODE(self: @TState) -> ByteArray;
    fn hash_proposal(self: @TState, calls: Span<Call>, description_hash: felt252) -> felt252;
    fn state(self: @TState, proposal_id: felt252) -> ProposalState;
    fn proposal_threshold(self: @TState) -> u256;
    fn proposal_snapshot(self: @TState, proposal_id: felt252) -> u64;
    fn proposal_deadline(self: @TState, proposal_id: felt252) -> u64;
    fn proposal_proposer(self: @TState, proposal_id: felt252) -> ContractAddress;
    fn proposal_eta(self: @TState, proposal_id: felt252) -> u64;
    fn proposal_needs_queuing(self: @TState, proposal_id: felt252) -> bool;
    fn voting_delay(self: @TState) -> u64;
    fn voting_period(self: @TState) -> u64;
    fn quorum(self: @TState, timepoint: u64) -> u256;
    fn get_votes(self: @TState, account: ContractAddress, timepoint: u64) -> u256;
    fn get_votes_with_params(
        self: @TState, account: ContractAddress, timepoint: u64, params: Span<felt252>
    ) -> u256;
    fn has_voted(self: @TState, proposal_id: felt252, account: ContractAddress) -> bool;
    fn propose(ref self: TState, calls: Span<Call>, description: ByteArray) -> felt252;
    fn queue(ref self: TState, calls: Span<Call>, description_hash: felt252) -> felt252;
    fn execute(ref self: TState, calls: Span<Call>, description_hash: felt252) -> felt252;
    fn cancel(ref self: TState, calls: Span<Call>, description_hash: felt252) -> felt252;
    fn cast_vote(ref self: TState, proposal_id: felt252, support: u8) -> u256;
    fn cast_vote_with_reason(
        ref self: TState, proposal_id: felt252, support: u8, reason: ByteArray
    ) -> u256;
    fn cast_vote_with_reason_and_params(
        ref self: TState,
        proposal_id: felt252,
        support: u8,
        reason: ByteArray,
        params: Span<felt252>
    ) -> u256;
    fn cast_vote_by_sig(
        ref self: TState,
        proposal_id: felt252,
        support: u8,
        voter: ContractAddress,
        signature: Span<felt252>
    ) -> u256;
    fn cast_vote_with_reason_and_params_by_sig(
        ref self: TState,
        proposal_id: felt252,
        support: u8,
        voter: ContractAddress,
        reason: ByteArray,
        params: Span<felt252>,
        signature: Span<felt252>
    ) -> u256;
    fn nonces(self: @TState, voter: ContractAddress) -> felt252;
    fn relay(ref self: TState, call: Call);
}
----
// llmstxt-short-description: Describes the Multisig component key features and its usage

= Multisig

:multisig-component: xref:api/governance.adoc#MultisigComponent[MultisigComponent]
:snip12-metadata: xref:api/utilities.adoc#snip12[SNIP12Metadata]

The Multisig component implements a multi-signature mechanism to enhance the security and
governance of smart contract transactions. It ensures that no single signer can unilaterally
execute critical actions, requiring multiple registered signers to approve and collectively
execute transactions.

This component is designed to secure operations such as fund management or protocol governance,
where collective decision-making is essential. The Multisig Component is self-administered,
meaning that changes to signers or quorum must be approved through the multisig process itself.

== Key features

- *Multi-Signature Security*: transactions must be approved by multiple signers, ensuring
distributed governance.

- *Quorum Enforcement*: defines the minimum number of approvals required for transaction execution.

- *Self-Administration*: all modifications to the component (e.g., adding or removing signers)
must pass through the multisig process.

- *Event Logging*: provides comprehensive event logging for transparency and auditability.

== Signer management

The Multisig component introduces the concept of signers and quorum:

- *Signers*: only registered signers can submit, confirm, revoke, or execute transactions. The Multisig
Component supports adding, removing, or replacing signers.
- *Quorum*: the quorum defines the minimum number of confirmations required to approve a transaction.

NOTE: To prevent unauthorized modifications, only the contract itself can add, remove, or replace signers or change the quorum.
This ensures that all modifications pass through the multisig approval process.

== Transaction lifecycle

The state of a transaction is represented by the `TransactionState` enum and can be retrieved
by calling the `get_transaction_state` function with the transaction's identifier.

The identifier of a multisig transaction is a `felt252` value, computed as the Pedersen hash
of the transaction's calls and salt. It can be computed by invoking the implementing contract's
`hash_transaction` method for single-call transactions or `hash_transaction_batch` for multi-call
transactions. Submitting a transaction with identical calls and the same salt value a second time
will fail, as transaction identifiers must be unique. To resolve this, use a different salt value
to generate a unique identifier.

A transaction in the Multisig component follows a specific lifecycle:

`NotFound` → `Pending` → `Confirmed` → `Executed`

- *NotFound*: the transaction does not exist.
- *Pending*: the transaction exists but has not reached the required confirmations.
- *Confirmed*: the transaction has reached the quorum but has not yet been executed.
- *Executed*: the transaction has been successfully executed.

== Usage

Integrating the Multisig functionality into a contract requires implementing {multisig-component}.
The contract's constructor should initialize the component with a quorum value and a list of initial signers.

Here's an example of a simple wallet contract featuring the Multisig functionality:

[,cairo]
----
#[starknet::contract]
mod MultisigWallet {
    use openzeppelin_governance::multisig::MultisigComponent;
    use starknet::ContractAddress;

    component!(path: MultisigComponent, storage: multisig, event: MultisigEvent);

    #[abi(embed_v0)]
    impl MultisigImpl = MultisigComponent::MultisigImpl<ContractState>;
    impl MultisigInternalImpl = MultisigComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        multisig: MultisigComponent::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        MultisigEvent: MultisigComponent::Event,
    }

    #[constructor]
    fn constructor(ref self: ContractState, quorum: u32, signers: Span<ContractAddress>) {
        self.multisig.initializer(quorum, signers);
    }
}
----

== Interface

This is the interface of a contract implementing the {multisig-component}:

[,cairo]
----
#[starknet::interface]
pub trait MultisigABI<TState> {
    // Read functions
    fn get_quorum(self: @TState) -> u32;
    fn is_signer(self: @TState, signer: ContractAddress) -> bool;
    fn get_signers(self: @TState) -> Span<ContractAddress>;
    fn is_confirmed(self: @TState, id: TransactionID) -> bool;
    fn is_confirmed_by(self: @TState, id: TransactionID, signer: ContractAddress) -> bool;
    fn is_executed(self: @TState, id: TransactionID) -> bool;
    fn get_submitted_block(self: @TState, id: TransactionID) -> u64;
    fn get_transaction_state(self: @TState, id: TransactionID) -> TransactionState;
    fn get_transaction_confirmations(self: @TState, id: TransactionID) -> u32;
    fn hash_transaction(
        self: @TState,
        to: ContractAddress,
        selector: felt252,
        calldata: Span<felt252>,
        salt: felt252,
    ) -> TransactionID;
    fn hash_transaction_batch(self: @TState, calls: Span<Call>, salt: felt252) -> TransactionID;

    // Write functions
    fn add_signers(ref self: TState, new_quorum: u32, signers_to_add: Span<ContractAddress>);
    fn remove_signers(ref self: TState, new_quorum: u32, signers_to_remove: Span<ContractAddress>);
    fn replace_signer(
        ref self: TState, signer_to_remove: ContractAddress, signer_to_add: ContractAddress,
    );
    fn change_quorum(ref self: TState, new_quorum: u32);
    fn submit_transaction(
        ref self: TState,
        to: ContractAddress,
        selector: felt252,
        calldata: Span<felt252>,
        salt: felt252,
    ) -> TransactionID;
    fn submit_transaction_batch(
        ref self: TState, calls: Span<Call>, salt: felt252,
    ) -> TransactionID;
    fn confirm_transaction(ref self: TState, id: TransactionID);
    fn revoke_confirmation(ref self: TState, id: TransactionID);
    fn execute_transaction(
        ref self: TState,
        to: ContractAddress,
        selector: felt252,
        calldata: Span<felt252>,
        salt: felt252,
    );
    fn execute_transaction_batch(ref self: TState, calls: Span<Call>, salt: felt252);
}
----
// llmstxt-short-description: Describes the Timelock Controller component key features and its usage

= Timelock Controller

:timelock-component: xref:api/governance.adoc#TimelockControllerComponent[TimelockControllerComponent]
:accesscontrol-component: xref:api/access.adoc#AccessControlComponent[AccessControlComponent]
:src5-component: xref:api/introspection.adoc#SRC5Component[SRC5Component]

The Timelock Controller provides a means of enforcing time delays on the execution of transactions. This is considered good practice regarding governance systems because it allows users the opportunity to exit the system if they disagree with a decision before it is executed.

NOTE: The Timelock contract itself executes transactions, not the user. The Timelock should, therefore, hold associated funds, ownership, and access control roles.

== Operation lifecycle

The state of an operation is represented by the `OperationState` enum and can be retrieved
by calling the `get_operation_state` function with the operation's identifier.

The identifier of an operation is a `felt252` value, computed as the Pedersen hash of the
operation's call or calls, its predecessor, and salt. It can be computed by invoking the
implementing contract's `hash_operation` function for single-call operations or
`hash_operation_batch` for multi-call operations. Submitting an operation with identical calls,
predecessor, and the same salt value a second time will fail, as operation identifiers must be
unique. To resolve this, use a different salt value to generate a unique identifier.

Timelocked operations follow a specific lifecycle:

`Unset` → `Waiting` → `Ready` → `Done`

- `Unset`: the operation has not been scheduled or has been canceled.
- `Waiting`: the operation has been scheduled and is pending the scheduled delay.
- `Ready`: the timer has expired, and the operation is eligible for execution.
- `Done`: the operation has been executed.

== Timelock flow

=== Schedule

:schedule: xref:api/governance.adoc#ITimelock-schedule[schedule]
:get_timestamp: xref:api/governance.adoc#ITimelock-get_timestamp[get_timestamp]

When a proposer calls {schedule}, the `OperationState` moves from `Unset` to `Waiting`.
This starts a timer that must be greater than or equal to the minimum delay.
The timer expires at a timestamp accessible through {get_timestamp}.
Once the timer expires, the `OperationState` automatically moves to the `Ready` state.
At this point, it can be executed.

=== Execute

:execute: xref:api/governance.adoc#ITimelock-execute[execute]

By calling {execute}, an executor triggers the operation's underlying transactions and moves it to the `Done` state. If the operation has a predecessor, the predecessor's operation must be in the `Done` state for this transaction to succeed.

=== Cancel

:cancel: xref:api/governance.adoc#ITimelock-cancel[cancel]

The {cancel} function allows cancellers to cancel any pending operations.
This resets the operation to the `Unset` state.
It is therefore possible for a proposer to re-schedule an operation that has been cancelled.
In this case, the timer restarts when the operation is re-scheduled.

=== Roles

{timelock-component} leverages an {accesscontrol-component} setup that we need to understand in order to set up roles.

- `PROPOSER_ROLE` - in charge of queueing operations.

- `CANCELLER_ROLE` - may cancel scheduled operations.
During initialization, accounts granted with `PROPOSER_ROLE` will also be granted `CANCELLER_ROLE`.
Therefore, the initial proposers may also cancel operations after they are scheduled.

- `EXECUTOR_ROLE` - in charge of executing already available operations.

- `DEFAULT_ADMIN_ROLE` - can grant and revoke the three previous roles.

CAUTION: The `DEFAULT_ADMIN_ROLE` is a sensitive role that will be granted automatically to the timelock itself and optionally to a second account.
The latter case may be required to ease a contract's initial configuration; however, this role should promptly be renounced.

Furthermore, the timelock component supports the concept of open roles for the `EXECUTOR_ROLE`.
This allows anyone to execute an operation once it's in the `Ready` OperationState.
To enable the `EXECUTOR_ROLE` to be open, grant the zero address with the `EXECUTOR_ROLE`.

CAUTION: Be very careful with enabling open roles as _anyone_ can call the function.

=== Minimum delay

:get_min_delay: xref:api/governance.adoc#ITimelock-get_min_delay[get_min_delay]

The minimum delay of the timelock acts as a buffer from when a proposer schedules an operation to the earliest point at which an executor may execute that operation.
The idea is for users, should they disagree with a scheduled proposal, to have options such as exiting the system or making their case for cancellers to cancel the operation.

After initialization, the only way to change the timelock's minimum delay is to schedule it and execute it with the same flow as any other operation.

The minimum delay of a contract is accessible through {get_min_delay}.

=== Usage

Integrating the timelock into a contract requires integrating {timelock-component} as well as {src5-component} and {accesscontrol-component} as dependencies.
The contract's constructor should initialize the timelock which consists of setting the:

- Proposers and executors.
- Minimum delay between scheduling and executing an operation.
- Optional admin if additional configuration is required.

NOTE: The optional admin should renounce their role once configuration is complete.

Here's an example of a simple timelock contract:

[,cairo]
----
#[starknet::contract]
mod TimelockControllerContract {
    use openzeppelin_access::accesscontrol::AccessControlComponent;
    use openzeppelin_governance::timelock::TimelockControllerComponent;
    use openzeppelin_introspection::src5::SRC5Component;
    use starknet::ContractAddress;

    component!(path: AccessControlComponent, storage: access_control, event: AccessControlEvent);
    component!(path: TimelockControllerComponent, storage: timelock, event: TimelockEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // Timelock Mixin
    #[abi(embed_v0)]
    impl TimelockMixinImpl =
        TimelockControllerComponent::TimelockMixinImpl<ContractState>;
    impl TimelockInternalImpl = TimelockControllerComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        access_control: AccessControlComponent::Storage,
        #[substorage(v0)]
        timelock: TimelockControllerComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        AccessControlEvent: AccessControlComponent::Event,
        #[flat]
        TimelockEvent: TimelockControllerComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        min_delay: u64,
        proposers: Span<ContractAddress>,
        executors: Span<ContractAddress>,
        admin: ContractAddress
    ) {
        self.timelock.initializer(min_delay, proposers, executors, admin);
    }
}
----

=== Interface

This is the full interface of the TimelockMixinImpl implementation:

[,cairo]
----
#[starknet::interface]
pub trait TimelockABI<TState> {
    // ITimelock
    fn is_operation(self: @TState, id: felt252) -> bool;
    fn is_operation_pending(self: @TState, id: felt252) -> bool;
    fn is_operation_ready(self: @TState, id: felt252) -> bool;
    fn is_operation_done(self: @TState, id: felt252) -> bool;
    fn get_timestamp(self: @TState, id: felt252) -> u64;
    fn get_operation_state(self: @TState, id: felt252) -> OperationState;
    fn get_min_delay(self: @TState) -> u64;
    fn hash_operation(self: @TState, call: Call, predecessor: felt252, salt: felt252) -> felt252;
    fn hash_operation_batch(
        self: @TState, calls: Span<Call>, predecessor: felt252, salt: felt252
    ) -> felt252;
    fn schedule(ref self: TState, call: Call, predecessor: felt252, salt: felt252, delay: u64);
    fn schedule_batch(
        ref self: TState, calls: Span<Call>, predecessor: felt252, salt: felt252, delay: u64
    );
    fn cancel(ref self: TState, id: felt252);
    fn execute(ref self: TState, call: Call, predecessor: felt252, salt: felt252);
    fn execute_batch(ref self: TState, calls: Span<Call>, predecessor: felt252, salt: felt252);
    fn update_delay(ref self: TState, new_delay: u64);

    // ISRC5
    fn supports_interface(self: @TState, interface_id: felt252) -> bool;

    // IAccessControl
    fn has_role(self: @TState, role: felt252, account: ContractAddress) -> bool;
    fn get_role_admin(self: @TState, role: felt252) -> felt252;
    fn grant_role(ref self: TState, role: felt252, account: ContractAddress);
    fn revoke_role(ref self: TState, role: felt252, account: ContractAddress);
    fn renounce_role(ref self: TState, role: felt252, account: ContractAddress);

    // IAccessControlCamel
    fn hasRole(self: @TState, role: felt252, account: ContractAddress) -> bool;
    fn getRoleAdmin(self: @TState, role: felt252) -> felt252;
    fn grantRole(ref self: TState, role: felt252, account: ContractAddress);
    fn revokeRole(ref self: TState, role: felt252, account: ContractAddress);
    fn renounceRole(ref self: TState, role: felt252, account: ContractAddress);
}
----
// llmstxt-short-description: Describes the Votes component key features and its usage

= Votes

:votes-component: xref:api/governance.adoc#VotesComponent[VotesComponent]
:delegate: xref:api/governance.adoc#VotesComponent-delegate[delegate]
:delegate_by_sig: xref:api/governance.adoc#VotesComponent-delegate_by_sig[delegate_by_sig]
:voting_units_trait: xref:api/governance.adoc#VotingUnitsTrait[VotingUnitsTrait]
:votes-usage: xref:Usage[usage]
:nonces-component: xref:api/utilities.adoc#NoncesComponent[NoncesComponent]
:snip12-metadata: xref:api/utilities.adoc#snip12[SNIP12Metadata]

The {votes-component} provides a flexible system for tracking and delegating voting power. This system allows users to delegate their voting power to other addresses, enabling more active participation in governance.

NOTE: By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.

IMPORTANT: The transferring of voting units must be handled by the implementing contract. In the case of `ERC20` and `ERC721` this is usually done via the hooks. You can check the {votes-usage} section for examples of how to implement this.

== Key features

1. *Delegation*: Users can delegate their voting power to any address, including themselves. Vote power can be delegated either by calling the {delegate} function directly, or by providing a signature to be used with {delegate_by_sig}.
2. *Historical lookups*: The system keeps track of historical snapshots for each account, which allows the voting power of an account to be queried at a specific timestamp. +
This can be used for example to determine the voting power of an account when a proposal was created, rather than using the current balance.

== Usage

When integrating the `VotesComponent`, the {voting_units_trait} must be implemented to get the voting units for a given account as a function of the implementing contract. +
For simplicity, this module already provides two implementations for `ERC20` and `ERC721` tokens, which will work out of the box if the respective components are integrated. +
Additionally, you must implement the {nonces-component} and the {snip12-metadata} trait to enable delegation by signatures.

Here's an example of how to structure a simple ERC20Votes contract:

[source,cairo]
----
#[starknet::contract]
mod ERC20VotesContract {
    use openzeppelin_governance::votes::VotesComponent;
    use openzeppelin_token::erc20::ERC20Component;
    use openzeppelin_utils::cryptography::nonces::NoncesComponent;
    use openzeppelin_utils::cryptography::snip12::SNIP12Metadata;
    use starknet::ContractAddress;

    component!(path: VotesComponent, storage: erc20_votes, event: ERC20VotesEvent);
    component!(path: ERC20Component, storage: erc20, event: ERC20Event);
    component!(path: NoncesComponent, storage: nonces, event: NoncesEvent);

    // Votes
    #[abi(embed_v0)]
    impl VotesImpl = VotesComponent::VotesImpl<ContractState>;
    impl VotesInternalImpl = VotesComponent::InternalImpl<ContractState>;

    // ERC20
    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    // Nonces
    #[abi(embed_v0)]
    impl NoncesImpl = NoncesComponent::NoncesImpl<ContractState>;

    #[storage]
    pub struct Storage {
        #[substorage(v0)]
        pub erc20_votes: VotesComponent::Storage,
        #[substorage(v0)]
        pub erc20: ERC20Component::Storage,
        #[substorage(v0)]
        pub nonces: NoncesComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC20VotesEvent: VotesComponent::Event,
        #[flat]
        ERC20Event: ERC20Component::Event,
        #[flat]
        NoncesEvent: NoncesComponent::Event
    }

    // Required for hash computation.
    pub impl SNIP12MetadataImpl of SNIP12Metadata {
        fn name() -> felt252 {
            'DAPP_NAME'
        }
        fn version() -> felt252 {
            'DAPP_VERSION'
        }
    }

    // We need to call the `transfer_voting_units` function after
    // every mint, burn and transfer.
    // For this, we use the `after_update` hook of the `ERC20Component::ERC20HooksTrait`.
    impl ERC20VotesHooksImpl of ERC20Component::ERC20HooksTrait<ContractState> {
        fn after_update(
            ref self: ERC20Component::ComponentState<ContractState>,
            from: ContractAddress,
            recipient: ContractAddress,
            amount: u256
        ) {
            let mut contract_state = self.get_contract_mut();
            contract_state.erc20_votes.transfer_voting_units(from, recipient, amount);
        }
    }

    #[constructor]
    fn constructor(ref self: ContractState) {
        self.erc20.initializer("MyToken", "MTK");
    }
}
----

And here's an example of how to structure a simple ERC721Votes contract:

[source,cairo]
----
#[starknet::contract]
pub mod ERC721VotesContract {
    use openzeppelin_governance::votes::VotesComponent;
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_token::erc721::ERC721Component;
    use openzeppelin_utils::cryptography::nonces::NoncesComponent;
    use openzeppelin_utils::cryptography::snip12::SNIP12Metadata;
    use starknet::ContractAddress;

    component!(path: VotesComponent, storage: erc721_votes, event: ERC721VotesEvent);
    component!(path: ERC721Component, storage: erc721, event: ERC721Event);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);
    component!(path: NoncesComponent, storage: nonces, event: NoncesEvent);

    // Votes
    #[abi(embed_v0)]
    impl VotesImpl = VotesComponent::VotesImpl<ContractState>;
    impl VotesInternalImpl = VotesComponent::InternalImpl<ContractState>;

    // ERC721
    #[abi(embed_v0)]
    impl ERC721MixinImpl = ERC721Component::ERC721MixinImpl<ContractState>;
    impl ERC721InternalImpl = ERC721Component::InternalImpl<ContractState>;

    // Nonces
    #[abi(embed_v0)]
    impl NoncesImpl = NoncesComponent::NoncesImpl<ContractState>;

    #[storage]
    pub struct Storage {
        #[substorage(v0)]
        pub erc721_votes: VotesComponent::Storage,
        #[substorage(v0)]
        pub erc721: ERC721Component::Storage,
        #[substorage(v0)]
        pub src5: SRC5Component::Storage,
        #[substorage(v0)]
        pub nonces: NoncesComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC721VotesEvent: VotesComponent::Event,
        #[flat]
        ERC721Event: ERC721Component::Event,
        #[flat]
        SRC5Event: SRC5Component::Event,
        #[flat]
        NoncesEvent: NoncesComponent::Event
    }

    /// Required for hash computation.
    pub impl SNIP12MetadataImpl of SNIP12Metadata {
        fn name() -> felt252 {
            'DAPP_NAME'
        }
        fn version() -> felt252 {
            'DAPP_VERSION'
        }
    }

    // We need to call the `transfer_voting_units` function after 
    // every mint, burn and transfer.
    // For this, we use the `before_update` hook of the
    //`ERC721Component::ERC721HooksTrait`.
    // This hook is called before the transfer is executed.
    // This  gives us access to the previous owner.
    impl ERC721VotesHooksImpl of ERC721Component::ERC721HooksTrait<ContractState> {
        fn before_update(
            ref self: ERC721Component::ComponentState<ContractState>,
            to: ContractAddress,
            token_id: u256,
            auth: ContractAddress
        ) {
            let mut contract_state = self.get_contract_mut();

            // We use the internal function here since it does not check if the token
            // id exists which is necessary for mints
            let previous_owner = self._owner_of(token_id);
            contract_state.erc721_votes.transfer_voting_units(previous_owner, to, 1);
        }
    }

    #[constructor]
    fn constructor(ref self: ContractState) {
        self.erc721.initializer("MyToken", "MTK", "");
    }
}
----

== Interface

This is the full interface of the `VotesImpl` implementation:
[source,cairo]
----
#[starknet::interface]
pub trait VotesABI<TState> {
    // IVotes
    fn get_votes(self: @TState, account: ContractAddress) -> u256;
    fn get_past_votes(self: @TState, account: ContractAddress, timepoint: u64) -> u256;
    fn get_past_total_supply(self: @TState, timepoint: u64) -> u256;
    fn delegates(self: @TState, account: ContractAddress) -> ContractAddress;
    fn delegate(ref self: TState, delegatee: ContractAddress);
    fn delegate_by_sig(ref self: TState, delegator: ContractAddress, delegatee: ContractAddress, nonce: felt252, expiry: u64, signature: Span<felt252>);

    // INonces
    fn nonces(self: @TState, owner: ContractAddress) -> felt252;
}
----
// llmstxt-short-description: API of the Governance module, including the Governor component, interface and extensions

:github-icon: pass:[<svg class="icon"><use href="#github-icon"/></svg>]
:IAccessControl-RoleGranted: xref:api/access.adoc#IAccessControl-RoleGranted[IAccessControl::RoleGranted]
:VotesComponent-DelegateChanged: xref:VotesComponent-DelegateChanged[DelegateChanged]
:VotesComponent-DelegateVotesChanged: xref:VotesComponent-DelegateVotesChanged[DelegateVotesChanged]
:VotingUnitsTrait: xref:VotingUnitsTrait[VotingUnitsTrait]
:VotesComponent: xref:VotesComponent[VotesComponent]
:IVotes: xref:IVotes[IVotes]
:governor: xref:governance/governor.adoc[Governor]
:inner-src5: xref:api/introspection.adoc#ISRC5[SRC5 ID]
:GovernorComponent: xref:#GovernorComponent[GovernorComponent]
:TimelockControllerComponent: xref:#TimelockControllerComponent[TimelockControllerComponent]
:ERC-6372: https://eips.ethereum.org/EIPS/eip-6372[ERC-6372]
:SNIP-12: https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md[SNIP-12]

= Governance

include::../utils/_common.adoc[]

This crate includes primitives for on-chain governance.

== Governor

This modular system of Governor components allows the deployment of easily customizable on-chain voting protocols.

TIP: For a walkthrough of how to implement a Governor, check the {governor} page.

[.contract]
[[IGovernor]]
=== `++IGovernor++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/governance/src/governor/interface.cairo[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_governance::governor::interface::IGovernor;
```

Interface of a governor contract.

[.contract-index]
.{inner-src5}
--
0x1100a1f8546595b5bd75a6cd8fcc5b015370655e66f275963321c5cd0357ac9
--

[.contract-index]
.Functions
--
* xref:#IGovernor-name[`++name()++`]
* xref:#IGovernor-version[`++version()++`]
* xref:#IGovernor-COUNTING_MODE[`++COUNTING_MODE()++`]
* xref:#IGovernor-hash_proposal[`++hash_proposal(calls, description_hash)++`]
* xref:#IGovernor-state[`++state(proposal_id)++`]
* xref:#IGovernor-proposal_threshold[`++proposal_threshold()++`]
* xref:#IGovernor-proposal_snapshot[`++proposal_snapshot(proposal_id)++`]
* xref:#IGovernor-proposal_deadline[`++proposal_deadline(proposal_id)++`]
* xref:#IGovernor-proposal_proposer[`++proposal_proposer(proposal_id)++`]
* xref:#IGovernor-proposal_eta[`++proposal_eta(proposal_id)++`]
* xref:#IGovernor-proposal_needs_queuing[`++proposal_needs_queuing(proposal_id)++`]
* xref:#IGovernor-voting_delay[`++voting_delay()++`]
* xref:#IGovernor-voting_period[`++voting_period()++`]
* xref:#IGovernor-quorum[`++quorum(timepoint)++`]
* xref:#IGovernor-get_votes[`++get_votes(account, timepoint)++`]
* xref:#IGovernor-get_votes_with_params[`++get_votes_with_params(account, timepoint, params)++`]
* xref:#IGovernor-has_voted[`++has_voted(proposal_id, account)++`]
* xref:#IGovernor-propose[`++propose(calls, description)++`]
* xref:#IGovernor-queue[`++queue(calls, description_hash)++`]
* xref:#IGovernor-execute[`++execute(calls, description_hash)++`]
* xref:#IGovernor-cancel[`++cancel(proposal_id, description_hash)++`]
* xref:#IGovernor-cast_vote[`++cast_vote(proposal_id, support)++`]
* xref:#IGovernor-cast_vote_with_reason[`++cast_vote_with_reason(proposal_id, support, reason)++`]
* xref:#IGovernor-cast_vote_with_reason_and_params[`++cast_vote_with_reason_and_params(proposal_id, support, reason, params)++`]
* xref:#IGovernor-cast_vote_by_sig[`++cast_vote_by_sig(proposal_id, support, reason, signature)++`]
* xref:#IGovernor-cast_vote_with_reason_and_params_by_sig[`++cast_vote_with_reason_and_params_by_sig(proposal_id, support, reason, params, signature)++`]
* xref:#IGovernor-nonces[`++nonces(voter)++`]
* xref:#IGovernor-relay[`++relay(call)++`]
--

[.contract-index]
.Events
--
* xref:#IGovernor-ProposalCreated[`++ProposalCreated(proposal_id, proposer, calls, signatures, vote_start, vote_end, description)++`]
* xref:#IGovernor-ProposalQueued[`++ProposalQueued(proposal_id, eta_seconds)++`]
* xref:#IGovernor-ProposalExecuted[`++ProposalExecuted(proposal_id)++`]
* xref:#IGovernor-ProposalCanceled[`++ProposalCanceled(proposal_id)++`]
* xref:#IGovernor-VoteCast[`++VoteCast(voter, proposal_id, support, weight, reason)++`]
* xref:#IGovernor-VoteCastWithParams[`++VoteCastWithParams(voter, proposal_id, support, weight, reason, params)++`]
--

[#IGovernor-Functions]
==== Functions

[.contract-item]
[[IGovernor-name]]
==== `[.contract-item-name]#++name++#++() → felt252++` [.item-kind]#external#

Name of the governor instance (used in building the {SNIP-12} domain separator).

[.contract-item]
[[IGovernor-version]]
==== `[.contract-item-name]#++version++#++() → felt252++` [.item-kind]#external#

Version of the governor instance (used in building {SNIP-12} domain separator).

[.contract-item]
[[IGovernor-COUNTING_MODE]]
==== `[.contract-item-name]#++COUNTING_MODE++#++() → ByteArray++` [.item-kind]#external#

A description of the possible `support` values for `cast_vote` and the way these votes are counted, meant to be consumed by UIs
to show correct vote options and interpret the results. The string is a URL-encoded sequence of key-value pairs
that each describe one aspect, for example `support=bravo&quorum=for,abstain`.

There are 2 standard keys: `support` and `quorum`.

- `support=bravo` refers to the vote options 0 = Against, 1 = For, 2 = Abstain, as in
`GovernorBravo`.
- `quorum=bravo` means that only For votes are counted towards quorum.
- `quorum=for,abstain` means that both For and Abstain votes are counted towards quorum.

If a counting module makes use of encoded `params`, it should  include this under a `params`
key with a unique name that describes the behavior. For example:

- `params=fractional` might refer to a scheme where votes are divided fractionally between
for/against/abstain.
- `params=erc721` might refer to a scheme where specific NFTs are delegated to vote.

NOTE: The string can be decoded by the standard https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams[`URLSearchParams`]
JavaScript class.

[.contract-item]
[[IGovernor-hash_proposal]]
==== `[.contract-item-name]#++hash_proposal++#++(calls: Span<Call>, description_hash: felt252) → felt252++` [.item-kind]#external#

Hashing function used to (re)build the proposal id from the proposal details.

[.contract-item]
[[IGovernor-state]]
==== `[.contract-item-name]#++state++#++(proposal_id: felt252) → ProposalState++` [.item-kind]#external#

Returns the state of a proposal, given its id.

[.contract-item]
[[IGovernor-proposal_threshold]]
==== `[.contract-item-name]#++proposal_threshold++#++() → u256++` [.item-kind]#external#

The number of votes required in order for a voter to become a proposer.

[.contract-item]
[[IGovernor-proposal_snapshot]]
==== `[.contract-item-name]#++proposal_snapshot++#++(proposal_id: felt252) → u64++` [.item-kind]#external#

Timepoint used to retrieve user's votes and quorum. If using block number, the snapshot is performed at the
end of this block. Hence, voting for this proposal starts at the beginning of the following block.

[.contract-item]
[[IGovernor-proposal_deadline]]
==== `[.contract-item-name]#++proposal_deadline++#++(proposal_id: felt252) → u64++` [.item-kind]#external#

Timepoint at which votes close. If using block number, votes close at the end of this block, so
it is possible to cast a vote during this block.

[.contract-item]
[[IGovernor-proposal_proposer]]
==== `[.contract-item-name]#++proposal_proposer++#++(proposal_id: felt252) → ContractAddress++` [.item-kind]#external#

The account that created a proposal.

[.contract-item]
[[IGovernor-proposal_eta]]
==== `[.contract-item-name]#++proposal_eta++#++(proposal_id: felt252) → u64++` [.item-kind]#external#

The time when a queued proposal becomes executable ("ETA"). Unlike `proposal_snapshot` and
`proposal_deadline`, this doesn't use the governor clock, and instead relies on the
executor's clock which may be different. In most cases this will be a timestamp.

[.contract-item]
[[IGovernor-proposal_needs_queuing]]
==== `[.contract-item-name]#++proposal_needs_queuing++#++(proposal_id: felt252) → bool++` [.item-kind]#external#

Whether a proposal needs to be queued before execution. This indicates if the proposal needs to go through a timelock.

[.contract-item]
[[IGovernor-voting_delay]]
==== `[.contract-item-name]#++voting_delay++#++() → u64++` [.item-kind]#external#

Delay between when a proposal is created and when the vote starts. The unit this duration is expressed in
depends on the clock (see {ERC-6372}) this contract uses.

This can be increased to leave time for users to buy voting power, or delegate it, before the voting of a proposal starts.

[.contract-item]
[[IGovernor-voting_period]]
==== `[.contract-item-name]#++voting_period++#++() → u64++` [.item-kind]#external#

Delay between when a vote starts and when it ends. The unit this duration is expressed in depends on
the clock (see {ERC-6372}) this contract uses.

NOTE: The `voting_delay` can delay the start of the vote. This must be considered when
setting the voting duration compared to the voting delay.

NOTE: This value is stored when the proposal is submitted so that possible changes to the
value do not affect proposals that have already been submitted.

[.contract-item]
[[IGovernor-quorum]]
==== `[.contract-item-name]#++quorum++#++(timepoint: u64) → u256++` [.item-kind]#external#

Minimum number of votes required for a proposal to be successful.

NOTE: The `timepoint` parameter corresponds to the snapshot used for counting vote. This
allows the quorum to scale depending on values such as the total supply of a token at this
timepoint.

[.contract-item]
[[IGovernor-get_votes]]
==== `[.contract-item-name]#++get_votes++#++(account: ContractAddress, timepoint: u64) → u256++` [.item-kind]#external#

Returns the voting power of an `account` at a specific `timepoint`.

NOTE: This can be implemented in a number of ways, for example by reading the delegated
balance from one (or multiple) `ERC20Votes` tokens.

[.contract-item]
[[IGovernor-get_votes_with_params]]
==== `[.contract-item-name]#++get_votes_with_params++#++(account: ContractAddress, timepoint: u64, params: Span<felt252>) → u256++` [.item-kind]#external#

Returns the voting power of an `account` at a specific `timepoint`, given additional encoded parameters.

[.contract-item]
[[IGovernor-has_voted]]
==== `[.contract-item-name]#++has_voted++#++(proposal_id: felt252, account: ContractAddress) → bool++` [.item-kind]#external#

Returns whether an `account` has cast a vote on a proposal.

[.contract-item]
[[IGovernor-propose]]
==== `[.contract-item-name]#++propose++#++(calls: Span<Call>, description: ByteArray) → felt252++` [.item-kind]#external#

Creates a new proposal. Vote starts after a delay specified by `voting_delay` and lasts for a duration specified by `voting_period`.

NOTE: The state of the Governor and targets may change between the proposal creation and its execution.
This may be the result of third party actions on the targeted contracts, or other governor proposals.
For example, the balance of this contract could be updated or its access control permissions may be
modified, possibly compromising the proposal's ability to execute successfully (e.g. the governor
doesn't have enough value to cover a proposal with multiple transfers).

Returns the id of the proposal.

[.contract-item]
[[IGovernor-queue]]
==== `[.contract-item-name]#++queue++#++(calls: Span<Call>, description_hash: felt252) → felt252++` [.item-kind]#external#

Queue a proposal. Some governors require this step to be performed before execution can
happen. If queuing is not necessary, this function may revert.

Queuing a proposal requires the quorum to be reached, the vote to be successful, and the
deadline to be reached.

Returns the id of the proposal.

[.contract-item]
[[IGovernor-execute]]
==== `[.contract-item-name]#++execute++#++(calls: span<Call>, description_hash: felt252) → felt252++` [.item-kind]#external#

Execute a successful proposal. This requires the quorum to be reached, the vote to be
successful, and the deadline to be reached. Depending on the governor it might also be
required that the proposal was queued and that some delay passed.

NOTE: Some modules can modify the requirements for execution, for example by adding an
additional timelock (See `timelock_controller`).

Returns the id of the proposal.

[.contract-item]
[[IGovernor-cancel]]
==== `[.contract-item-name]#++cancel++#++(calls: Span<Call>, description_hash: felt252) → felt252++` [.item-kind]#external#

Cancel a proposal. A proposal is cancellable by the proposer, but only while it is Pending
state, i.e. before the vote starts.

Returns the id of the proposal.

[.contract-item]
[[IGovernor-cast_vote]]
==== `[.contract-item-name]#++cast_vote++#++(proposal_id: felt252, support: u8) → u256++` [.item-kind]#external#

Cast a vote on a proposal.

Returns the weight of the vote.

[.contract-item]
[[IGovernor-cast_vote_with_reason]]
==== `[.contract-item-name]#++cast_vote_with_reason++#++(proposal_id: felt252, support: u8, reason: ByteArray) → u256++` [.item-kind]#external#

Cast a vote on a proposal with a `reason`.

Returns the weight of the vote.

[.contract-item]
[[IGovernor-cast_vote_with_reason_and_params]]
==== `[.contract-item-name]#++cast_vote_with_reason_and_params++#++(proposal_id: felt252, support: u8, reason: ByteArray, params: Span<felt252>) → u256++` [.item-kind]#external#

Cast a vote on a proposal with a reason and additional encoded parameters.

Returns the weight of the vote.

[.contract-item]
[[IGovernor-cast_vote_by_sig]]
==== `[.contract-item-name]#++cast_vote_by_sig++#++(proposal_id: felt252, support: u8, voter: ContractAddress, signature: Span<felt252>) → u256++` [.item-kind]#external#

Cast a vote on a proposal using the voter's signature.

Returns the weight of the vote.

[.contract-item]
[[IGovernor-cast_vote_with_reason_and_params_by_sig]]
==== `[.contract-item-name]#++cast_vote_with_reason_and_params_by_sig++#++(proposal_id: felt252, support: u8, voter: ContractAddress, reason: ByteArray, params: Span<felt252>, signature: Span<felt252>) → u256++` [.item-kind]#external#

Cast a vote on a proposal with a reason and additional encoded parameters using the ``voter``'s signature.

Returns the weight of the vote.

[.contract-item]
[[IGovernor-nonces]]
==== `[.contract-item-name]#++nonces++#++(voter: ContractAddress) → felt252++` [.item-kind]#external#

Returns the next unused nonce for an address.

[.contract-item]
[[IGovernor-relay]]
==== `[.contract-item-name]#++relay++#++(call: Call)++` [.item-kind]#external#

Relays a transaction or function call to an arbitrary target.

In cases where the governance executor is some contract other than the governor itself, like
when using a timelock, this function can be invoked in a governance proposal to recover
tokens that were sent to the governor contract by mistake.

NOTE: If the executor is simply the governor itself, use of `relay` is redundant.

[#IGovernor-Events]
==== Events

[.contract-item]
[[IGovernor-ProposalCreated]]
==== `[.contract-item-name]#++ProposalCreated++#++(proposal_id: felt252, proposer: ContractAddress, calls: Span<Call>, signatures: Span<Span<felt252>>, vote_start: u64, vote_end: u64, description: ByteArray)++` [.item-kind]#event#

Emitted when a proposal is created.

[.contract-item]
[[IGovernor-ProposalQueued]]
==== `[.contract-item-name]#++ProposalQueued++#++(proposal_id: felt252, eta_seconds: u64)++` [.item-kind]#event#

Emitted when a proposal is queued.

[.contract-item]
[[IGovernor-ProposalExecuted]]
==== `[.contract-item-name]#++ProposalExecuted++#++(proposal_id: felt252)++` [.item-kind]#event#

Emitted when a proposal is executed.

[.contract-item]
[[IGovernor-ProposalCanceled]]
==== `[.contract-item-name]#++ProposalCanceled++#++(proposal_id: felt252)++` [.item-kind]#event#

Emitted when a proposal is canceled.

[.contract-item]
[[IGovernor-VoteCast]]
==== `[.contract-item-name]#++VoteCast++#++(voter: ContractAddress, proposal_id: felt252, support: u8, weight: u256, reason: ByteArray)++` [.item-kind]#event#

Emitted when a vote is cast.

[.contract-item]
[[IGovernor-VoteCastWithParams]]
==== `[.contract-item-name]#++VoteCastWithParams++#++(voter: ContractAddress, proposal_id: felt252, support: u8, weight: u256, reason: ByteArray, params: Span<felt252>)++` [.item-kind]#event#

Emitted when a vote is cast with params.

:ProposalCreated: xref:GovernorComponent-ProposalCreated[ProposalCreated]
:ProposalExecuted: xref:GovernorComponent-ProposalExecuted[ProposalExecuted]
:ProposalQueued: xref:GovernorComponent-ProposalQueued[ProposalQueued]
:ProposalCanceled: xref:GovernorComponent-ProposalCanceled[ProposalCanceled]
:VoteCast: xref:GovernorComponent-VoteCast[VoteCast]
:VoteCastWithParams: xref:GovernorComponent-VoteCastWithParams[VoteCastWithParams]
:component-extensions: xref:#governor_extensions[component extensions]

[.contract]
[[GovernorComponent]]
=== `++GovernorComponent++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/governance/src/governor/governor.cairo[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_governance::governor::GovernorComponent;
```

Core of the governance system.

NOTE: The extension traits presented below are what make the GovernorComponent a modular and configurable system. The embeddable
and internal implementations depends on these trait. They can be implemented locally in the contract, or through the provided library
{component-extensions}.

NOTE: {src5-component-required-note}

[.contract-index#GovernorComponent-Extensions-Traits-Traits]
.Extensions traits
--
[.sub-index#GovernorComponent-Extensions-Traits-GovernorSettingsTrait]
.GovernorSettingsTrait

* xref:#GovernorComponent-GovernorSettingsTrait-voting_delay[`++voting_delay(self)++`]
* xref:#GovernorComponent-GovernorSettingsTrait-voting_period[`++voting_period(self)++`]
* xref:#GovernorComponent-GovernorSettingsTrait-proposal_threshold[`++proposal_threshold(self)++`]

[.sub-index#GovernorComponent-Extensions-Traits-GovernorQuorumTrait]
.GovernorQuorumTrait

* xref:#GovernorComponent-GovernorQuorumTrait-quorum[`++quorum(self, timepoint)++`]

[.sub-index#GovernorComponent-Extensions-Traits-GovernorCountingTrait]
.GovernorCountingTrait

* xref:#GovernorComponent-GovernorCountingTrait-counting_mode[`++counting_mode(self)++`]
* xref:#GovernorComponent-GovernorCountingTrait-count_vote[`++count_vote(self, proposal_id, account, support, total_weight, params)++`]
* xref:#GovernorComponent-GovernorCountingTrait-has_voted[`++has_voted(self, proposal_id, account)++`]
* xref:#GovernorComponent-GovernorCountingTrait-quorum_reached[`++quorum_reached(self, proposal_id)++`]
* xref:#GovernorComponent-GovernorCountingTrait-vote_succeeded[`++vote_succeeded(self, proposal_id)++`]

[.sub-index#GovernorComponent-Extensions-Traits-GovernorVotesTrait]
.GovernorVotesTrait

* xref:#GovernorComponent-GovernorVotesTrait-clock[`++clock(self)++`]
* xref:#GovernorComponent-GovernorVotesTrait-clock_mode[`++clock_mode(self)++`]
* xref:#GovernorComponent-GovernorVotesTrait-get_votes[`++get_votes(self, account, timepoint, params)++`]

[.sub-index#GovernorComponent-Extensions-Traits-GovernorExecutionTrait]
.GovernorExecutionTrait

* xref:#GovernorComponent-GovernorExecutionTrait-state[`++state(self, proposal_id)++`]
* xref:#GovernorComponent-GovernorExecutionTrait-executor[`++executor(self)++`]
* xref:#GovernorComponent-GovernorExecutionTrait-execute_operations[`++execute_operations(self, proposal_id, calls, description_hash)++`]
* xref:#GovernorComponent-GovernorExecutionTrait-queue_operations[`++queue_operations(self, proposal_id, calls, description_hash)++`]
* xref:#GovernorComponent-GovernorExecutionTrait-proposal_needs_queuing[`++proposal_needs_queuing(self, proposal_id)++`]
* xref:#GovernorComponent-GovernorExecutionTrait-cancel_operations[`++cancel_operations(self, proposal_id, description_hash)++`]
--

[.contract-index#GovernorComponent-Embeddable-Impls]
.Embeddable Implementations
--
[.sub-index#GovernorComponent-Embeddable-Impls-GovernorImpl]
.GovernorImpl

* xref:#GovernorComponent-name[`++name(self)++`]
* xref:#GovernorComponent-version[`++version(self)++`]
* xref:#GovernorComponent-COUNTING_MODE[`++COUNTING_MODE(self)++`]
* xref:#GovernorComponent-hash_proposal[`++hash_proposal(self, calls, description_hash)++`]
* xref:#GovernorComponent-state[`++state(self, proposal_id)++`]
* xref:#GovernorComponent-proposal_threshold[`++proposal_threshold(self)++`]
* xref:#GovernorComponent-proposal_snapshot[`++proposal_snapshot(self, proposal_id)++`]
* xref:#GovernorComponent-proposal_deadline[`++proposal_deadline(self, proposal_id)++`]
* xref:#GovernorComponent-proposal_proposer[`++proposal_proposer(self, proposal_id)++`]
* xref:#GovernorComponent-proposal_eta[`++proposal_eta(self, proposal_id)++`]
* xref:#GovernorComponent-proposal_needs_queuing[`++proposal_needs_queuing(self, proposal_id)++`]
* xref:#GovernorComponent-voting_delay[`++voting_delay(self)++`]
* xref:#GovernorComponent-voting_period[`++voting_period(self)++`]
* xref:#GovernorComponent-quorum[`++quorum(self, timepoint)++`]
* xref:#GovernorComponent-get_votes[`++get_votes(self, account, timepoint)++`]
* xref:#GovernorComponent-get_votes_with_params[`++get_votes_with_params(self, account, timepoint, params)++`]
* xref:#GovernorComponent-has_voted[`++has_voted(self, proposal_id, account)++`]
* xref:#GovernorComponent-propose[`++propose(self, calls, description)++`]
* xref:#GovernorComponent-queue[`++queue(self, calls, description_hash)++`]
* xref:#GovernorComponent-execute[`++execute(self, calls, description_hash)++`]
* xref:#GovernorComponent-cancel[`++cancel(self, proposal_id, description_hash)++`]
* xref:#GovernorComponent-cast_vote[`++cast_vote(self, proposal_id, support)++`]
* xref:#GovernorComponent-cast_vote_with_reason[`++cast_vote_with_reason(self, proposal_id, support, reason)++`]
* xref:#GovernorComponent-cast_vote_with_reason_and_params[`++cast_vote_with_reason_and_params(self, proposal_id, support, reason, params)++`]
* xref:#GovernorComponent-cast_vote_by_sig[`++cast_vote_by_sig(self, proposal_id, support, reason, signature)++`]
* xref:#GovernorComponent-cast_vote_with_reason_and_params_by_sig[`++cast_vote_with_reason_and_params_by_sig(self, proposal_id, support, reason, params, signature)++`]
* xref:#GovernorComponent-nonces[`++nonces(self, voter)++`]
* xref:#GovernorComponent-relay[`++relay(self, call)++`]
--

[.contract-index]
.Internal Implementations
--
.InternalImpl

* xref:#GovernorComponent-initializer[`++initializer(self)++`]
* xref:#GovernorComponent-get_proposal[`++get_proposal(self, proposal_id)++`]
* xref:#GovernorComponent-is_valid_description_for_proposer[`++is_valid_description_for_proposer(self, proposer, description)++`]
* xref:#GovernorComponent-_hash_proposal[`++_hash_proposal(self, calls, description_hash)++`]
* xref:#GovernorComponent-_proposal_snapshot[`++_proposal_snapshot(self, proposal_id)++`]
* xref:#GovernorComponent-_proposal_deadline[`++_proposal_deadline(self, proposal_id)++`]
* xref:#GovernorComponent-_proposal_proposer[`++_proposal_proposer(self, proposal_id)++`]
* xref:#GovernorComponent-_proposal_eta[`++_proposal_eta(self, proposal_id)++`]

.InternalExtendedImpl

* xref:#GovernorComponent-assert_only_governance[`++assert_only_governance(self)++`]
* xref:#GovernorComponent-validate_state[`++validate_state(self, proposal_id, allowed_states)++`]
* xref:#GovernorComponent-use_nonce[`++use_nonce(self, voter)++`]
* xref:#GovernorComponent-_get_votes[`++_get_votes(self, account, timepoint, params)++`]
* xref:#GovernorComponent-_proposal_threshold[`++_proposal_threshold(self)++`]
* xref:#GovernorComponent-_state[`++_state(self, proposal_id)++`]
* xref:#GovernorComponent-_propose[`++_propose(self, calls, description, proposer)++`]
* xref:#GovernorComponent-_cancel[`++_cancel(self, proposal_id, description_hash)++`]
* xref:#GovernorComponent-_count_vote[`++_count_vote(self, proposal_id, account, support, total_weight, params)++`]
* xref:#GovernorComponent-_cast_vote[`++_cast_vote(self, proposal_id, voter, support, reason, params)++`]
--

[.contract-index]
.Events
--
* xref:#GovernorComponent-ProposalCreated[`++ProposalCreated(proposal_id, proposer, calls, signatures, vote_start, vote_end, description)++`]
* xref:#GovernorComponent-ProposalQueued[`++ProposalQueued(proposal_id)++`]
* xref:#GovernorComponent-ProposalExecuted[`++ProposalExecuted(proposal_id)++`]
* xref:#GovernorComponent-ProposalCanceled[`++ProposalCanceled(proposal_id)++`]
* xref:#GovernorComponent-VoteCast[`++VoteCast(voter, proposal_id, support, weight, reason)++`]
* xref:#GovernorComponent-VoteCastWithParams[`++VoteCastWithParams(voter, proposal_id, support, weight, reason, params)++`]
--

[#GovernorComponent-Extensions-Traits]
==== Extensions traits functions

[.contract-item]
[[GovernorComponent-GovernorSettingsTrait-voting_delay]]
==== `[.contract-item-name]#++voting_delay++#++(self: @ContractState) → u64++` [.item-kind]#extension#

Must return the delay, in number of timepoints, between when the proposal is created and when the vote starts. This can be
increased to leave time for users to buy voting power, or delegate it, before the voting of a
proposal starts.

[.contract-item]
[[GovernorComponent-GovernorSettingsTrait-voting_period]]
==== `[.contract-item-name]#++voting_period++#++(self: @ContractState) → u64++` [.item-kind]#extension#

Must return the delay, in number of timepoints, between the vote start and vote end.

[.contract-item]
[[GovernorComponent-GovernorSettingsTrait-proposal_threshold]]
==== `[.contract-item-name]#++proposal_threshold++#++(self: @ContractState) → u256++` [.item-kind]#extension#

Must return the minimum number of votes that an account must have to create a proposal.

[.contract-item]
[[GovernorComponent-GovernorQuorumTrait-quorum]]
==== `[.contract-item-name]#++quorum++#++(self: @ContractState, timepoint: u64) → u256++` [.item-kind]#extension#

Must return the minimum number of votes required for a proposal to succeed.

[.contract-item]
[[GovernorComponent-GovernorCountingTrait-counting_mode]]
==== `[.contract-item-name]#++counting_mode++#++(self: @ContractState) → ByteArray++` [.item-kind]#extension#

Must return a description of the possible `support` values for `cast_vote` and the way these votes are counted,
meant to be consumed by UIs to show correct vote options and interpret the results.
See <<GovernorComponent-COUNTING_MODE, COUNTING_MODE>> for more details.

[.contract-item]
[[GovernorComponent-GovernorCountingTrait-count_vote]]
==== `[.contract-item-name]#++count_vote++#++(ref self: ContractState, proposal_id: felt252, account: ContractAddress, support: u8, total_weight: u256, params: Span<felt252>) → u256++` [.item-kind]#extension#

Must register a vote for `proposal_id` by `account` with a given `support`, voting `weight` and voting `params`.

NOTE: Support is generic and can represent various things depending on the voting system used.

[.contract-item]
[[GovernorComponent-GovernorCountingTrait-has_voted]]
==== `[.contract-item-name]#++has_voted++#++(self: @ContractState, proposal_id: felt252, account: ContractAddress) → bool++` [.item-kind]#extension#

Must return whether an account has cast a vote on a proposal.

[.contract-item]
[[GovernorComponent-GovernorCountingTrait-quorum_reached]]
==== `[.contract-item-name]#++quorum_reached++#++(self: @ContractState, proposal_id: felt252) → bool++` [.item-kind]#extension#

Must return whether the minimum quorum has been reached for a proposal.

[.contract-item]
[[GovernorComponent-GovernorCountingTrait-vote_succeeded]]
==== `[.contract-item-name]#++vote_succeeded++#++(self: @ContractState, proposal_id: felt252) → bool++` [.item-kind]#extension#

Must return whether a proposal has succeeded or not.

[.contract-item]
[[GovernorComponent-GovernorVotesTrait-clock]]
==== `[.contract-item-name]#++clock++#++(self: @ContractState) → u64++` [.item-kind]#extension#

Must return the current timepoint according to the clock mode the governor is operating in.

NOTE: For now, only timestamp is supported.

[.contract-item]
[[GovernorComponent-GovernorVotesTrait-clock_mode]]
==== `[.contract-item-name]#++clock_mode++#++(self: @ContractState) → ByteArray++` [.item-kind]#extension#

Must return the clock mode the governor is operating in.

NOTE: For now, only timestamp is supported.

[.contract-item]
[[GovernorComponent-GovernorVotesTrait-get_votes]]
==== `[.contract-item-name]#++get_votes++#++(self: @ContractState, account: ContractAddress, timepoint: u64, params: Span<felt252>) → u256++` [.item-kind]#extension#

Must return the voting power of an account at a specific timepoint with the given parameters.

[.contract-item]
[[GovernorComponent-GovernorExecutionTrait-state]]
==== `[.contract-item-name]#++state++#++(self: @ContractState, proposal_id: felt252) → ProposalState++` [.item-kind]#extension#

Must return the state of a proposal at the current time.

The state can be either:

- `Pending`: The proposal does not exist yet.
- `Active`: The proposal is active.
- `Canceled`: The proposal has been canceled.
- `Defeated`: The proposal has been defeated.
- `Succeeded`: The proposal has succeeded.
- `Queued`: The proposal has been queued.
- `Executed`: The proposal has been executed.

[.contract-item]
[[GovernorComponent-GovernorExecutionTrait-executor]]
==== `[.contract-item-name]#++executor++#++(self: @ContractState) → ContractAddress++` [.item-kind]#internal#

Must return the address through which the governor executes action.
Should be used to specify whether the module execute actions through another contract
such as a timelock.

NOTE: MUST be the governor itself, or an instance of TimelockController with the
governor as the only proposer, canceller, and executor.

WARNING: When the executor is not the governor itself (i.e. a timelock), it can call
functions that are restricted with the `assert_only_governance` guard, and also
potentially execute transactions on behalf of the governor. Because of this, this module
is designed to work with the TimelockController as the unique potential external
executor.

[.contract-item]
[[GovernorComponent-GovernorExecutionTrait-execute_operations]]
==== `[.contract-item-name]#++execute_operations++#++(ref self: ContractState, proposal_id: felt252, calls: Span<Call>)++` [.item-kind]#internal#

Execution mechanism. Can be used to modify the way operations are executed (for example adding a vault/timelock).

[.contract-item]
[[GovernorComponent-GovernorExecutionTrait-queue_operations]]
==== `[.contract-item-name]#++queue_operations++#++(ref self: ContractState, proposal_id: felt252, calls: Span<Call>)++` [.item-kind]#internal#

Queuing mechanism. Can be used to modify the way queuing is
performed (for example adding a vault/timelock).

Requirements:

- Must return a timestamp that describes the expected ETA for execution. If the returned
value is 0, the core will consider queueing did not succeed, and the public `queue`
function will revert.

[.contract-item]
[[GovernorComponent-GovernorExecutionTrait-proposal_needs_queuing]]
==== `[.contract-item-name]#++proposal_needs_queuing++#++(self: @ContractState) → bool++` [.item-kind]#internal#

Must return whether proposals need to be queued before execution. This usually indicates if the proposal needs to go through a timelock.

[.contract-item]
[[GovernorComponent-GovernorExecutionTrait-cancel_operations]]
==== `[.contract-item-name]#++cancel_operations++#++(ref self: ContractState, proposal_id: felt252, calls: Span<Call>)++` [.item-kind]#internal#

Cancel mechanism. Can be used to modify the way canceling is
performed (for example adding a vault/timelock).

[#GovernorComponent-Embeddable-Functions]
==== Embeddable functions

[.contract-item]
[[GovernorComponent-name]]
==== `[.contract-item-name]#++name++#++() → felt252++` [.item-kind]#external#

Name of the governor instance (used in building the {SNIP-12} domain separator).

[.contract-item]
[[GovernorComponent-version]]
==== `[.contract-item-name]#++version++#++() → felt252++` [.item-kind]#external#

Version of the governor instance (used in building {SNIP-12} domain separator).

[.contract-item]
[[GovernorComponent-COUNTING_MODE]]
==== `[.contract-item-name]#++COUNTING_MODE++#++() → ByteArray++` [.item-kind]#external#

A description of the possible `support` values for `cast_vote` and the way these votes are counted, meant to be consumed by UIs
to show correct vote options and interpret the results. The string is a URL-encoded sequence of key-value pairs
that each describe one aspect, for example `support=bravo&quorum=for,abstain`.

There are 2 standard keys: `support` and `quorum`.

- `support=bravo` refers to the vote options 0 = Against, 1 = For, 2 = Abstain, as in
`GovernorBravo`.
- `quorum=bravo` means that only For votes are counted towards quorum.
- `quorum=for,abstain` means that both For and Abstain votes are counted towards quorum.

If a counting module makes use of encoded `params`, it should  include this under a `params`
key with a unique name that describes the behavior. For example:

- `params=fractional` might refer to a scheme where votes are divided fractionally between
for/against/abstain.
- `params=erc721` might refer to a scheme where specific NFTs are delegated to vote.

NOTE: The string can be decoded by the standard https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams[`URLSearchParams`]
JavaScript class.

[.contract-item]
[[GovernorComponent-hash_proposal]]
==== `[.contract-item-name]#++hash_proposal++#++(calls: Span<Call>, description_hash: felt252) → felt252++` [.item-kind]#external#

Hashing function used to (re)build the proposal id from the proposal details.

[.contract-item]
[[GovernorComponent-state]]
==== `[.contract-item-name]#++state++#++(proposal_id: felt252) → ProposalState++` [.item-kind]#external#

Returns the state of a proposal, given its id.

[.contract-item]
[[GovernorComponent-proposal_threshold]]
==== `[.contract-item-name]#++proposal_threshold++#++() → u256++` [.item-kind]#external#

The number of votes required in order for a voter to become a proposer.

[.contract-item]
[[GovernorComponent-proposal_snapshot]]
==== `[.contract-item-name]#++proposal_snapshot++#++(proposal_id: felt252) → u64++` [.item-kind]#external#

Timepoint used to retrieve user's votes and quorum. If using block number, the snapshot is performed at the
end of this block. Hence, voting for this proposal starts at the beginning of the following block.

[.contract-item]
[[GovernorComponent-proposal_deadline]]
==== `[.contract-item-name]#++proposal_deadline++#++(proposal_id: felt252) → u64++` [.item-kind]#external#

Timepoint at which votes close. If using block number, votes close at the end of this block, so
it is possible to cast a vote during this block.

[.contract-item]
[[GovernorComponent-proposal_proposer]]
==== `[.contract-item-name]#++proposal_proposer++#++(proposal_id: felt252) → ContractAddress++` [.item-kind]#external#

The account that created a proposal.

[.contract-item]
[[GovernorComponent-proposal_eta]]
==== `[.contract-item-name]#++proposal_eta++#++(proposal_id: felt252) → u64++` [.item-kind]#external#

The time when a queued proposal becomes executable ("ETA"). Unlike `proposal_snapshot` and
`proposal_deadline`, this doesn't use the governor clock, and instead relies on the
executor's clock which may be different. In most cases this will be a timestamp.

[.contract-item]
[[GovernorComponent-proposal_needs_queuing]]
==== `[.contract-item-name]#++proposal_needs_queuing++#++(proposal_id: felt252) → bool++` [.item-kind]#external#

Whether a proposal needs to be queued before execution. This indicates if the proposal needs to go through a timelock.

[.contract-item]
[[GovernorComponent-voting_delay]]
==== `[.contract-item-name]#++voting_delay++#++() → u64++` [.item-kind]#external#

Delay between when a proposal is created and when the vote starts. The unit this duration is expressed in
depends on the clock (see {ERC-6372}) this contract uses.

This can be increased to leave time for users to buy voting power, or delegate it, before the voting of a proposal starts.

[.contract-item]
[[GovernorComponent-voting_period]]
==== `[.contract-item-name]#++voting_period++#++() → u64++` [.item-kind]#external#

Delay between the vote start and vote end. The unit this duration is expressed in depends on
the clock (see {ERC-6372}) this contract uses.

NOTE: The `voting_delay` can delay the start of the vote. This must be considered when
setting the voting duration compared to the voting delay.

NOTE: This value is stored when the proposal is submitted so that possible changes to the
value do not affect proposals that have already been submitted.

[.contract-item]
[[GovernorComponent-quorum]]
==== `[.contract-item-name]#++quorum++#++(timepoint: u64) → u256++` [.item-kind]#external#

Minimum number of votes required for a proposal to be successful.

NOTE: The `timepoint` parameter corresponds to the snapshot used for counting vote. This
allows the quorum to scale depending on values such as the total supply of a token at this
timepoint.

[.contract-item]
[[GovernorComponent-get_votes]]
==== `[.contract-item-name]#++get_votes++#++(account: ContractAddress, timepoint: u64) → u256++` [.item-kind]#external#

Returns the voting power of an `account` at a specific `timepoint`.

NOTE: This can be implemented in a number of ways, for example by reading the delegated
balance from one (or multiple) `ERC20Votes` tokens.

[.contract-item]
[[GovernorComponent-get_votes_with_params]]
==== `[.contract-item-name]#++get_votes_with_params++#++(account: ContractAddress, timepoint: u64, params: Span<felt252>) → u256++` [.item-kind]#external#

Returns the voting power of an account at a specific timepoint, given additional encoded parameters.

[.contract-item]
[[GovernorComponent-has_voted]]
==== `[.contract-item-name]#++has_voted++#++(proposal_id: felt252, account: ContractAddress) → bool++` [.item-kind]#external#

Returns whether an account has cast a vote on a proposal.

[.contract-item]
[[GovernorComponent-propose]]
==== `[.contract-item-name]#++propose++#++(calls: Span<Call>, description: ByteArray) → felt252++` [.item-kind]#external#

Creates a new proposal. Voting starts after the delay specified by `voting_delay` and
lasts for a duration specified by `voting_period`. Returns the id of the proposal.

This function has opt-in frontrunning protection, described in
`is_valid_description_for_proposer`.

NOTE: The state of the Governor and targets may change between the proposal creation
and its execution. This may be the result of third party actions on the targeted
contracts, or other governor proposals. For example, the balance of this contract could
be updated or its access control permissions may be modified, possibly compromising the
proposal's ability to execute successfully (e.g. the governor doesn't have enough value
to cover a proposal with multiple transfers).

Requirements:

- The proposer must be authorized to submit the proposal.
- The proposer must have enough votes to submit the proposal if `proposal_threshold` is
greater than zero.
- The proposal must not already exist.

Emits a {ProposalCreated} event.

[.contract-item]
[[GovernorComponent-queue]]
==== `[.contract-item-name]#++queue++#++(calls: Span<Call>, description_hash: felt252) → felt252++` [.item-kind]#external#

Queues a proposal. Some governors require this step to be performed before execution can
happen. If queuing is not necessary, this function may revert.
Queuing a proposal requires the quorum to be reached, the vote to be successful, and the
deadline to be reached.

Returns the id of the proposal.

Requirements:

- The proposal must be in the `Succeeded` state.
- The queue operation must return a non-zero ETA.

Emits a {ProposalQueued} event.

[.contract-item]
[[GovernorComponent-execute]]
==== `[.contract-item-name]#++execute++#++(calls: span<Call>, description_hash: felt252) → felt252++` [.item-kind]#external#

Executes a successful proposal. This requires the quorum to be reached, the vote to be
successful, and the deadline to be reached. Depending on the governor it might also be
required that the proposal was queued and that some delay passed.

NOTE: Some modules can modify the requirements for execution, for example by adding an
additional timelock (See `timelock_controller`).

Returns the id of the proposal.

Requirements:

- The proposal must be in the `Succeeded` or `Queued` state.

Emits a {ProposalExecuted} event.

[.contract-item]
[[GovernorComponent-cancel]]
==== `[.contract-item-name]#++cancel++#++(calls: Span<Call>, description_hash: felt252) → felt252++` [.item-kind]#external#

Cancels a proposal. A proposal is cancellable by the proposer, but only while it is
Pending state, i.e. before the vote starts.

Returns the id of the proposal.

Requirements:

- The proposal must be in the `Pending` state.
- The caller must be the proposer of the proposal.

Emits a {ProposalCanceled} event.

[.contract-item]
[[GovernorComponent-cast_vote]]
==== `[.contract-item-name]#++cast_vote++#++(proposal_id: felt252, support: u8) → u256++` [.item-kind]#external#

Cast a vote.

Requirements:

- The proposal must be active.

Emits a {VoteCast} event.

[.contract-item]
[[GovernorComponent-cast_vote_with_reason]]
==== `[.contract-item-name]#++cast_vote_with_reason++#++(proposal_id: felt252, support: u8, reason: ByteArray) → u256++` [.item-kind]#external#

Cast a vote with a `reason`.

Requirements:

- The proposal must be active.

Emits a {VoteCast} event.

[.contract-item]
[[GovernorComponent-cast_vote_with_reason_and_params]]
==== `[.contract-item-name]#++cast_vote_with_reason_and_params++#++(proposal_id: felt252, support: u8, reason: ByteArray, params: Span<felt252>) → u256++` [.item-kind]#external#

Cast a vote with a `reason` and additional serialized `params`.

Requirements:

- The proposal must be active.

Emits either:

- {VoteCast} event if no params are provided.
- {VoteCastWithParams} event otherwise.

[.contract-item]
[[GovernorComponent-cast_vote_by_sig]]
==== `[.contract-item-name]#++cast_vote_by_sig++#++(proposal_id: felt252, support: u8, voter: ContractAddress, signature: Span<felt252>) → u256++` [.item-kind]#external#

Cast a vote using the ``voter``'s signature.

Requirements:

- The proposal must be active.
- The nonce in the signed message must match the account's current nonce.
- `voter` must implement `SRC6::is_valid_signature`.
- `signature` must be valid for the message hash.

Emits a {VoteCast} event.

[.contract-item]
[[GovernorComponent-cast_vote_with_reason_and_params_by_sig]]
==== `[.contract-item-name]#++cast_vote_with_reason_and_params_by_sig++#++(proposal_id: felt252, support: u8, voter: ContractAddress, reason: ByteArray, params: Span<felt252>, signature: Span<felt252>) → u256++` [.item-kind]#external#

Cast a vote with a `reason` and additional serialized `params` using the ``voter``'s
signature.

Requirements:

- The proposal must be active.
- The nonce in the signed message must match the account's current nonce.
- `voter` must implement `SRC6::is_valid_signature`.
- `signature` must be valid for the message hash.

Emits either:

- {VoteCast} event if no params are provided.
- {VoteCastWithParams} event otherwise.

[.contract-item]
[[GovernorComponent-nonces]]
==== `[.contract-item-name]#++nonces++#++(voter: ContractAddress) → felt252++` [.item-kind]#external#

Returns the next unused nonce for an address.

[.contract-item]
[[GovernorComponent-relay]]
==== `[.contract-item-name]#++relay++#++(call: Call)++` [.item-kind]#external#

Relays a transaction or function call to an arbitrary target.

In cases where the governance executor is some contract other than the governor itself, like
when using a timelock, this function can be invoked in a governance proposal to recover
tokens that were sent to the governor contract by mistake.

NOTE: If the executor is simply the governor itself, use of `relay` is redundant.

[#GovernorComponent-Internal-Functions]
==== Internal functions

[.contract-item]
[[GovernorComponent-initializer]]
==== `[.contract-item-name]#++initializer++#++(ref self: ContractState)++` [.item-kind]#internal#

Initializes the contract by registering the supported interface id.

[.contract-item]
[[GovernorComponent-get_proposal]]
==== `[.contract-item-name]#++get_proposal++#++(self: @ContractState, proposal_id: felt252) → ProposalCore++` [.item-kind]#internal#

Returns the proposal object given its id.

[.contract-item]
[[GovernorComponent-is_valid_description_for_proposer]]
==== `[.contract-item-name]#++is_valid_description_for_proposer++#++(self: @ContractState, proposer: ContractAddress, description: ByteArray) → bool++` [.item-kind]#internal#

Checks if the proposer is authorized to submit a proposal with the given description.

If the proposal description ends with `#proposer=0x???`, where `0x???` is an address
written as a hex string (case insensitive), then the submission of this proposal will
only be authorized to said address.

This is used for frontrunning protection. By adding this pattern at the end of their
proposal, one can ensure that no other address can submit the same proposal. An attacker
would have to either remove or change that part, which would result in a different
proposal id.

NOTE: In Starknet, the Sequencer ensures the order of transactions, but frontrunning
can still be achieved by nodes, and potentially other actors in the future with
sequencer decentralization.

If the description does not match this pattern, it is unrestricted and anyone can submit
it. This includes:

- If the `0x???` part is not a valid hex string.
- If the `0x???` part is a valid hex string, but does not contain exactly 64 hex digits.
- If it ends with the expected suffix followed by newlines or other whitespace.
- If it ends with some other similar suffix, e.g. `#other=abc`.
- If it does not end with any such suffix.

[.contract-item]
[[GovernorComponent-_hash_proposal]]
==== `[.contract-item-name]#++_hash_proposal++#++(self: @ContractState, calls: Span<Call>, description_hash: felt252) → felt252++` [.item-kind]#internal#

Returns the proposal id computed from the given parameters.

The proposal id is computed as a Pedersen hash of:

- The array of calls being proposed
- The description hash

[.contract-item]
[[GovernorComponent-_proposal_snapshot]]
==== `[.contract-item-name]#++_proposal_snapshot++#++(self: @ContractState, proposal_id: felt252) → u64++` [.item-kind]#internal#

Timepoint used to retrieve user's votes and quorum. If using block number, the snapshot
is performed at the end of this block. Hence, voting for this proposal starts at the
beginning of the following block.

[.contract-item]
[[GovernorComponent-_proposal_deadline]]
==== `[.contract-item-name]#++_proposal_deadline++#++(self: @ContractState, proposal_id: felt252) → u64++` [.item-kind]#internal#

Timepoint at which votes close. If using block number, votes close at the end of this
block, so it is possible to cast a vote during this block.

[.contract-item]
[[GovernorComponent-_proposal_proposer]]
==== `[.contract-item-name]#++_proposal_proposer++#++(self: @ContractState, proposal_id: felt252) → ContractAddress++` [.item-kind]#internal#

The account that created a proposal.

[.contract-item]
[[GovernorComponent-_proposal_eta]]
==== `[.contract-item-name]#++_proposal_eta++#++(self: @ContractState, proposal_id: felt252) → u64++` [.item-kind]#internal#

The time when a queued proposal becomes executable ("ETA"). Unlike `proposal_snapshot`
and `proposal_deadline`, this doesn't use the governor clock, and instead relies on the
executor's clock which may be different. In most cases this will be a timestamp.

[.contract-item]
[[GovernorComponent-assert_only_governance]]
==== `[.contract-item-name]#++assert_only_governance++#++(self: @ContractState)++` [.item-kind]#internal#

Asserts that the caller is the governance executor.

WARNING: When the executor is not the governor itself (i.e. a timelock), it can call
functions that are restricted with this modifier, and also potentially execute
transactions on behalf of the governor. Because of this, this module is designed to work
with the TimelockController as the unique potential external executor. The timelock
MUST have the governor as the only proposer, canceller, and executor.

[.contract-item]
[[GovernorComponent-validate_state]]
==== `[.contract-item-name]#++validate_state++#++(self: @ContractState, proposal_id: felt252, state: ProposalState)++` [.item-kind]#internal#

Validates that a proposal is in the expected state. Otherwise it panics.

[.contract-item]
[[GovernorComponent-use_nonce]]
==== `[.contract-item-name]#++use_nonce++#++(ref self: ContractState) → felt252++` [.item-kind]#internal#

Consumes a nonce, returns the current value, and increments nonce.

[.contract-item]
[[GovernorComponent-_get_votes]]
==== `[.contract-item-name]#++_get_votes++#++(self: @ContractState, account: ContractAddress, timepoint: u64, params: Span<felt252>) → u256++` [.item-kind]#internal#

Internal wrapper for `GovernorVotesTrait::get_votes`.

[.contract-item]
[[GovernorComponent-_proposal_threshold]]
==== `[.contract-item-name]#++_proposal_threshold++#++(self: @ContractState) → u256++` [.item-kind]#internal#

Internal wrapper for `GovernorProposeTrait::proposal_threshold`.

[.contract-item]
[[GovernorComponent-_state]]
==== `[.contract-item-name]#++_state++#++(self: @ContractState, proposal_id: felt252) → ProposalState++` [.item-kind]#internal#

Returns the state of a proposal, given its id.

Requirements:

- The proposal must exist.

[.contract-item]
[[GovernorComponent-_propose]]
==== `[.contract-item-name]#++_propose++#++(ref self: ContractState, calls: Span<Call>, description_hash: felt252) → felt252++` [.item-kind]#internal#

Internal propose mechanism. Returns the proposal id.

Requirements:

- The proposal must not already exist.

Emits a {ProposalCreated} event.

[.contract-item]
[[GovernorComponent-_cancel]]
==== `[.contract-item-name]#++_cancel++#++(ref self: ContractState, proposal_id: felt252)++` [.item-kind]#internal#

Internal cancel mechanism with minimal restrictions.

A proposal can be cancelled in any state other than Canceled or Executed.

NOTE: Once cancelled, a proposal can't be re-submitted.

[.contract-item]
[[GovernorComponent-_count_vote]]
==== `[.contract-item-name]#++_count_vote++#++(ref self: ContractState, proposal_id: felt252, account: ContractAddress, support: u8, weight: u256, params: Span<felt252>)++` [.item-kind]#internal#

Internal wrapper for `GovernorCountingTrait::count_vote`.

[.contract-item]
[[GovernorComponent-_cast_vote]]
==== `[.contract-item-name]#++_cast_vote++#++(ref self: ContractState, proposal_id: felt252, account: ContractAddress, support: u8, reason: ByteArray, params: Span<felt252>) → u256++` [.item-kind]#internal#

Internal vote-casting mechanism.

Checks that the vote is pending and that it has not been cast yet.
This function retrieves the voting weight using `get_votes` and then calls
the `_count_vote` internal function.

Emits either:

- {VoteCast} event if no params are provided.
- {VoteCastWithParams} event otherwise.

[#GovernorComponent-Events]
==== Events

[.contract-item]
[[GovernorComponent-ProposalCreated]]
==== `[.contract-item-name]#++ProposalCreated++#++(proposal_id: felt252, proposer: ContractAddress, calls: Span<Call>, signatures: Span<Span<felt252>>, vote_start: u64, vote_end: u64, description: ByteArray)++` [.item-kind]#event#

Emitted when a proposal is created.

[.contract-item]
[[GovernorComponent-ProposalQueued]]
==== `[.contract-item-name]#++ProposalQueued++#++(proposal_id: felt252, eta_seconds: u64)++` [.item-kind]#event#

Emitted when a proposal is queued.

[.contract-item]
[[GovernorComponent-ProposalExecuted]]
==== `[.contract-item-name]#++ProposalExecuted++#++(proposal_id: felt252)++` [.item-kind]#event#

Emitted when a proposal is executed.

[.contract-item]
[[GovernorComponent-ProposalCanceled]]
==== `[.contract-item-name]#++ProposalCanceled++#++(proposal_id: felt252)++` [.item-kind]#event#

Emitted when a proposal is canceled.

[.contract-item]
[[GovernorComponent-VoteCast]]
==== `[.contract-item-name]#++VoteCast++#++(voter: ContractAddress, proposal_id: felt252, support: u8, weight: u256, reason: ByteArray)++` [.item-kind]#event#

Emitted when a vote is cast.

[.contract-item]
[[GovernorComponent-VoteCastWithParams]]
==== `[.contract-item-name]#++VoteCastWithParams++#++(voter: ContractAddress, proposal_id: felt252, support: u8, weight: u256, reason: ByteArray, params: Span<felt252>)++` [.item-kind]#event#

Emitted when a vote is cast with params.

== Governor extensions

:extension-traits: xref:#GovernorComponent-Extensions-Traits-Traits[extensions traits]

The Governor component can (and must) be extended by implementing the {extension-traits} to add the desired functionality.
This can be achieved by directly implementing the traits on your contract, or by using a set of ready-to-use extensions
provided by the library, which are presented below.

[.contract]
[[GovernorCoreExecutionComponent]]
=== `++GovernorCoreExecutionComponent++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/governance/src/governor/extensions/governor_core_execution.cairo[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_governance::governor::extensions::GovernorCoreExecutionComponent;
```

Extension of {GovernorComponent} providing an execution mechanism directly through
the Governor itself. For a timelocked execution mechanism, see
xref:#GovernorTimelockExecutionComponent[GovernorTimelockExecutionComponent].

[.contract-index]
.Extension traits implementations
--
.GovernorExecution

* xref:#GovernorCoreExecutionComponent-state[`++state(self, proposal_id)++`]
* xref:#GovernorCoreExecutionComponent-executor[`++executor(self)++`]
* xref:#GovernorCoreExecutionComponent-execute_operations[`++execute_operations(self, proposal_id, calls, description_hash)++`]
* xref:#GovernorCoreExecutionComponent-queue_operations[`++queue_operations(self, proposal_id, calls, description_hash)++`]
* xref:#GovernorCoreExecutionComponent-proposal_needs_queuing[`++proposal_needs_queuing(self, proposal_id)++`]
* xref:#GovernorCoreExecutionComponent-cancel_operations[`++cancel_operations(self, proposal_id, description_hash)++`]
--

[#GovernorCoreExecutionComponent-Extension-Traits-Functions]
==== Extension traits functions

[.contract-item]
[[GovernorCoreExecutionComponent-state]]
==== `[.contract-item-name]#++state++#++(self: @ContractState, proposal_id: felt252) → ProposalState++` [.item-kind]#internal#

Returns the state of a proposal given its id.

Requirements:

- The proposal must exist.

[.contract-item]
[[GovernorCoreExecutionComponent-executor]]
==== `[.contract-item-name]#++executor++#++(self: @ContractState) → ContractAddress++` [.item-kind]#internal#

Returns the executor address.

In this case, it returns the governor contract address since execution is performed directly through it.

[.contract-item]
[[GovernorCoreExecutionComponent-execute_operations]]
==== `[.contract-item-name]#++execute_operations++#++(ref self: ContractState, proposal_id: felt252, calls: Span<Call>, description_hash: felt252)++` [.item-kind]#internal#

Executes the proposal's operations directly through the governor contract.

[.contract-item]
[[GovernorCoreExecutionComponent-queue_operations]]
==== `[.contract-item-name]#++queue_operations++#++(ref self: ContractState, proposal_id: felt252, calls: Span<Call>, description_hash: felt252) → u64++` [.item-kind]#internal#

In this implementation, queuing is not required so it returns 0.

[.contract-item]
[[GovernorCoreExecutionComponent-proposal_needs_queuing]]
==== `[.contract-item-name]#++proposal_needs_queuing++#++(self: @ContractState, proposal_id: felt252) → bool++` [.item-kind]#internal#

In this implementation, it always returns false.

[.contract-item]
[[GovernorCoreExecutionComponent-cancel_operations]]
==== `[.contract-item-name]#++cancel_operations++#++(ref self: ContractState, proposal_id: felt252, description_hash: felt252)++` [.item-kind]#internal#

Cancels a proposal's operations.

[.contract]
[[GovernorCountingSimpleComponent]]
=== `++GovernorCountingSimpleComponent++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/governance/src/governor/extensions/governor_counting_simple.cairo[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_governance::governor::extensions::GovernorCountingSimpleComponent;
```

Extension of {GovernorComponent} for simple vote counting with three options.

[.contract-index]
.Extension traits implementations
--
.GovernorCounting

* xref:#GovernorCountingSimpleComponent-counting_mode[`counting_mode(self)`]
* xref:#GovernorCountingSimpleComponent-count_vote[`count_vote(self, proposal_id, account, support, total_weight, params)`]
* xref:#GovernorCountingSimpleComponent-has_voted[`has_voted(self, proposal_id, account)`]
* xref:#GovernorCountingSimpleComponent-quorum_reached[`quorum_reached(self, proposal_id)`]
* xref:#GovernorCountingSimpleComponent-vote_succeeded[`vote_succeeded(self, proposal_id)`]
--

[#GovernorCountingSimpleComponent-Extension-Traits-Functions]
==== Extension traits functions

[.contract-item]
[[GovernorCountingSimpleComponent-counting_mode]]
==== `[.contract-item-name]#++counting_mode++#++(self: @ContractState) → ByteArray++` [.item-kind]#internal#

Returns `"support=bravo&quorum=for,abstain"`.

- `support=bravo` indicates that the support follows the Governor Bravo format where voters can vote For, Against, or Abstain
- `quorum=for,abstain` indicates that both For and Abstain votes count toward quorum

[.contract-item]
[[GovernorCountingSimpleComponent-count_vote]]
==== `[.contract-item-name]#++count_vote++#++(ref self: ContractState, proposal_id: felt252, account: ContractAddress, support: u8, total_weight: u256, params: Span<felt252>) → u256++` [.item-kind]#internal#

Records a vote for a proposal.

The support value follows the `VoteType` enum (0=Against, 1=For, 2=Abstain).

Returns the weight that was counted.

[.contract-item]
[[GovernorCountingSimpleComponent-has_voted]]
==== `[.contract-item-name]#++has_voted++#++(self: @ContractState, proposal_id: felt252, account: ContractAddress) → bool++` [.item-kind]#internal#

Returns whether an account has cast a vote on a proposal.

[.contract-item]
[[GovernorCountingSimpleComponent-quorum_reached]]
==== `[.contract-item-name]#++quorum_reached++#++(self: @ContractState, proposal_id: felt252) → bool++` [.item-kind]#internal#

Returns whether a proposal has reached quorum.

In this implementation, both For and Abstain votes count toward quorum.

[.contract-item]
[[GovernorCountingSimpleComponent-vote_succeeded]]
==== `[.contract-item-name]#++vote_succeeded++#++(self: @ContractState, proposal_id: felt252) → bool++` [.item-kind]#internal#

Returns whether a proposal has succeeded.

In this implementation, the For votes must be strictly greater than Against votes.

[.contract]
[[GovernorSettingsComponent]]
=== `++GovernorSettingsComponent++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/governance/src/governor/extensions/governor_settings.cairo[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_governance::governor::extensions::GovernorSettingsComponent;
```

Extension of {GovernorComponent} for settings that are updatable through governance.

[.contract-index]
.Extension traits implementations
--
.GovernorSettings

* xref:#GovernorSettingsComponent-voting_delay[`++voting_delay(self)++`]
* xref:#GovernorSettingsComponent-voting_period[`++voting_period(self)++`]
* xref:#GovernorSettingsComponent-proposal_threshold[`++proposal_threshold(self)++`]
--

[.contract-index]
.Embeddable implementations
--
.GovernorSettingsAdminImpl

* xref:#GovernorSettingsComponent-set_voting_delay[`++set_voting_delay(self, new_voting_delay)++`]
* xref:#GovernorSettingsComponent-set_voting_period[`++set_voting_period(self, new_voting_period)++`]
* xref:#GovernorSettingsComponent-set_proposal_threshold[`++set_proposal_threshold(self, new_proposal_threshold)++`]
--

[.contract-index]
.Internal implementations
--
.InternalImpl

* xref:#GovernorSettingsComponent-initializer[`++initializer(self, new_voting_delay, new_voting_period, new_proposal_threshold)++`]
* xref:#GovernorSettingsComponent-assert_only_governance[`++assert_only_governance(self)++`]
* xref:#GovernorSettingsComponent-_set_voting_delay[`++_set_voting_delay(self, new_voting_delay)++`]
* xref:#GovernorSettingsComponent-_set_voting_period[`++_set_voting_period(self, new_voting_period)++`]
* xref:#GovernorSettingsComponent-_set_proposal_threshold[`++_set_proposal_threshold(self, new_proposal_threshold)++`]
--

[.contract-index]
.Events
--
* xref:#GovernorSettingsComponent-VotingDelayUpdated[`++VotingDelayUpdated(old_voting_delay, new_voting_delay)++`]
* xref:#GovernorSettingsComponent-VotingPeriodUpdated[`++VotingPeriodUpdated(old_voting_period, new_voting_period)++`]
* xref:#GovernorSettingsComponent-ProposalThresholdUpdated[`++ProposalThresholdUpdated(old_proposal_threshold, new_proposal_threshold)++`]
--

[#GovernorSettings-Extension-Traits-Functions]
==== Extension traits functions

[.contract-item]
[[GovernorSettingsComponent-voting_delay]]
==== `[.contract-item-name]#++voting_delay++#++(self: @ContractState) → u64++` [.item-kind]#internal#

Returns the delay, between when a proposal is created and when voting starts.

[.contract-item]
[[GovernorSettingsComponent-voting_period]]
==== `[.contract-item-name]#++voting_period++#++(self: @ContractState) → u64++` [.item-kind]#internal#

Returns the time period, during which votes can be cast.

[.contract-item]
[[GovernorSettingsComponent-proposal_threshold]]
==== `[.contract-item-name]#++proposal_threshold++#++(self: @ContractState) → u256++` [.item-kind]#internal#

Returns the minimum number of votes required for an account to create a proposal.

[#GovernorSettings-Embeddable-Functions]
==== Embeddable functions

:VotingDelayUpdated: xref:#GovernorSettingsComponent-VotingDelayUpdated[VotingDelayUpdated]
:VotingPeriodUpdated: xref:#GovernorSettingsComponent-VotingPeriodUpdated[VotingPeriodUpdated]
:ProposalThresholdUpdated: xref:#GovernorSettingsComponent-ProposalThresholdUpdated[ProposalThresholdUpdated]

[.contract-item]
[[GovernorSettingsComponent-set_voting_delay]]
==== `[.contract-item-name]#++set_voting_delay++#++(ref self: ContractState, new_voting_delay: u64)++` [.item-kind]#external#

Sets the voting delay.

Requirements:

- Caller must be the governance executor.

NOTE: This function does not emit an event if the new voting delay is the same as the old one.

May emit a {VotingDelayUpdated} event.

[.contract-item]
[[GovernorSettingsComponent-set_voting_period]]
==== `[.contract-item-name]#++set_voting_period++#++(ref self: ContractState, new_voting_period: u64)++` [.item-kind]#external#

Sets the voting period.

NOTE: This function does not emit an event if the new voting period is the same as the
old one.

Requirements:

- Caller must be the governance executor.
- `new_voting_period` must be greater than 0.

May emit a {VotingPeriodUpdated} event.

[.contract-item]
[[GovernorSettingsComponent-set_proposal_threshold]]
==== `[.contract-item-name]#++set_proposal_threshold++#++(ref self: ContractState, new_proposal_threshold: u256)++` [.item-kind]#external#

Sets the proposal threshold.

NOTE: This function does not emit an event if the new proposal threshold is the same as
the old one.

Requirements:

- Caller must be the governance executor.

May emit a {ProposalThresholdUpdated} event.

[#GovernorSettingsComponent-Internal-Functions]
==== Internal functions

[.contract-item]
[[GovernorSettingsComponent-initializer]]
==== `[.contract-item-name]#++initializer++#++(ref self: ContractState, initial_voting_delay: u64, initial_voting_period: u64, initial_proposal_threshold: u256)++` [.item-kind]#internal#

Initializes the component by setting the default values.

Requirements:

- `new_voting_period` must be greater than 0.

Emits a {VotingDelayUpdated}, {VotingPeriodUpdated}, and {ProposalThresholdUpdated} event.

[.contract-item]
[[GovernorSettingsComponent-assert_only_governance]]
==== `[.contract-item-name]#++assert_only_governance++#++(ref self: ContractState)++` [.item-kind]#internal#

Asserts that the caller is the governance executor.

[.contract-item]
[[GovernorSettingsComponent-_set_voting_delay]]
==== `[.contract-item-name]#++_set_voting_delay++#++(ref self: ContractState, new_voting_delay: u64)++` [.item-kind]#internal#

Internal function to update the voting delay.

NOTE: This function does not emit an event if the new voting delay is the same as the
old one.

May emit a {VotingDelayUpdated} event.

[.contract-item]
[[GovernorSettingsComponent-_set_voting_period]]
==== `[.contract-item-name]#++_set_voting_period++#++(ref self: ContractState, new_voting_period: u64)++` [.item-kind]#internal#

Internal function to update the voting period.

Requirements:

- `new_voting_period` must be greater than 0.

NOTE: This function does not emit an event if the new voting period is the same as the old one.

May emit a {VotingPeriodUpdated} event.

[.contract-item]
[[GovernorSettingsComponent-_set_proposal_threshold]]
==== `[.contract-item-name]#++_set_proposal_threshold++#++(ref self: ContractState, new_proposal_threshold: u256)++` [.item-kind]#internal#

Internal function to update the proposal threshold.

NOTE: This function does not emit an event if the new proposal threshold is the same as the old one.

May emit a {ProposalThresholdUpdated} event.

[#GovernorSettings-Events]
==== Events

[.contract-item]
[[GovernorSettingsComponent-VotingDelayUpdated]]
==== `[.contract-item-name]#++VotingDelayUpdated++#++(old_voting_delay: u64, new_voting_delay: u64)++` [.item-kind]#event#

Emitted when the voting delay is updated.

[.contract-item]
[[GovernorSettingsComponent-VotingPeriodUpdated]]
==== `[.contract-item-name]#++VotingPeriodUpdated++#++(old_voting_period: u64, new_voting_period: u64)++` [.item-kind]#event#

Emitted when the voting period is updated.

[.contract-item]
[[GovernorSettingsComponent-ProposalThresholdUpdated]]
==== `[.contract-item-name]#++ProposalThresholdUpdated++#++(old_proposal_threshold: u256, new_proposal_threshold: u256)++` [.item-kind]#event#

Emitted when the proposal threshold is updated.

[.contract]
[[GovernorVotesComponent]]
=== `++GovernorVotesComponent++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/governance/src/governor/extensions/governor_votes.cairo[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_governance::governor::extensions::GovernorVotesComponent;
```

Extension of {GovernorComponent} for voting weight extraction from a token with the {IVotes}
extension.

[.contract-index]
.Extension traits implementations
--
.GovernorVotes

* xref:#GovernorVotesComponent-clock[`++clock(self)++`]
* xref:#GovernorVotesComponent-clock_mode[`++clock_mode(self)++`]
* xref:#GovernorVotesComponent-get_votes[`++get_votes(self, account, timepoint, params)++`]
--

[.contract-index]
.Embeddable implementations
--
.VotesTokenImpl

* xref:#GovernorVotesComponent-token[`++token(self)++`]
--

[.contract-index]
.Internal implementations
--
.InternalImpl

* xref:#GovernorVotesComponent-initializer[`++initializer(self, votes_token)++`]
--

[#GovernorVotes-Extension-Traits-Functions]
==== Extension traits functions

[.contract-item]
[[GovernorVotesComponent-clock]]
==== `[.contract-item-name]#++clock++#++(self: @ContractState) → u64++` [.item-kind]#internal#

Returns the current timepoint according to the time mode the contract is operating in.

In this implementation, returns the current block timestamp.

NOTE: {VotesComponent} always uses the block timestamp for tracking checkpoints.
This must be updated in order to allow for more flexible clock modes.

[.contract-item]
[[GovernorVotesComponent-clock_mode]]
==== `[.contract-item-name]#++clock_mode++#++(self: @ContractState) → ByteArray++` [.item-kind]#internal#

Returns `"mode=timestamp&from=starknet::SN_MAIN"`.

See https://eips.ethereum.org/EIPS/eip-6372#clock_mode

[.contract-item]
[[GovernorVotesComponent-get_votes]]
==== `[.contract-item-name]#++get_votes++#++(self: @ContractState, account: ContractAddress, timepoint: u64, params: Span<felt252>) → u256++` [.item-kind]#internal#

Returns the voting power of `account` at a specific `timepoint` using the votes token.

[[GovernorVotesComponent-Embeddable-Functions]]
==== Embeddable functions

[.contract-item]
[[GovernorVotesComponent-token]]
==== `[.contract-item-name]#++token++#++(self: @ContractState) → ContractAddress++` [.item-kind]#external#

Returns the votes token that voting power is sourced from.

[#GovernorVotesComponent-Internal-Functions]
==== Internal functions

[.contract-item]
[[GovernorVotesComponent-initializer]]
==== `[.contract-item-name]#++initializer++#++(ref self: ContractState, votes_token: ContractAddress)++` [.item-kind]#internal#

Initializes the component by setting the votes token.

Requirements:

- `votes_token` must not be zero.

:QuorumNumeratorUpdated: xref:#GovernorVotesQuorumFractionComponent-QuorumNumeratorUpdated[QuorumNumeratorUpdated]

[.contract]
[[GovernorVotesQuorumFractionComponent]]
=== `++GovernorVotesQuorumFractionComponent++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/governance/src/governor/extensions/governor_votes_quorum_fraction.cairo[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_governance::governor::extensions::GovernorVotesQuorumFractionComponent;
```

Extension of {GovernorComponent} for voting weight extraction from a token with the
{IVotes} extension and a quorum expressed as a fraction of the total supply.

[.contract-index]
.Extension traits implementations
--
.GovernorQuorum

* xref:#GovernorVotesQuorumFractionComponent-quorum[`++quorum(self, timepoint)++`]

.GovernorVotes

* xref:#GovernorVotesQuorumFractionComponent-clock[`++clock(self)++`]
* xref:#GovernorVotesQuorumFractionComponent-clock_mode[`++clock_mode(self)++`]
* xref:#GovernorVotesQuorumFractionComponent-get_votes[`++get_votes(self, account, timepoint, params)++`]
--

[.contract-index]
.Embeddable implementations
--
.QuorumFractionImpl

* xref:#GovernorVotesQuorumFractionComponent-token[`++token(self)++`]
* xref:#GovernorVotesQuorumFractionComponent-current_quorum_numerator[`++current_quorum_numerator(self)++`]
* xref:#GovernorVotesQuorumFractionComponent-quorum_numerator[`++quorum_numerator(self, timepoint)++`]
* xref:#GovernorVotesQuorumFractionComponent-quorum_denominator[`++quorum_denominator(self)++`]
--

[.contract-index]
.Internal implementations
--
.InternalImpl

* xref:#GovernorVotesQuorumFractionComponent-initializer[`++initializer(self, votes_token, quorum_numerator)++`]
* xref:#GovernorVotesQuorumFractionComponent-update_quorum_numerator[`++update_quorum_numerator(self, new_quorum_numerator)++`]
--

[.contract-index]
.Events
--
* xref:#GovernorVotesQuorumFractionComponent-QuorumNumeratorUpdated[`++QuorumNumeratorUpdated(old_quorum_numerator, new_quorum_numerator)++`]
--

[#GovernorVotesQuorumFractionComponent-Extension-Traits-Functions]
==== Extension traits functions

[.contract-item]
[[GovernorVotesQuorumFractionComponent-quorum]]
==== `[.contract-item-name]#++quorum++#++(self: @ContractState, timepoint: u64) → u256++` [.item-kind]#internal#

It is computed as a percentage of the votes token total supply at a given `timepoint` in the past.

[.contract-item]
[[GovernorVotesQuorumFractionComponent-clock]]
==== `[.contract-item-name]#++clock++#++(self: @ContractState) → u64++` [.item-kind]#internal#

Returns the current timepoint according to the time mode the contract is operating in.

In this implementation, returns the current block timestamp.

[.contract-item]
[[GovernorVotesQuorumFractionComponent-clock_mode]]
==== `[.contract-item-name]#++clock_mode++#++(self: @ContractState) → ByteArray++` [.item-kind]#internal#

Returns `"mode=timestamp&from=starknet::SN_MAIN"`.

See https://eips.ethereum.org/EIPS/eip-6372#clock_mode

[.contract-item]
[[GovernorVotesQuorumFractionComponent-get_votes]]
==== `[.contract-item-name]#++get_votes++#++(self: @ContractState, account: ContractAddress, timepoint: u64, params: Span<felt252>) → u256++` [.item-kind]#internal#

Returns the voting power of `account` at a specific `timepoint` using the votes token.

[#GovernorVotesQuorumFractionComponent-Embeddable-Functions]
==== Embeddable functions

[.contract-item]
[[GovernorVotesQuorumFractionComponent-token]]
==== `[.contract-item-name]#++token++#++(self: @ContractState) → ContractAddress++` [.item-kind]#external#

Returns the address of the votes token used for voting power extraction.

[.contract-item]
[[GovernorVotesQuorumFractionComponent-current_quorum_numerator]]
==== `[.contract-item-name]#++current_quorum_numerator++#++(self: @ContractState) → u256++` [.item-kind]#external#

Returns the current quorum numerator value.

[.contract-item]
[[GovernorVotesQuorumFractionComponent-quorum_numerator]]
==== `[.contract-item-name]#++quorum_numerator++#++(self: @ContractState, timepoint: u64) → u256++` [.item-kind]#external#

Returns the quorum numerator value at a specific `timepoint` in the past.

[.contract-item]
[[GovernorVotesQuorumFractionComponent-quorum_denominator]]
==== `[.contract-item-name]#++quorum_denominator++#++(self: @ContractState) → u256++` [.item-kind]#external#

Returns the quorum denominator value.

[#GovernorVotesQuorumFractionComponent-Internal-Functions]
==== Internal functions

[.contract-item]
[[GovernorVotesQuorumFractionComponent-initializer]]
==== `[.contract-item-name]#++initializer++#++(self: @ComponentState<TContractState>, votes_token: ContractAddress, quorum_numerator: u256)++` [.item-kind]#internal#

Initializes the component by setting the votes token and the initial quorum numerator value.

Requirements:

* `votes_token` must not be zero.
* `quorum_numerator` must be less than `quorum_denominator`.

Emits a {QuorumNumeratorUpdated} event.

[.contract-item]
[[GovernorVotesQuorumFractionComponent-update_quorum_numerator]]
==== `[.contract-item-name]#++update_quorum_numerator++#++(self: @ComponentState<TContractState>, new_quorum_numerator: u256)++` [.item-kind]#internal#

Updates the quorum numerator.

NOTE: This function does not emit an event if the new quorum numerator is the same as the old one.

Requirements:

* `new_quorum_numerator` must be less than `quorum_denominator`.

May emit a {QuorumNumeratorUpdated} event.

[#GovernorVotesQuorumFractionComponent-Events]
==== Events

[.contract-item]
[[GovernorVotesQuorumFractionComponent-QuorumNumeratorUpdated]]
==== `[.contract-item-name]#++QuorumNumeratorUpdated++#++(old_quorum_numerator: u256, new_quorum_numerator: u256)++` [.item-kind]#event#

Emitted when the quorum numerator is updated.

:roles: xref:governance/timelock.adoc#roles

[.contract]
[[GovernorTimelockExecutionComponent]]
=== `++GovernorTimelockExecutionComponent++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/governance/src/governor/extensions/governor_timelock_execution.cairo[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_governance::governor::extensions::GovernorTimelockExecutionComponent;
```

Extension of {GovernorComponent} that binds the execution process to an instance of a contract
implementing {TimelockControllerComponent}. This adds a delay, enforced by the timelock
to all successful proposals (in addition to the voting duration).

NOTE: The Governor needs the {roles}[PROPOSER, EXECUTOR, and CANCELLER roles] to work properly.

Using this model means the proposal will be operated by the timelock and not by the
governor. Thus, the assets and permissions must be attached to the timelock. Any asset
sent to the governor will be inaccessible from a proposal, unless executed via
`Governor::relay`.

WARNING: Setting up the timelock to have additional proposers or cancellers besides
the governor is very risky, as it grants them the ability to: 1) execute operations as the
timelock, and thus possibly performing operations or accessing funds that are expected to only
be accessible through a vote, and 2) block governance proposals that have been approved by the
voters, effectively executing a Denial of Service attack.

[.contract-index]
.Extension traits implementations
--
.GovernorExecution

* xref:#GovernorTimelockExecutionComponent-state[`++state(self, proposal_id)++`]
* xref:#GovernorTimelockExecutionComponent-executor[`++executor(self)++`]
* xref:#GovernorTimelockExecutionComponent-execute_operations[`++execute_operations(self, proposal_id, calls, description_hash)++`]
* xref:#GovernorTimelockExecutionComponent-queue_operations[`++queue_operations(self, proposal_id, calls, description_hash)++`]
* xref:#GovernorTimelockExecutionComponent-proposal_needs_queuing[`++proposal_needs_queuing(self, proposal_id)++`]
* xref:#GovernorTimelockExecutionComponent-cancel_operations[`++cancel_operations(self, proposal_id, description_hash)++`]
--

[.contract-index]
.Embeddable implementations
--
.TimelockedImpl

* xref:#GovernorTimelockExecutionComponent-timelock[`++timelock(self)++`]
* xref:#GovernorTimelockExecutionComponent-get_timelock_id[`++get_timelock_id(self, proposal_id)++`]
* xref:#GovernorTimelockExecutionComponent-update_timelock[`++update_timelock(self, new_timelock)++`]
--

[.contract-index]
.Internal implementations
--
.InternalImpl

* xref:#GovernorTimelockExecutionComponent-initializer[`++initializer(self, timelock_controller)++`]
* xref:#GovernorTimelockExecutionComponent-assert_only_governance[`++assert_only_governance(self)++`]
* xref:#GovernorTimelockExecutionComponent-timelock_salt[`++timelock_salt(self, description_hash)++`]
* xref:#GovernorTimelockExecutionComponent-get_timelock_dispatcher[`++get_timelock_dispatcher(self)++`]
* xref:#GovernorTimelockExecutionComponent-_update_timelock[`++_update_timelock(self, new_timelock)++`]

--

[.contract-index]
.Events
--
* xref:#GovernorTimelockExecutionComponent-TimelockUpdated[`++TimelockUpdated(old_timelock, new_timelock)++`]
--

[#GovernorTimelockExecutionComponent-Extension-Traits-Functions]
==== Extension traits functions

[.contract-item]
[[GovernorTimelockExecutionComponent-state]]
==== `[.contract-item-name]#++state++#++(self: @ContractState, proposal_id: felt252) → ProposalState++` [.item-kind]#internal#

Returns the state of a proposal given its id.

Requirements:

- The proposal must exist.

[.contract-item]
[[GovernorTimelockExecutionComponent-executor]]
==== `[.contract-item-name]#++executor++#++(self: @ContractState) → ContractAddress++` [.item-kind]#internal#

Returns the executor address.

In this module, the executor is the timelock controller.

[.contract-item]
[[GovernorTimelockExecutionComponent-execute_operations]]
==== `[.contract-item-name]#++execute_operations++#++(ref self: ContractState, proposal_id: felt252, calls: Span<Call>, description_hash: felt252)++` [.item-kind]#internal#

Runs the already queued proposal through the timelock.

[.contract-item]
[[GovernorTimelockExecutionComponent-queue_operations]]
==== `[.contract-item-name]#++queue_operations++#++(ref self: ContractState, proposal_id: felt252, calls: Span<Call>, description_hash: felt252) → u64++` [.item-kind]#internal#

Queue a proposal to the timelock.

Returns the eta for the execution of the queued proposal.

[.contract-item]
[[GovernorTimelockExecutionComponent-proposal_needs_queuing]]
==== `[.contract-item-name]#++proposal_needs_queuing++#++(self: @ContractState, proposal_id: felt252) → bool++` [.item-kind]#internal#

In this implementation, it always returns true.

[.contract-item]
[[GovernorTimelockExecutionComponent-cancel_operations]]
==== `[.contract-item-name]#++cancel_operations++#++(ref self: ContractState, proposal_id: felt252, description_hash: felt252)++` [.item-kind]#internal#

Cancels the timelocked proposal if it has already been queued.

[#GovernorTimelockExecutionComponent-Embeddable-Functions]
==== Embeddable functions

:TimelockUpdated: xref:#GovernorTimelockExecutionComponent-TimelockUpdated[TimelockUpdated]

[.contract-item]
[[GovernorTimelockExecutionComponent-timelock]]
==== `[.contract-item-name]#++timelock++#++(self: @ContractState) → ContractAddress++` [.item-kind]#external#

Returns the timelock controller address.

[.contract-item]
[[GovernorTimelockExecutionComponent-get_timelock_id]]
==== `[.contract-item-name]#++get_timelock_id++#++(self: @ContractState) → felt252++` [.item-kind]#external#

Returns the timelock proposal id for a given proposal id.

[.contract-item]
[[GovernorTimelockExecutionComponent-update_timelock]]
==== `[.contract-item-name]#++update_timelock++#++(ref self: ContractState, new_timelock: ContractAddress)++` [.item-kind]#external#

Updates the associated timelock.

Requirements:

- The caller must be the governance.

Emits a {TimelockUpdated} event.

[#GovernorTimelockExecutionComponent-Internal-Functions]
==== Internal functions

[.contract-item]
[[GovernorTimelockExecutionComponent-initializer]]
==== `[.contract-item-name]#++initializer++#++(ref self: ContractState, timelock: ContractAddress)++` [.item-kind]#internal#

Initializes the timelock controller.

Requirements:

- The timelock must not be the zero address.

[.contract-item]
[[GovernorTimelockExecutionComponent-assert_only_governance]]
==== `[.contract-item-name]#++assert_only_governance++#++(self: @ContractState)++` [.item-kind]#internal#

Ensures the caller is the executor (the timelock controller in this case).

[.contract-item]
[[GovernorTimelockExecutionComponent-timelock_salt]]
==== `[.contract-item-name]#++timelock_salt++#++(self: @ContractState, description_hash: felt252) → felt252++` [.item-kind]#internal#

Computes the `TimelockController` operation salt as the XOR of
the governor address and `description_hash`.

It is computed with the governor address itself to avoid collisions across
governor instances using the same timelock.

[.contract-item]
[[GovernorTimelockExecutionComponent-get_timelock_dispatcher]]
==== `[.contract-item-name]#++get_timelock_dispatcher++#++(self: @ContractState) → ITimelockDispatcher++` [.item-kind]#internal#

Returns a dispatcher for interacting with the timelock controller.

[.contract-item]
[[GovernorTimelockExecutionComponent-_update_timelock]]
==== `[.contract-item-name]#++_update_timelock++#++(ref self: ContractState, new_timelock: ContractAddress)++` [.item-kind]#internal#

Internal function to update the timelock controller address.

Emits a {TimelockUpdated} event.

[#GovernorTimelockExecutionComponent-Events]
==== Events

[.contract-item]
[[GovernorTimelockExecutionComponent-TimelockUpdated]]
==== `[.contract-item-name]#++TimelockUpdated++#++(old_timelock: ContractAddress, new_timelock: ContractAddress)++` [.item-kind]#event#

Emitted when the timelock controller is updated.

== Multisig

A Multisig module enhances security and decentralization by requiring multiple signers to 
approve and execute transactions. Features include configurable quorum, signer management, 
and self-administration, ensuring collective decision-making and transparency for critical 
operations.

[.contract]
[[IMultisig]]
=== `++IMultisig++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/governance/src/multisig/interface.cairo[{github-icon},role=heading-link]

:IMultisig-CallSalt: xref:IMultisig-CallSalt[CallSalt]
:IMultisig-SignerAdded: xref:IMultisig-SignerAdded[SignerAdded]
:IMultisig-SignerRemoved: xref:IMultisig-SignerRemoved[SignerRemoved]
:IMultisig-QuorumUpdated: xref:IMultisig-QuorumUpdated[QuorumUpdated]
:IMultisig-TransactionSubmitted: xref:IMultisig-TransactionSubmitted[TransactionSubmitted]
:IMultisig-TransactionConfirmed: xref:IMultisig-TransactionConfirmed[TransactionConfirmed]
:IMultisig-ConfirmationRevoked: xref:IMultisig-ConfirmationRevoked[ConfirmationRevoked]
:IMultisig-TransactionExecuted: xref:IMultisig-TransactionExecuted[TransactionExecuted]

[.hljs-theme-dark]
```cairo
use openzeppelin_governance::multisig::interface::IMultisig;
```

Interface of a multisig contract.

[.contract-index]
.Functions
--
* xref:#IMultisig-get_quorum[`++get_quorum()++`]
* xref:#IMultisig-is_signer[`++is_signer(signer)++`]
* xref:#IMultisig-get_signers[`++get_signers()++`]
* xref:#IMultisig-is_confirmed[`++is_confirmed(id)++`]
* xref:#IMultisig-is_confirmed_by[`++is_confirmed_by(id, signer)++`]
* xref:#IMultisig-is_executed[`++is_executed(id)++`]
* xref:#IMultisig-get_submitted_block[`++get_submitted_block(id)++`]
* xref:#IMultisig-get_transaction_state[`++get_transaction_state(id)++`]
* xref:#IMultisig-get_transaction_confirmations[`++get_transaction_confirmations(id)++`]
* xref:#IMultisig-hash_transaction[`++hash_transaction(to, selector, calldata, salt)++`]
* xref:#IMultisig-hash_transaction_batch[`++hash_transaction_batch(calls, salt)++`]
* xref:#IMultisig-add_signers[`++add_signers(new_quorum, signers_to_add)++`]
* xref:#IMultisig-remove_signers[`++remove_signers(new_quorum, signers_to_remove)++`]
* xref:#IMultisig-replace_signer[`++replace_signer(signer_to_remove, signer_to_add)++`]
* xref:#IMultisig-change_quorum[`++change_quorum(new_quorum)++`]
* xref:#IMultisig-submit_transaction[`++submit_transaction(to, selector, calldata, salt)++`]
* xref:#IMultisig-submit_transaction_batch[`++submit_transaction_batch(calls, salt)++`]
* xref:#IMultisig-confirm_transaction[`++confirm_transaction(id)++`]
* xref:#IMultisig-revoke_confirmation[`++revoke_confirmation(id)++`]
* xref:#IMultisig-execute_transaction[`++execute_transaction(to, selector, calldata, salt)++`]
* xref:#IMultisig-execute_transaction_batch[`++execute_transaction_batch(calls, salt)++`]
--

[.contract-index]
.Events
--
* xref:#IMultisig-SignerAdded[`++SignerAdded(signer)++`]
* xref:#IMultisig-SignerRemoved[`++SignerRemoved(signer)++`]
* xref:#IMultisig-QuorumUpdated[`++QuorumUpdated(old_quorum, new_quorum)++`]
* xref:#IMultisig-TransactionSubmitted[`++TransactionSubmitted(id, signer)++`]
* xref:#IMultisig-TransactionConfirmed[`++TransactionConfirmed(id, signer)++`]
* xref:#IMultisig-ConfirmationRevoked[`++ConfirmationRevoked(id, signer)++`]
* xref:#IMultisig-TransactionExecuted[`++TransactionExecuted(id)++`]
* xref:#IMultisig-CallSalt[`++CallSalt(id, salt)++`]
--

[#IMultisig-Functions]
==== Functions

[.contract-item]
[[IMultisig-get_quorum]]
==== `[.contract-item-name]#++get_quorum++#++() → u32++` [.item-kind]#external#

Returns the current quorum value. The quorum is the minimum number of confirmations required to approve a transaction.

[.contract-item]
[[IMultisig-is_signer]]
==== `[.contract-item-name]#++is_signer++#++(signer: ContractAddress) → bool++` [.item-kind]#external#

Returns whether the given `signer` is registered. Only registered signers can submit, confirm, or execute transactions.

[.contract-item]
[[IMultisig-get_signers]]
==== `[.contract-item-name]#++get_signers++#++() → Span<ContractAddress>++` [.item-kind]#external#

Returns the list of all current signers.

[.contract-item]
[[IMultisig-is_confirmed]]
==== `[.contract-item-name]#++is_confirmed++#++(id: TransactionID) → bool++` [.item-kind]#external#

Returns whether the transaction with the given `id` has been confirmed.

[.contract-item]
[[IMultisig-is_confirmed_by]]
==== `[.contract-item-name]#++is_confirmed_by++#++(id: TransactionID, signer: ContractAddress) → bool++` [.item-kind]#external#

Returns whether the transaction with the given `id` has been confirmed by the specified `signer`.

[.contract-item]
[[IMultisig-is_executed]]
==== `[.contract-item-name]#++is_executed++#++(id: TransactionID) → bool++` [.item-kind]#external#

Returns whether the transaction with the given `id` has been executed.

[.contract-item]
[[IMultisig-get_submitted_block]]
==== `[.contract-item-name]#++get_submitted_block++#++(id: TransactionID) → u64++` [.item-kind]#external#

Returns the block number when the transaction with the given `id` was submitted.

[.contract-item]
[[IMultisig-get_transaction_state]]
==== `[.contract-item-name]#++get_transaction_state++#++(id: TransactionID) → TransactionState++` [.item-kind]#external#

Returns the current state of the transaction with the given `id`.

[.contract-item]
[[IMultisig-get_transaction_confirmations]]
==== `[.contract-item-name]#++get_transaction_confirmations++#++(id: TransactionID) → u32++` [.item-kind]#external#

Returns the number of confirmations from registered signers for the transaction with the specified `id`.

[.contract-item]
[[IMultisig-hash_transaction]]
==== `[.contract-item-name]#++hash_transaction++#++(to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252) → TransactionID++` [.item-kind]#external#

Returns the computed identifier of a transaction containing a single call.

[.contract-item]
[[IMultisig-hash_transaction_batch]]
==== `[.contract-item-name]#++hash_transaction_batch++#++(calls: Span<Call>, salt: felt252) → TransactionID++` [.item-kind]#external#

Returns the computed identifier of a transaction containing a batch of calls.

[.contract-item]
[[IMultisig-add_signers]]
==== `[.contract-item-name]#++add_signers++#++(new_quorum: u32, signers_to_add: Span<ContractAddress>)++` [.item-kind]#external#

Adds new signers and updates the quorum.

Requirements:

- The caller must be the contract itself.
- `new_quorum` must be less than or equal to the total number of signers after addition.

Emits a {IMultisig-SignerAdded} event for each signer added.

Emits a {IMultisig-QuorumUpdated} event if the quorum changes.

[.contract-item]
[[IMultisig-remove_signers]]
==== `[.contract-item-name]#++remove_signers++#++(new_quorum: u32, signers_to_remove: Span<ContractAddress>)++` [.item-kind]#external#

Removes signers and updates the quorum.

Requirements:

- The caller must be the contract itself.
- `new_quorum` must be less than or equal to the total number of signers after removal.

Emits a {IMultisig-SignerRemoved} event for each signer removed.

Emits a {IMultisig-QuorumUpdated} event if the quorum changes.

[.contract-item]
[[IMultisig-replace_signer]]
==== `[.contract-item-name]#++replace_signer++#++(signer_to_remove: ContractAddress, signer_to_add: ContractAddress)++` [.item-kind]#external#

Replaces an existing signer with a new signer.

Requirements:

- The caller must be the contract itself.
- `signer_to_remove` must be an existing signer.
- `signer_to_add` must not be an existing signer.

Emits a {IMultisig-SignerRemoved} event for the removed signer.

Emits a {IMultisig-SignerAdded} event for the new signer.

[.contract-item]
[[IMultisig-change_quorum]]
==== `[.contract-item-name]#++change_quorum++#++(new_quorum: u32)++` [.item-kind]#external#

Updates the quorum value to `new_quorum` if it differs from the current quorum.

Requirements:

- The caller must be the contract itself.
- `new_quorum` must be non-zero.
- `new_quorum` must be less than or equal to the total number of signers.

Emits a {IMultisig-QuorumUpdated} event if the quorum changes.

[.contract-item]
[[IMultisig-submit_transaction]]
==== `[.contract-item-name]#++submit_transaction++#++(to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252) → TransactionID++` [.item-kind]#external#

Submits a new transaction for confirmation.

Requirements:

- The caller must be a registered signer.
- The transaction must not have been submitted before.

Emits a {IMultisig-TransactionSubmitted} event.

Emits a {IMultisig-CallSalt} event if `salt` is not zero.

[.contract-item]
[[IMultisig-submit_transaction_batch]]
==== `[.contract-item-name]#++submit_transaction_batch++#++(calls: Span<Call>, salt: felt252) → TransactionID++` [.item-kind]#external#

Submits a new batch transaction for confirmation.

Requirements:

- The caller must be a registered signer.
- The transaction must not have been submitted before.

Emits a {IMultisig-TransactionSubmitted} event.

Emits a {IMultisig-CallSalt} event if `salt` is not zero.

[.contract-item]
[[IMultisig-confirm_transaction]]
==== `[.contract-item-name]#++confirm_transaction++#++(id: TransactionID)++` [.item-kind]#external#

Confirms a transaction with the given `id`.

Requirements:

- The caller must be a registered signer.
- The transaction must exist and not be executed.
- The caller must not have already confirmed the transaction.

Emits a {IMultisig-TransactionConfirmed} event.

[.contract-item]
[[IMultisig-revoke_confirmation]]
==== `[.contract-item-name]#++revoke_confirmation++#++(id: TransactionID)++` [.item-kind]#external#

Revokes a previous confirmation for a transaction with the given `id`.

Requirements:

- The transaction must exist and not be executed.
- The caller must have previously confirmed the transaction.

Emits a {IMultisig-ConfirmationRevoked} event.

[.contract-item]
[[IMultisig-execute_transaction]]
==== `[.contract-item-name]#++execute_transaction++#++(to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252)++` [.item-kind]#external#

Executes a confirmed transaction.

Requirements:

- The caller must be a registered signer.
- The transaction must be confirmed and not yet executed.

Emits a {IMultisig-TransactionExecuted} event.

[.contract-item]
[[IMultisig-execute_transaction_batch]]
==== `[.contract-item-name]#++execute_transaction_batch++#++(calls: Span<Call>, salt: felt252)++` [.item-kind]#external#

Executes a confirmed batch transaction.

Requirements:

- The caller must be a registered signer.
- The transaction must be confirmed and not yet executed.

Emits a {IMultisig-TransactionExecuted} event.

[#IMultisig-Events]
==== Events

[.contract-item]
[[IMultisig-SignerAdded]]
==== `[.contract-item-name]#++SignerAdded++#++(signer: ContractAddress)++` [.item-kind]#event#

Emitted when a new `signer` is added.

[.contract-item]
[[IMultisig-SignerRemoved]]
==== `[.contract-item-name]#++SignerRemoved++#++(signer: ContractAddress)++` [.item-kind]#event#

Emitted when a `signer` is removed.

[.contract-item]
[[IMultisig-QuorumUpdated]]
==== `[.contract-item-name]#++QuorumUpdated++#++(old_quorum: u32, new_quorum: u32)++` [.item-kind]#event#

Emitted when the `quorum` value is updated.

[.contract-item]
[[IMultisig-TransactionSubmitted]]
==== `[.contract-item-name]#++TransactionSubmitted++#++(id: TransactionID, signer: ContractAddress)++` [.item-kind]#event#

Emitted when a new transaction is submitted by a `signer`.

[.contract-item]
[[IMultisig-TransactionConfirmed]]
==== `[.contract-item-name]#++TransactionConfirmed++#++(id: TransactionID, signer: ContractAddress)++` [.item-kind]#event#

Emitted when a transaction is confirmed by a `signer`.

[.contract-item]
[[IMultisig-ConfirmationRevoked]]
==== `[.contract-item-name]#++ConfirmationRevoked++#++(id: TransactionID, signer: ContractAddress)++` [.item-kind]#event#

Emitted when a `signer` revokes his confirmation.

[.contract-item]
[[IMultisig-TransactionExecuted]]
==== `[.contract-item-name]#++TransactionExecuted++#++(id: TransactionID)++` [.item-kind]#event#

Emitted when a transaction is executed.

[.contract-item]
[[IMultisig-CallSalt]]
==== `[.contract-item-name]#++CallSalt++#++(id: felt252, salt: felt252)++` [.item-kind]#event#

Emitted when a new transaction is submitted with non-zero salt.

[.contract]
[[MultisigComponent]]
=== `++MultisigComponent++`

:MultisigComponent-CallSalt: xref:MultisigComponent-CallSalt[CallSalt]
:MultisigComponent-SignerAdded: xref:MultisigComponent-SignerAdded[SignerAdded]
:MultisigComponent-SignerRemoved: xref:MultisigComponent-SignerRemoved[SignerRemoved]
:MultisigComponent-QuorumUpdated: xref:MultisigComponent-QuorumUpdated[QuorumUpdated]
:MultisigComponent-TransactionSubmitted: xref:MultisigComponent-TransactionSubmitted[TransactionSubmitted]
:MultisigComponent-TransactionConfirmed: xref:MultisigComponent-TransactionConfirmed[TransactionConfirmed]
:MultisigComponent-ConfirmationRevoked: xref:MultisigComponent-ConfirmationRevoked[ConfirmationRevoked]
:MultisigComponent-TransactionExecuted: xref:MultisigComponent-TransactionExecuted[TransactionExecuted]

[.hljs-theme-dark]
```cairo
use openzeppelin_governance::multisig::MultisigComponent;
```

Component that implements <<IMultisig, IMultisig>> and provides functionality for multisignature wallets, 
including transaction management, quorum handling, and signer operations.

[.contract-index]
.Embeddable Implementations
--
.MultisigImpl

* xref:#MultisigComponent-get_quorum[`++get_quorum(self)++`]
* xref:#MultisigComponent-is_signer[`++is_signer(self, signer)++`]
* xref:#MultisigComponent-get_signers[`++get_signers(self)++`]
* xref:#MultisigComponent-is_confirmed[`++is_confirmed(self, id)++`]
* xref:#MultisigComponent-is_confirmed_by[`++is_confirmed_by(self, id, signer)++`]
* xref:#MultisigComponent-is_executed[`++is_executed(self, id)++`]
* xref:#MultisigComponent-get_submitted_block[`++get_submitted_block(self, id)++`]
* xref:#MultisigComponent-get_transaction_state[`++get_transaction_state(self, id)++`]
* xref:#MultisigComponent-get_transaction_confirmations[`++get_transaction_confirmations(self, id)++`]
* xref:#MultisigComponent-hash_transaction[`++hash_transaction(self, to, selector, calldata, salt)++`]
* xref:#MultisigComponent-hash_transaction_batch[`++hash_transaction_batch(self, calls, salt)++`]
* xref:#MultisigComponent-add_signers[`++add_signers(ref self, new_quorum, signers_to_add)++`]
* xref:#MultisigComponent-remove_signers[`++remove_signers(ref self, new_quorum, signers_to_remove)++`]
* xref:#MultisigComponent-replace_signer[`++replace_signer(ref self, signer_to_remove, signer_to_add)++`]
* xref:#MultisigComponent-change_quorum[`++change_quorum(ref self, new_quorum)++`]
* xref:#MultisigComponent-submit_transaction[`++submit_transaction(ref self, to, selector, calldata, salt)++`]
* xref:#MultisigComponent-submit_transaction_batch[`++submit_transaction_batch(ref self, calls, salt)++`]
* xref:#MultisigComponent-confirm_transaction[`++confirm_transaction(ref self, id)++`]
* xref:#MultisigComponent-revoke_confirmation[`++revoke_confirmation(ref self, id)++`]
* xref:#MultisigComponent-execute_transaction[`++execute_transaction(ref self, to, selector, calldata, salt)++`]
* xref:#MultisigComponent-execute_transaction_batch[`++execute_transaction_batch(ref self, calls, salt)++`]
--

[.contract-index]
.Internal Implementations
--
.InternalImpl

* xref:#MultisigComponent-initializer[`++initializer(ref self, quorum, signers)++`]
* xref:#MultisigComponent-resolve_tx_state[`++resolve_tx_state(self, id)++`]
* xref:#MultisigComponent-assert_one_of_signers[`++assert_one_of_signers(self, caller)++`]
* xref:#MultisigComponent-assert_tx_exists[`++assert_tx_exists(self, id)++`]
* xref:#MultisigComponent-assert_only_self[`++assert_only_self(self)++`]
* xref:#MultisigComponent-_add_signers[`++_add_signers(ref self, new_quorum, signers_to_add)++`]
* xref:#MultisigComponent-_remove_signers[`++_remove_signers(ref self, new_quorum, signers_to_remove)++`]
* xref:#MultisigComponent-_replace_signer[`++_replace_signer(ref self, signer_to_remove, signer_to_add)++`]
* xref:#MultisigComponent-_change_quorum[`++_change_quorum(ref self, new_quorum)++`]
--

[.contract-index]
.Events
--
* xref:#MultisigComponent-SignerAdded[`++SignerAdded(signer)++`]
* xref:#MultisigComponent-SignerRemoved[`++SignerRemoved(signer)++`]
* xref:#MultisigComponent-QuorumUpdated[`++QuorumUpdated(old_quorum, new_quorum)++`]
* xref:#MultisigComponent-TransactionSubmitted[`++TransactionSubmitted(id, signer)++`]
* xref:#MultisigComponent-TransactionConfirmed[`++TransactionConfirmed(id, signer)++`]
* xref:#MultisigComponent-ConfirmationRevoked[`++ConfirmationRevoked(id, signer)++`]
* xref:#MultisigComponent-TransactionExecuted[`++TransactionExecuted(id)++`]
* xref:#MultisigComponent-CallSalt[`++CallSalt(id, salt)++`]
--

[#MultisigComponent-Functions]
==== Embeddable functions

[.contract-item]
[[MultisigComponent-get_quorum]]
==== `[.contract-item-name]#++get_quorum++#++(self: @ContractState) → u32++` [.item-kind]#external#

Returns the current quorum value.

[.contract-item]
[[MultisigComponent-is_signer]]
==== `[.contract-item-name]#++is_signer++#++(self: @ContractState, signer: ContractAddress) → bool++` [.item-kind]#external#

Checks if a given `signer` is registered.

[.contract-item]
[[MultisigComponent-get_signers]]
==== `[.contract-item-name]#++get_signers++#++(self: @ContractState) → Span<ContractAddress>++` [.item-kind]#external#

Returns a list of all current signers.

[.contract-item]
[[MultisigComponent-is_confirmed]]
==== `[.contract-item-name]#++is_confirmed++#++(self: @ContractState, id: TransactionID) → bool++` [.item-kind]#external#

Returns whether the transaction with the given `id` has been confirmed. A confirmed transaction has received the required number of confirmations (quorum).

[.contract-item]
[[MultisigComponent-is_confirmed_by]]
==== `[.contract-item-name]#++is_confirmed_by++#++(self: @ContractState, id: TransactionID, signer: ContractAddress) → bool++` [.item-kind]#external#

Returns whether the transaction with the given `id` has been confirmed by the specified `signer`.

[.contract-item]
[[MultisigComponent-is_executed]]
==== `[.contract-item-name]#++is_executed++#++(self: @ContractState, id: TransactionID) → bool++` [.item-kind]#external#

Returns whether the transaction with the given `id` has been executed.

[.contract-item]
[[MultisigComponent-get_submitted_block]]
==== `[.contract-item-name]#++get_submitted_block++#++(self: @ContractState, id: TransactionID) → u64++` [.item-kind]#external#

Returns the block number when the transaction with the given `id` was submitted.

[.contract-item]
[[MultisigComponent-get_transaction_state]]
==== `[.contract-item-name]#++get_transaction_state++#++(self: @ContractState, id: TransactionID) → TransactionState++` [.item-kind]#external#

Returns the current state of the transaction with the given `id`.

The possible states are:

- `NotFound`: the transaction does not exist.
- `Pending`: the transaction exists but hasn't reached the required confirmations.
- `Confirmed`: the transaction has reached the required confirmations but hasn't been executed.
- `Executed`: the transaction has been executed.

[.contract-item]
[[MultisigComponent-get_transaction_confirmations]]
==== `[.contract-item-name]#++get_transaction_confirmations++#++(self: @ContractState, id: TransactionID) → u32++` [.item-kind]#external#

Returns the number of confirmations from registered signers for the transaction with the specified `id`.

[.contract-item]
[[MultisigComponent-hash_transaction]]
==== `[.contract-item-name]#++hash_transaction++#++(self: @ContractState, to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252)++` [.item-kind]#external#

Returns the computed identifier of a transaction containing a single call.

[.contract-item]
[[MultisigComponent-hash_transaction_batch]]
==== `[.contract-item-name]#++hash_transaction_batch++#++(self: @ContractState, calls: Span<Call>, salt: felt252)++` [.item-kind]#external#

Returns the computed identifier of a transaction containing a batch of calls.

[.contract-item]
[[MultisigComponent-add_signers]]
==== `[.contract-item-name]#++add_signers++#++(ref self: ContractState, new_quorum: u32, signers_to_add: Span<ContractAddress>)++` [.item-kind]#external#

Adds new signers and updates the quorum.

Requirements:

- The caller must be the contract itself.
- `new_quorum` must be less than or equal to the total number of signers after addition.

Emits a {MultisigComponent-SignerAdded} event for each signer added.

Emits a {MultisigComponent-QuorumUpdated} event if the quorum changes.

[.contract-item]
[[MultisigComponent-remove_signers]]
==== `[.contract-item-name]#++remove_signers++#++(ref self: ContractState, new_quorum: u32, signers_to_remove: Span<ContractAddress>)++` [.item-kind]#external#

Removes signers and updates the quorum.

Requirements:

- The caller must be the contract itself.
- `new_quorum` must be less than or equal to the total number of signers after removal.

Emits a {MultisigComponent-SignerRemoved} event for each signer removed.

Emits a {MultisigComponent-QuorumUpdated} event if the quorum changes.

[.contract-item]
[[MultisigComponent-replace_signer]]
==== `[.contract-item-name]#++replace_signer++#++(ref self: ContractState, signer_to_remove: ContractAddress, signer_to_add: ContractAddress)++` [.item-kind]#external#

Replaces an existing signer with a new signer.

Requirements:

- The caller must be the contract itself.
- `signer_to_remove` must be an existing signer.
- `signer_to_add` must not be an existing signer.

Emits a {MultisigComponent-SignerRemoved} event for the removed signer.

Emits a {MultisigComponent-SignerAdded} event for the new signer.

[.contract-item]
[[MultisigComponent-change_quorum]]
==== `[.contract-item-name]#++change_quorum++#++(ref self: ContractState, new_quorum: u32)++` [.item-kind]#external#

Updates the quorum value to `new_quorum`.

Requirements:

- The caller must be the contract itself.
- `new_quorum` must be non-zero.
- `new_quorum` must be less than or equal to the total number of signers.

Emits a {MultisigComponent-QuorumUpdated} event if the quorum changes.

[.contract-item]
[[MultisigComponent-submit_transaction]]
==== `[.contract-item-name]#++submit_transaction++#++(ref self: ContractState, to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252)++` [.item-kind]#external#

Submits a new transaction for confirmation.

Requirements:

- The caller must be a registered signer.
- The transaction must not have been submitted before.

Emits a {MultisigComponent-TransactionSubmitted} event.

Emits a {MultisigComponent-CallSalt} event if `salt` is not zero.

[.contract-item]
[[MultisigComponent-submit_transaction_batch]]
==== `[.contract-item-name]#++submit_transaction_batch++#++(ref self: ContractState, calls: Span<Call>, salt: felt252)++` [.item-kind]#external#

Submits a new batch transaction for confirmation.

Requirements:

- The caller must be a registered signer.
- The transaction must not have been submitted before.

Emits a {MultisigComponent-TransactionSubmitted} event.

Emits a {MultisigComponent-CallSalt} event if `salt` is not zero.

[.contract-item]
[[MultisigComponent-confirm_transaction]]
==== `[.contract-item-name]#++confirm_transaction++#++(ref self: ContractState, id: TransactionID)++` [.item-kind]#external#

Confirms a transaction with the given `id`.

Requirements:

- The caller must be a registered signer.
- The transaction must exist and not be executed.
- The caller must not have already confirmed the transaction.

Emits a {MultisigComponent-TransactionConfirmed} event.

[.contract-item]
[[MultisigComponent-revoke_confirmation]]
==== `[.contract-item-name]#++revoke_confirmation++#++(ref self: ContractState, id: TransactionID)++` [.item-kind]#external#

Revokes a previous confirmation for a transaction with the given `id`.

Requirements:

- The transaction must exist and not be executed.
- The caller must have previously confirmed the transaction.

Emits a {MultisigComponent-ConfirmationRevoked} event.

[.contract-item]
[[MultisigComponent-execute_transaction]]
==== `[.contract-item-name]#++execute_transaction++#++(ref self: ContractState, to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252)++` [.item-kind]#external#

Executes a confirmed transaction.

Requirements:

- The caller must be a registered signer.
- The transaction must be confirmed and not yet executed.

Emits a {MultisigComponent-TransactionExecuted} event.

[.contract-item]
[[MultisigComponent-execute_transaction_batch]]
==== `[.contract-item-name]#++execute_transaction_batch++#++(ref self: ContractState, calls: Span<Call>, salt: felt252)++` [.item-kind]#external#

Executes a confirmed batch transaction.

Requirements:

- The caller must be a registered signer.
- The transaction must be confirmed and not yet executed.

Emits a {MultisigComponent-TransactionExecuted} event.

[#MultisigComponent-Internal-Functions]
==== Internal functions

[.contract-item]
[[MultisigComponent-initializer]]
==== `[.contract-item-name]#++initializer++#++(ref self: ContractState, quorum: u32, signers: Span<ContractAddress>)++` [.item-kind]#internal#

Initializes the Multisig component with the initial `quorum` and `signers`.
This function must be called during contract initialization to set up the initial state.

Requirements:

- `quorum` must be non-zero and less than or equal to the number of `signers`.

Emits a {MultisigComponent-SignerAdded} event for each signer added.

Emits a {MultisigComponent-QuorumUpdated} event.

[.contract-item]
[[MultisigComponent-resolve_tx_state]]
==== `[.contract-item-name]#++resolve_tx_state++#++(self: @ContractState, id: TransactionID) → TransactionState++` [.item-kind]#internal#

Resolves and returns the current state of the transaction with the given `id`.

The possible states are:

- `NotFound`: the transaction does not exist.
- `Pending`: the transaction exists but hasn't reached the required confirmations.
- `Confirmed`: the transaction has reached the required confirmations but hasn't been executed.
- `Executed`: the transaction has been executed.

[.contract-item]
[[MultisigComponent-assert_one_of_signers]]
==== `[.contract-item-name]#++assert_one_of_signers++#++(self: @ContractState, caller: ContractAddress)++` [.item-kind]#internal#

Asserts that the `caller` is one of the registered signers.

Requirements:

- The `caller` must be a registered signer.

[.contract-item]
[[MultisigComponent-assert_tx_exists]]
==== `[.contract-item-name]#++assert_tx_exists++#++(self: @ContractState, id: TransactionID)++` [.item-kind]#internal#

Asserts that a transaction with the given `id` exists.

Requirements:

- The transaction with the given `id` must have been submitted.

[.contract-item]
[[MultisigComponent-assert_only_self]]
==== `[.contract-item-name]#++assert_only_self++#++(self: @ContractState)++` [.item-kind]#internal#

Asserts that the caller is the contract itself.

Requirements:

- The caller must be the contract's own address.

[.contract-item]
[[MultisigComponent-_add_signers]]
==== `[.contract-item-name]#++_add_signers++#++(ref self: ContractState, new_quorum: u32, signers_to_add: Span<ContractAddress>)++` [.item-kind]#internal#

Adds new signers and updates the quorum.

Requirements:

- Each signer address must be non-zero.
- `new_quorum` must be non-zero and less than or equal to the total number of signers after addition.

Emits a {MultisigComponent-SignerAdded} event for each new signer added.

Emits a {MultisigComponent-QuorumUpdated} event if the quorum changes.

[.contract-item]
[[MultisigComponent-_remove_signers]]
==== `[.contract-item-name]#++_remove_signers++#++(ref self: ContractState, new_quorum: u32, signers_to_remove: Span<ContractAddress>)++` [.item-kind]#internal#

Removes existing signers and updates the quorum.

Requirements:

- `new_quorum` must be non-zero and less than or equal to the total number of signers
after removal.

Emits a {MultisigComponent-SignerRemoved} event for each signer removed.

Emits a {MultisigComponent-QuorumUpdated} event if the quorum changes.

[.contract-item]
[[MultisigComponent-_replace_signer]]
==== `[.contract-item-name]#++_replace_signer++#++(ref self: ContractState, signer_to_remove: ContractAddress, signer_to_add: ContractAddress)++` [.item-kind]#internal#

Replaces an existing signer with a new signer.

Requirements:

- `signer_to_remove` must be an existing signer.
- `signer_to_add` must not be an existing signer.
- `signer_to_add` must be a non-zero address.

Emits a {MultisigComponent-SignerRemoved} event for the removed signer.

Emits a {MultisigComponent-SignerAdded} event for the new signer.

[.contract-item]
[[MultisigComponent-_change_quorum]]
==== `[.contract-item-name]#++_change_quorum++#++(ref self: ContractState, new_quorum: u32)++` [.item-kind]#internal#

Updates the quorum value to `new_quorum` if it differs from the current quorum.

Requirements:

- `new_quorum` must be non-zero.
- `new_quorum` must be less than or equal to the total number of signers.

Emits a {MultisigComponent-QuorumUpdated} event if the quorum changes.

[#MultisigComponent-Events]
==== Events

[.contract-item]
[[MultisigComponent-SignerAdded]]
==== `[.contract-item-name]#++SignerAdded++#++(signer: ContractAddress)++` [.item-kind]#event#

Emitted when a new `signer` is added.

[.contract-item]
[[MultisigComponent-SignerRemoved]]
==== `[.contract-item-name]#++SignerRemoved++#++(signer: ContractAddress)++` [.item-kind]#event#

Emitted when a `signer` is removed.

[.contract-item]
[[MultisigComponent-QuorumUpdated]]
==== `[.contract-item-name]#++QuorumUpdated++#++(old_quorum: u32, new_quorum: u32)++` [.item-kind]#event#

Emitted when the `quorum` value is updated.

[.contract-item]
[[MultisigComponent-TransactionSubmitted]]
==== `[.contract-item-name]#++TransactionSubmitted++#++(id: TransactionID, signer: ContractAddress)++` [.item-kind]#event#

Emitted when a new transaction is submitted by a `signer`.

[.contract-item]
[[MultisigComponent-TransactionConfirmed]]
==== `[.contract-item-name]#++TransactionConfirmed++#++(id: TransactionID, signer: ContractAddress)++` [.item-kind]#event#

Emitted when a transaction is confirmed by a `signer`.

[.contract-item]
[[MultisigComponent-ConfirmationRevoked]]
==== `[.contract-item-name]#++ConfirmationRevoked++#++(id: TransactionID, signer: ContractAddress)++` [.item-kind]#event#

Emitted when a `signer` revokes his confirmation.

[.contract-item]
[[MultisigComponent-TransactionExecuted]]
==== `[.contract-item-name]#++TransactionExecuted++#++(id: TransactionID)++` [.item-kind]#event#

Emitted when a transaction is executed.

[.contract-item]
[[MultisigComponent-CallSalt]]
==== `[.contract-item-name]#++CallSalt++#++(id: felt252, salt: felt252)++` [.item-kind]#event#

Emitted when a new transaction is submitted with non-zero salt.

== Timelock

In a governance system, `TimelockControllerComponent` is in charge of introducing a delay between a proposal and its execution.

[.contract]
[[ITimelock]]
=== `++ITimelock++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/governance/src/timelock/interface.cairo[{github-icon},role=heading-link]

:ITimelock-CallScheduled: xref:ITimelock-CallScheduled[CallScheduled]
:ITimelock-CallExecuted: xref:ITimelock-CallExecuted[CallExecuted]
:ITimelock-CallSalt: xref:ITimelock-CallSalt[CallSalt]
:ITimelock-CallCancelled: xref:ITimelock-CallCancelled[CallCancelled]
:ITimelock-MinDelayChanged: xref:ITimelock-MinDelayChanged[MinDelayChanged]

[.hljs-theme-dark]
```cairo
use openzeppelin_governance::timelock::interface::ITimelock;
```

Interface of a timelock contract.

[.contract-index]
.Functions
--
* xref:#ITimelock-is_operation[`++is_operation(id)++`]
* xref:#ITimelock-is_operation_pending[`++is_operation_pending(id)++`]
* xref:#ITimelock-is_operation_ready[`++is_operation_ready(id)++`]
* xref:#ITimelock-is_operation_done[`++is_operation_done(id)++`]
* xref:#ITimelock-get_timestamp[`++get_timestamp(id)++`]
* xref:#ITimelock-get_operation_state[`++get_operation_state(id)++`]
* xref:#ITimelock-get_min_delay[`++get_min_delay()++`]
* xref:#ITimelock-hash_operation[`++hash_operation(call, predecessor, salt)++`]
* xref:#ITimelock-hash_operation_batch[`++hash_operation_batch(calls, predecessor, salt)++`]
* xref:#ITimelock-schedule[`++schedule(call, predecessor, salt, delay)++`]
* xref:#ITimelock-schedule_batch[`++schedule_batch(calls, predecessor, salt, delay)++`]
* xref:#ITimelock-cancel[`++cancel(id)++`]
* xref:#ITimelock-execute[`++execute(call, predecessor, salt)++`]
* xref:#ITimelock-execute_batch[`++execute_batch(calls, predecessor, salt)++`]
* xref:#ITimelock-update_delay[`++update_delay(new_delay)++`]
--

[.contract-index]
.Events
--
* xref:#ITimelock-CallScheduled[`++CallScheduled(id, index, call, predecessor, delay)++`]
* xref:#ITimelock-CallExecuted[`++CallExecuted(id, index, call)++`]
* xref:#ITimelock-CallSalt[`++CallSalt(id, salt)++`]
* xref:#ITimelock-CallCancelled[`++CallCancelled(id)++`]
* xref:#ITimelock-MinDelayChanged[`++MinDelayChanged(old_duration, new_duration)++`]
--

[#ITimelock-Functions]
==== Functions

[.contract-item]
[[ITimelock-is_operation]]
==== `[.contract-item-name]#++is_operation++#++(id: felt252) → bool++` [.item-kind]#external#

Returns whether `id` corresponds to a registered operation.
This includes the OperationStates: `Waiting`, `Ready`, and `Done`.

[.contract-item]
[[ITimelock-is_operation_pending]]
==== `[.contract-item-name]#++is_operation_pending++#++(id: felt252) → bool++` [.item-kind]#external#

Returns whether the `id` OperationState is pending or not.
Note that a pending operation may be either `Waiting` or `Ready`.

[.contract-item]
[[ITimelock-is_operation_ready]]
==== `[.contract-item-name]#++is_operation_ready++#++(id: felt252) → bool++` [.item-kind]#external#

Returns whether the `id` OperationState is `Ready` or not.

[.contract-item]
[[ITimelock-is_operation_done]]
==== `[.contract-item-name]#++is_operation_done++#++(id: felt252) → bool++` [.item-kind]#external#

Returns whether the `id` OperationState is `Done` or not.

[.contract-item]
[[ITimelock-get_timestamp]]
==== `[.contract-item-name]#++get_timestamp++#++(id: felt252) → u64++` [.item-kind]#external#

Returns the timestamp at which `id` becomes `Ready`.

NOTE: `0` means the OperationState is `Unset` and `1` means the OperationState
is `Done`.

[.contract-item]
[[ITimelock-get_operation_state]]
==== `[.contract-item-name]#++get_operation_state++#++(id: felt252) → OperationState++` [.item-kind]#external#

Returns the current state of the operation with the given `id`.

The possible states are:

- `Unset`: the operation has not been scheduled or has been canceled.
- `Waiting`: the operation has been scheduled and is pending the scheduled delay.
- `Ready`: the timer has expired, and the operation is eligible for execution.
- `Done`: the operation has been executed.

[.contract-item]
[[ITimelock-get_min_delay]]
==== `[.contract-item-name]#++get_min_delay++#++() → u64++` [.item-kind]#external#

Returns the minimum delay in seconds for an operation to become valid.
This value can be changed by executing an operation that calls `update_delay`.

[.contract-item]
[[ITimelock-hash_operation]]
==== `[.contract-item-name]#++hash_operation++#++(call: Call, predecessor: felt252, salt: felt252)++` [.item-kind]#external#

Returns the identifier of an operation containing a single transaction.

[.contract-item]
[[ITimelock-hash_operation_batch]]
==== `[.contract-item-name]#++hash_operation_batch++#++(calls: Span<Call>, predecessor: felt252, salt: felt252)++` [.item-kind]#external#

Returns the identifier of an operation containing a batch of transactions.

[.contract-item]
[[ITimelock-schedule]]
==== `[.contract-item-name]#++schedule++#++(call: Call, predecessor: felt252, salt: felt252, delay: u64)++` [.item-kind]#external#

Schedule an operation containing a single transaction.

Requirements:

- The caller must have the `PROPOSER_ROLE` role.

Emits {ITimelock-CallScheduled} event.
Emits {ITimelock-CallSalt} event if `salt` is not zero.

[.contract-item]
[[ITimelock-schedule_batch]]
==== `[.contract-item-name]#++schedule_batch++#++(calls: Span<Call>, predecessor: felt252, salt: felt252, delay: u64)++` [.item-kind]#external#

Schedule an operation containing a batch of transactions.

Requirements:

- The caller must have the `PROPOSER_ROLE` role.

Emits one {ITimelock-CallScheduled} event for each transaction in the batch.
Emits {ITimelock-CallSalt} event if `salt` is not zero.

[.contract-item]
[[ITimelock-cancel]]
==== `[.contract-item-name]#++cancel++#++(id: felt252)++` [.item-kind]#external#

Cancels an operation. A canceled operation returns to `Unset` OperationState.

Requirements:

- The caller must have the `CANCELLER_ROLE` role.
- `id` must be a pending operation.

Emits a {ITimelock-CallCancelled} event.

[.contract-item]
[[ITimelock-execute]]
==== `[.contract-item-name]#++execute++#++(call: Call, predecessor: felt252, salt: felt252)++` [.item-kind]#external#

Execute a (Ready) operation containing a single Call.

Requirements:

- Caller must have `EXECUTOR_ROLE`.
- `id` must be in Ready OperationState.
- `predecessor` must either be `0` or in Done OperationState.

Emits a {ITimelock-CallExecuted} event.

NOTE: This function can reenter, but it doesn't pose a risk because <<TimelockControllerComponent-_after_call>>
checks that the proposal is pending, thus any modifications to the operation during
reentrancy should be caught.

[.contract-item]
[[ITimelock-execute_batch]]
==== `[.contract-item-name]#++execute_batch++#++(calls: Span<Call>, predecessor: felt252, salt: felt252)++` [.item-kind]#external#

Execute a (Ready) operation containing a batch of Calls.

Requirements:

- Caller must have `EXECUTOR_ROLE`.
- `id` must be in Ready OperationState.
- `predecessor` must either be `0` or in Done OperationState.

Emits a {ITimelock-CallExecuted} event for each Call.

NOTE: This function can reenter, but it doesn't pose a risk because `_after_call`
checks that the proposal is pending, thus any modifications to the operation during
reentrancy should be caught.

[.contract-item]
[[ITimelock-update_delay]]
==== `[.contract-item-name]#++update_delay++#++(new_delay: u64)++` [.item-kind]#external#

Changes the minimum timelock duration for future operations.

Requirements:

- The caller must be the timelock itself. This can only be achieved by scheduling
and later executing an operation where the timelock is the target and the data
is the serialized call to this function.

Emits a {ITimelock-MinDelayChanged} event.

[#ITimelock-Events]
==== Events

[.contract-item]
[[ITimelock-CallScheduled]]
==== `[.contract-item-name]#++CallScheduled++#++(id: felt252, index: felt252, call: Call, predecessor: felt252, delay: u64)++` [.item-kind]#event#

Emitted when `call` is scheduled as part of operation `id`.

[.contract-item]
[[ITimelock-CallExecuted]]
==== `[.contract-item-name]#++CallExecuted++#++(id: felt252, index: felt252, call: Call)++` [.item-kind]#event#

Emitted when `call` is performed as part of operation `id`.

[.contract-item]
[[ITimelock-CallSalt]]
==== `[.contract-item-name]#++CallSalt++#++(id: felt252, salt: felt252)++` [.item-kind]#event#

Emitted when a new proposal is scheduled with non-zero salt.

[.contract-item]
[[ITimelock-CallCancelled]]
==== `[.contract-item-name]#++CallCancelled++#++(id: felt252)++` [.item-kind]#event#

Emitted when operation `id` is cancelled.

[.contract-item]
[[ITimelock-MinDelayChanged]]
==== `[.contract-item-name]#++MinDelayChanged++#++(old_duration: u64, new_duration: u64)++` [.item-kind]#event#

Emitted when the minimum delay for future operations is modified.

[.contract]
[[TimelockControllerComponent]]
=== `++TimelockControllerComponent++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/governance/src/timelock/timelock_controller.cairo[{github-icon},role=heading-link]

:TimelockComponent-CallScheduled: xref:TimelockControllerComponent-CallScheduled[CallScheduled]
:TimelockComponent-CallExecuted: xref:TimelockControllerComponent-CallExecuted[CallExecuted]
:TimelockComponent-CallSalt: xref:TimelockControllerComponent-CallSalt[CallSalt]
:TimelockComponent-CallCancelled: xref:TimelockControllerComponent-CallCancelled[CallCancelled]
:TimelockComponent-MinDelayChanged: xref:TimelockControllerComponent-MinDelayChanged[MinDelayChanged]

include::../utils/_common.adoc[]

[.hljs-theme-dark]
```cairo
use openzeppelin_governance::timelock::TimelockControllerComponent;
```

Component that implements <<ITimelock, ITimelock>> and enables the implementing contract to act as a timelock controller.

[.contract-index#TimelockControllerComponent-Embeddable-Mixin-Impl]
.{mixin-impls}

--
.TimelockMixinImpl

* xref:#TimelockControllerComponent-Embeddable-Impls-TimelockImpl[`++TimelockImpl++`]
* xref:api/introspection.adoc#SRC5Component-Embeddable-Impls[`++SRC5Impl++`]
* xref:api/access.adoc#AccessControlComponent-Embeddable-Impls[`++AccessControlImpl++`]
* xref:api/access.adoc#AccessControlComponent-Embeddable-Impls[`++AccessControlCamelImpl++`]
--

[.contract-index#TimelockControllerComponent-Embeddable-Impls]
.Embeddable Implementations
--
[.sub-index#TimelockControllerComponent-Embeddable-Impls-TimelockImpl]
.TimelockImpl

* xref:#TimelockControllerComponent-is_operation[`++is_operation(self, id)++`]
* xref:#TimelockControllerComponent-is_operation_pending[`++is_operation_pending(self, id)++`]
* xref:#TimelockControllerComponent-is_operation_ready[`++is_operation_ready(self, id)++`]
* xref:#TimelockControllerComponent-is_operation_done[`++is_operation_done(self, id)++`]
* xref:#TimelockControllerComponent-get_timestamp[`++get_timestamp(self, id)++`]
* xref:#TimelockControllerComponent-get_operation_state[`++get_operation_state(self, id)++`]
* xref:#TimelockControllerComponent-get_min_delay[`++get_min_delay(self)++`]
* xref:#TimelockControllerComponent-hash_operation[`++hash_operation(self, call, predecessor, salt)++`]
* xref:#TimelockControllerComponent-hash_operation_batch[`++hash_operation_batch(self, calls, predecessor, salt)++`]
* xref:#TimelockControllerComponent-schedule[`++schedule(self, call, predecessor, salt, delay)++`]
* xref:#TimelockControllerComponent-schedule_batch[`++schedule_batch(self, calls, predecessor, salt, delay)++`]
* xref:#TimelockControllerComponent-cancel[`++cancel(self, id)++`]
* xref:#TimelockControllerComponent-execute[`++execute(self, call, predecessor, salt)++`]
* xref:#TimelockControllerComponent-execute_batch[`++execute_batch(self, calls, predecessor, salt)++`]
* xref:#TimelockControllerComponent-update_delay[`++update_delay(self, new_delay)++`]

.SRC5Impl
* xref:api/introspection.adoc#ISRC5-supports_interface[`supports_interface(self, interface_id: felt252)`]

.AccessControlImpl
* xref:api/access.adoc#IAccessControl-has_role[`++has_role(self, role, account)++`]
* xref:api/access.adoc#IAccessControl-get_role_admin[`++get_role_admin(self, role)++`]
* xref:api/access.adoc#IAccessControl-grant_role[`++grant_role(self, role, account)++`]
* xref:api/access.adoc#IAccessControl-revoke_role[`++revoke_role(self, role, account)++`]
* xref:api/access.adoc#IAccessControl-renounce_role[`++renounce_role(self, role, account)++`]

.AccessControlCamelImpl
* xref:api/access.adoc#IAccessControl-hasRole[`++hasRole(self, role, account)++`]
* xref:api/access.adoc#IAccessControl-getRoleAdmin[`++getRoleAdmin(self, role)++`]
* xref:api/access.adoc#IAccessControl-grantRole[`++grantRole(self, role, account)++`]
* xref:api/access.adoc#IAccessControl-revokeRole[`++revokeRole(self, role, account)++`]
* xref:api/access.adoc#IAccessControl-renounceRole[`++renounceRole(self, role, account)++`]
--

[.contract-index]
.Internal Implementations
--
.InternalImpl

* xref:#TimelockControllerComponent-initializer[`++initializer(self, min_delay, proposers, executors, admin)++`]
* xref:#TimelockControllerComponent-assert_only_role[`++assert_only_role(self, role)++`]
* xref:#TimelockControllerComponent-assert_only_role_or_open_role[`++assert_only_role_or_open_role(self, role)++`]
* xref:#TimelockControllerComponent-assert_only_self[`++assert_only_self(self)++`]
* xref:#TimelockControllerComponent-_before_call[`++_before_call(self, id, predecessor)++`]
* xref:#TimelockControllerComponent-_after_call[`++_after_call(self, id)++`]
* xref:#TimelockControllerComponent-_schedule[`++_schedule(self, id, delay)++`]
* xref:#TimelockControllerComponent-_execute[`++_execute(self, call)++`]
--

[.contract-index]
.Events
--
* xref:#TimelockControllerComponent-CallScheduled[`++CallScheduled(id, index, call, predecessor, delay)++`]
* xref:#TimelockControllerComponent-CallExecuted[`++CallExecuted(id, index, call)++`]
* xref:#TimelockControllerComponent-CallSalt[`++CallSalt(id, salt)++`]
* xref:#TimelockControllerComponent-CallCancelled[`++CallCancelled(id)++`]
* xref:#TimelockControllerComponent-MinDelayChanged[`++MinDelayChanged(old_duration, new_duration)++`]
--

[#TimelockControllerComponent-Functions]
==== Embeddable functions

[.contract-item]
[[TimelockControllerComponent-is_operation]]
==== `[.contract-item-name]#++is_operation++#++(self: @ContractState, id: felt252) → bool++` [.item-kind]#external#

Returns whether `id` corresponds to a registered operation.
This includes the OperationStates: `Waiting`, `Ready`, and `Done`.

[.contract-item]
[[TimelockControllerComponent-is_operation_pending]]
==== `[.contract-item-name]#++is_operation_pending++#++(self: @ContractState, id: felt252) → bool++` [.item-kind]#external#

Returns whether the `id` OperationState is pending or not.
Note that a pending operation may be either `Waiting` or `Ready`.

[.contract-item]
[[TimelockControllerComponent-is_operation_ready]]
==== `[.contract-item-name]#++is_operation_ready++#++(self: @ContractState, id: felt252) → bool++` [.item-kind]#external#

Returns whether the `id` OperationState is `Ready` or not.

[.contract-item]
[[TimelockControllerComponent-is_operation_done]]
==== `[.contract-item-name]#++is_operation_done++#++(self: @ContractState, id: felt252) → bool++` [.item-kind]#external#

Returns whether the `id` OperationState is `Done` or not.

[.contract-item]
[[TimelockControllerComponent-get_timestamp]]
==== `[.contract-item-name]#++get_timestamp++#++(self: @ContractState, id: felt252) → u64++` [.item-kind]#external#

Returns the timestamp at which `id` becomes `Ready`.

NOTE: `0` means the OperationState is `Unset` and `1` means the OperationState
is `Done`.

[.contract-item]
[[TimelockControllerComponent-get_operation_state]]
==== `[.contract-item-name]#++get_operation_state++#++(self: @ContractState, id: felt252) → OperationState++` [.item-kind]#external#

Returns the current state of the operation with the given `id`.

The possible states are:

- `Unset`: the operation has not been scheduled or has been canceled.
- `Waiting`: the operation has been scheduled and is pending the scheduled delay.
- `Ready`: the timer has expired, and the operation is eligible for execution.
- `Done`: the operation has been executed.

[.contract-item]
[[TimelockControllerComponent-get_min_delay]]
==== `[.contract-item-name]#++get_min_delay++#++(self: @ContractState) → u64++` [.item-kind]#external#

Returns the minimum delay in seconds for an operation to become valid.
This value can be changed by executing an operation that calls `update_delay`.

[.contract-item]
[[TimelockControllerComponent-hash_operation]]
==== `[.contract-item-name]#++hash_operation++#++(self: @ContractState, call: Call, predecessor: felt252, salt: felt252)++` [.item-kind]#external#

Returns the identifier of an operation containing a single transaction.

[.contract-item]
[[TimelockControllerComponent-hash_operation_batch]]
==== `[.contract-item-name]#++hash_operation_batch++#++(self: @ContractState, calls: Span<Call>, predecessor: felt252, salt: felt252)++` [.item-kind]#external#

Returns the identifier of an operation containing a batch of transactions.

[.contract-item]
[[TimelockControllerComponent-schedule]]
==== `[.contract-item-name]#++schedule++#++(ref self: ContractState, call: Call, predecessor: felt252, salt: felt252, delay: u64)++` [.item-kind]#external#

Schedule an operation containing a single transaction.

Requirements:

- The caller must have the `PROPOSER_ROLE` role.
- The proposal must not already exist.
- `delay` must be greater than or equal to the min delay.

Emits {TimelockComponent-CallScheduled} event.
Emits {TimelockComponent-CallSalt} event if `salt` is not zero.

[.contract-item]
[[TimelockControllerComponent-schedule_batch]]
==== `[.contract-item-name]#++schedule_batch++#++(ref self: ContractState, calls: Span<Call>, predecessor: felt252, salt: felt252, delay: u64)++` [.item-kind]#external#

Schedule an operation containing a batch of transactions.

Requirements:

- The caller must have the `PROPOSER_ROLE` role.
- The proposal must not already exist.
- `delay` must be greater than or equal to the min delay.

Emits one {TimelockComponent-CallScheduled} event for each transaction in the batch.
Emits {TimelockComponent-CallSalt} event if `salt` is not zero.

[.contract-item]
[[TimelockControllerComponent-cancel]]
==== `[.contract-item-name]#++cancel++#++(ref self: ContractState, id: felt252)++` [.item-kind]#external#

Cancels an operation. A canceled operation returns to `Unset` OperationState.

Requirements:

- The caller must have the `CANCELLER_ROLE` role.
- `id` must be a pending operation.

Emits a {TimelockComponent-CallCancelled} event.

[.contract-item]
[[TimelockControllerComponent-execute]]
==== `[.contract-item-name]#++execute++#++(ref self: ContractState, call: Call, predecessor: felt252, salt: felt252)++` [.item-kind]#external#

Execute a (Ready) operation containing a single Call.

Requirements:

- Caller must have `EXECUTOR_ROLE`.
- `id` must be in Ready OperationState.
- `predecessor` must either be `0` or in Done OperationState.

Emits a {TimelockComponent-CallExecuted} event.

NOTE: This function can reenter, but it doesn't pose a risk because <<TimelockControllerComponent-_after_call>>
checks that the proposal is pending, thus any modifications to the operation during
reentrancy should be caught.

[.contract-item]
[[TimelockControllerComponent-execute_batch]]
==== `[.contract-item-name]#++execute_batch++#++(ref self: ContractState, calls: Span<Call>, predecessor: felt252, salt: felt252)++` [.item-kind]#external#

Execute a (Ready) operation containing a batch of Calls.

Requirements:

- Caller must have `EXECUTOR_ROLE`.
- `id` must be in Ready OperationState.
- `predecessor` must either be `0` or in Done OperationState.

Emits a {TimelockComponent-CallExecuted} event for each Call.

NOTE: This function can reenter, but it doesn't pose a risk because `_after_call`
checks that the proposal is pending, thus any modifications to the operation during
reentrancy should be caught.

[.contract-item]
[[TimelockControllerComponent-update_delay]]
==== `[.contract-item-name]#++update_delay++#++(ref self: ContractState, new_delay: u64)++` [.item-kind]#external#

Changes the minimum timelock duration for future operations.

Requirements:

- The caller must be the timelock itself. This can only be achieved by scheduling
and later executing an operation where the timelock is the target and the data
is the serialized call to this function.

Emits a {TimelockComponent-MinDelayChanged} event.

[#TimelockControllerComponent-Internal-Functions]
==== Internal functions

[.contract-item]
[[TimelockControllerComponent-initializer]]
==== `[.contract-item-name]#++initializer++#++(ref self: ContractState, min_delay: u64, proposers: Span<ContractAddress>, executors: Span<ContractState>, admin: ContractAddress)++` [.item-kind]#internal#

Initializes the contract by registering support for SRC5 and AccessControl.

This function also configures the contract with the following parameters:

- `min_delay`: initial minimum delay in seconds for operations.
- `proposers`: accounts to be granted proposer and canceller roles.
- `executors`: accounts to be granted executor role.
- `admin`: optional account to be granted admin role; disable with zero address.

WARNING: The optional admin can aid with initial configuration of roles after deployment
without being subject to delay, but this role should be subsequently renounced in favor of
administration through timelocked proposals.

Emits two {IAccessControl-RoleGranted} events for each account in `proposers` with `PROPOSER_ROLE` and
`CANCELLER_ROLE` roles.

Emits a {IAccessControl-RoleGranted} event for each account in `executors` with `EXECUTOR_ROLE` role.

May emit a {IAccessControl-RoleGranted} event for `admin` with `DEFAULT_ADMIN_ROLE` role (if `admin` is
not zero).

Emits {TimelockComponent-MinDelayChanged} event.

[.contract-item]
[[TimelockControllerComponent-assert_only_role]]
==== `[.contract-item-name]#++assert_only_role++#++(self: @ContractState, role: felt252)++` [.item-kind]#internal#

Validates that the caller has the given `role`.
Otherwise it panics.

[.contract-item]
[[TimelockControllerComponent-assert_only_role_or_open_role]]
==== `[.contract-item-name]#++assert_only_role_or_open_role++#++(self: @ContractState, role: felt252)++` [.item-kind]#internal#

Validates that the caller has the given `role`.
If `role` is granted to the zero address, then this is considered an open role which allows anyone to be the caller.

[.contract-item]
[[TimelockControllerComponent-assert_only_self]]
==== `[.contract-item-name]#++assert_only_self++#++(self: @ContractState)++` [.item-kind]#internal#

Validates that the caller is the timelock contract itself.
Otherwise it panics.

[.contract-item]
[[TimelockControllerComponent-_before_call]]
==== `[.contract-item-name]#++_before_call++#++(self: @ContractState, id: felt252, predecessor: felt252)++` [.item-kind]#internal#

Private function that checks before execution of an operation's calls.

Requirements:

- `id` must be in the `Ready` OperationState.
- `predecessor` must either be zero or be in the `Done` OperationState.

[.contract-item]
[[TimelockControllerComponent-_after_call]]
==== `[.contract-item-name]#++_after_call++#++(self: @ContractState, id: felt252)++` [.item-kind]#internal#

Private function that checks after execution of an operation's calls
and sets the OperationState of `id` to `Done`.

Requirements:

- `id` must be in the Ready OperationState.

[.contract-item]
[[TimelockControllerComponent-_schedule]]
==== `[.contract-item-name]#++_schedule++#++(ref self: ContractState, id: felt252, delay: u64)++` [.item-kind]#internal#

Private function that schedules an operation that is to become valid after a given `delay`.

[.contract-item]
[[TimelockControllerComponent-_execute]]
==== `[.contract-item-name]#++_execute++#++(ref self: ContractState, call: Call)++` [.item-kind]#internal#

Private function that executes an operation's calls.

[#TimelockControllerComponent-Events]
==== Events

[.contract-item]
[[TimelockControllerComponent-CallScheduled]]
==== `[.contract-item-name]#++CallScheduled++#++(id: felt252, index: felt252, call: Call, predecessor: felt252, delay: u64)++` [.item-kind]#event#

Emitted when `call` is scheduled as part of operation `id`.

[.contract-item]
[[TimelockControllerComponent-CallExecuted]]
==== `[.contract-item-name]#++CallExecuted++#++(id: felt252, index: felt252, call: Call)++` [.item-kind]#event#

Emitted when `call` is performed as part of operation `id`.

[.contract-item]
[[TimelockControllerComponent-CallSalt]]
==== `[.contract-item-name]#++CallSalt++#++(id: felt252, salt: felt252)++` [.item-kind]#event#

Emitted when a new proposal is scheduled with non-zero salt.

[.contract-item]
[[TimelockControllerComponent-CallCancelled]]
==== `[.contract-item-name]#++CallCancelled++#++(id: felt252)++` [.item-kind]#event#

Emitted when operation `id` is cancelled.

[.contract-item]
[[TimelockControllerComponent-MinDelayChanged]]
==== `[.contract-item-name]#++MinDelayChanged++#++(old_duration: u64, new_duration: u64)++` [.item-kind]#event#

Emitted when the minimum delay for future operations is modified.

== Votes

The `VotesComponent` provides a flexible system for tracking and delegating voting power. This system allows users to delegate their voting power to other addresses, enabling more active participation in governance.

[.contract]
[[IVotes]]
=== `++IVotes++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/governance/src/votes/interface.cairo[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_governance::votes::interface::IVotes;
```

Common interface for Votes-enabled contracts.

[.contract-index]
.Functions
--
* xref:#IVotes-get_votes[`++get_votes(account)++`]
* xref:#IVotes-get_past_votes[`++get_past_votes(account, timepoint)++`]
* xref:#IVotes-get_past_total_supply[`++get_past_total_supply(timepoint)++`]
* xref:#IVotes-delegates[`++delegates(account)++`]
* xref:#IVotes-delegate[`++delegate(delegatee)++`]
* xref:#IVotes-delegate_by_sig[`++delegate_by_sig(delegator, delegatee, nonce, expiry, signature)++`]
--

[#IVotes-Functions]
==== Functions

[.contract-item]
[[IVotes-get_votes]]
==== `[.contract-item-name]#++get_votes++#++(account: ContractAddress) → u256++` [.item-kind]#external#

Returns the current amount of votes that `account` has.

[.contract-item]
[[IVotes-get_past_votes]]
==== `[.contract-item-name]#++get_past_votes++#++(account: ContractAddress, timepoint: u64) → u256++` [.item-kind]#external#

Returns the amount of votes that `account` had at a specific moment in the past.

[.contract-item]
[[IVotes-get_past_total_supply]]
==== `[.contract-item-name]#++get_past_total_supply++#++(timepoint: u64) → u256++` [.item-kind]#external#

Returns the total supply of votes available at a specific moment in the past.

NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.
Votes that have not been delegated are still part of total supply, even though they would not participate in a
vote.

[.contract-item]
[[IVotes-delegates]]
==== `[.contract-item-name]#++delegates++#++(account: ContractAddress) → ContractAddress++` [.item-kind]#external#

Returns the delegate that `account` has chosen.

[.contract-item]
[[IVotes-delegate]]
==== `[.contract-item-name]#++delegate++#++(delegatee: ContractAddress)++` [.item-kind]#external#

Delegates votes from the sender to `delegatee`.

[.contract-item]
[[IVotes-delegate_by_sig]]
==== `[.contract-item-name]#++delegate_by_sig++#++(delegator: ContractAddress, delegatee: ContractAddress, nonce: felt252, expiry: u64, signature: Span<felt252>)++` [.item-kind]#external#

Delegates votes from `delegator` to `delegatee` through a {SNIP-12} message signature validation.

[.contract]
[[VotesComponent]]
=== `++VotesComponent++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/governance/src/votes/votes.cairo[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_governance::votes::VotesComponent;
```
Component that implements the {IVotes} interface and provides a flexible system for tracking and delegating voting power.

By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.

NOTE: When using this module, your contract must implement the {VotingUnitsTrait}. For convenience, this is done automatically for `ERC20` and `ERC721` tokens.

[.contract-index]
.Voting Units Trait Implementations
--
.ERC20VotesImpl
* xref:#VotesComponent-ERC20VotesImpl-get_voting_units[`++get_voting_units(self, account)++`]

.ERC721VotesImpl
* xref:#VotesComponent-ERC721VotesImpl-get_voting_units[`++get_voting_units(self, account)++`]
--

[.contract-index#VotesComponent-Embeddable-Impls]
.Embeddable Implementations
--
[.sub-index#VotesComponent-Embeddable-Impls-VotesImpl]
.VotesImpl
* xref:#VotesComponent-get_votes[`++get_votes(self, account)++`]
* xref:#VotesComponent-get_past_votes[`++get_past_votes(self, account, timepoint)++`]
* xref:#VotesComponent-get_past_total_supply[`++get_past_total_supply(self, timepoint)++`]
* xref:#VotesComponent-delegates[`++delegates(self, account)++`]
* xref:#VotesComponent-delegate[`++delegate(self, delegatee)++`]
* xref:#VotesComponent-delegate_by_sig[`++delegate_by_sig(self, delegator, delegatee, nonce, expiry, signature)++`]
--

[.contract-index]
.Internal implementations
--
.InternalImpl
* xref:#VotesComponent-get_total_supply[`++get_total_supply(self)++`]
* xref:#VotesComponent-move_delegate_votes[`++move_delegate_votes(self, from, to, amount)++`]
* xref:#VotesComponent-transfer_voting_units[`++transfer_voting_units(self, from, to, amount)++`]
* xref:#VotesComponent-num_checkpoints[`++num_checkpoints(self, account)++`]
* xref:#VotesComponent-checkpoints[`++checkpoints(self, account, pos)++`]
* xref:#VotesComponent-_delegate[`++_delegate(self, account, delegatee)++`]
--

[.contract-index]
.Events
--
* xref:#VotesComponent-DelegateChanged[`++DelegateChanged(delegator, from_delegate, to_delegate)++`]
* xref:#VotesComponent-DelegateVotesChanged[`++DelegateVotesChanged(delegate, previous_votes, new_votes)++`]
--

[#VotesComponent-ERC20VotesImpl]
==== ERC20VotesImpl

[.contract-item]
[[VotesComponent-ERC20VotesImpl-get_voting_units]]
==== `[.contract-item-name]#++get_voting_units++#++(self: @ContractState, account: ContractAddress) → u256++` [.item-kind]#internal#

Returns the number of voting units for a given account.

This implementation is specific to ERC20 tokens, where the balance
of tokens directly represents the number of voting units.

NOTE: This implementation will work out of the box if the ERC20 component
is implemented in the final contract.

WARNING: This implementation assumes tokens map to voting units 1:1.
Any deviation from this formula when transferring voting units (e.g. by using hooks)
may compromise the internal vote accounting.

[#VotesComponent-ERC721VotesImpl]
==== ERC721VotesImpl

[.contract-item]
[[VotesComponent-ERC721VotesImpl-get_voting_units]]
==== `[.contract-item-name]#++get_voting_units++#++(self: @ContractState, account: ContractAddress) → u256++` [.item-kind]#internal#

Returns the number of voting units for a given account.

This implementation is specific to ERC721 tokens, where each token
represents one voting unit. The function returns the balance of
ERC721 tokens for the specified account.

NOTE: This implementation will work out of the box if the ERC721 component
is implemented in the final contract.

WARNING: This implementation assumes tokens map to voting units 1:1.
Any deviation from this formula when transferring voting units (e.g. by using hooks)
may compromise the internal vote accounting.

[#VotesComponent-Functions]
==== Embeddable functions

[.contract-item]
[[VotesComponent-get_votes]]
==== `[.contract-item-name]#++get_votes++#++(self: @ContractState, account: ContractAddress) → u256++` [.item-kind]#external#

Returns the current amount of votes that `account` has.

[.contract-item]
[[VotesComponent-get_past_votes]]
==== `[.contract-item-name]#++get_past_votes++#++(self: @ContractState, account: ContractAddress, timepoint: u64) → u256++` [.item-kind]#external#

Returns the amount of votes that `account` had at a specific moment in the past.

Requirements:

- `timepoint` must be in the past.

[.contract-item]
[[VotesComponent-get_past_total_supply]]
==== `[.contract-item-name]#++get_past_total_supply++#++(self: @ContractState, timepoint: u64) → u256++` [.item-kind]#external#

Returns the total supply of votes available at a specific moment in the past.

NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.
Votes that have not been delegated are still part of total supply, even though they would not participate in a
vote.

Requirements:

- `timepoint` must be in the past.

[.contract-item]
[[VotesComponent-delegates]]
==== `[.contract-item-name]#++delegates++#++(self: @ContractState, account: ContractAddress) → ContractAddress++` [.item-kind]#external#

Returns the delegate that `account` has chosen.

[.contract-item]
[[VotesComponent-delegate]]
==== `[.contract-item-name]#++delegate++#++(ref self: ContractState, delegatee: ContractAddress)++` [.item-kind]#external#

Delegates votes from the sender to `delegatee`.

Emits a {VotesComponent-DelegateChanged} event.

May emit one or two {VotesComponent-DelegateVotesChanged} events.

[.contract-item]
[[VotesComponent-delegate_by_sig]]
==== `[.contract-item-name]#++delegate_by_sig++#++(ref self: ContractState, delegator: ContractAddress, delegatee: ContractAddress, nonce: felt252, expiry: u64, signature: Span<felt252>)++` [.item-kind]#external#

Delegates votes from `delegator` to `delegatee` through a {SNIP-12} message signature validation.

Requirements:

- `expiry` must not be in the past.
- `nonce` must match the account's current nonce.
- `delegator` must implement `SRC6::is_valid_signature`.
- `signature` should be valid for the message hash.

Emits a {VotesComponent-DelegateChanged} event.

May emit one or two {VotesComponent-DelegateVotesChanged} events.

[#VotesComponent-Internal-functions]
==== Internal functions

[.contract-item]
[[VotesComponent-get_total_supply]]
==== `[.contract-item-name]#++get_total_supply++#++(self: @ContractState) → u256++` [.item-kind]#internal#

Returns the current total supply of votes.

[.contract-item]
[[VotesComponent-move_delegate_votes]]
==== `[.contract-item-name]#++move_delegate_votes++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, amount: u256)++` [.item-kind]#internal#

Moves delegated votes from one delegate to another.

May emit one or two {VotesComponent-DelegateVotesChanged} events.

[.contract-item]
[[VotesComponent-transfer_voting_units]]
==== `[.contract-item-name]#++transfer_voting_units++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, amount: u256)++` [.item-kind]#internal#

Transfers, mints, or burns voting units.

To register a mint, `from` should be zero. To register a burn, `to`
should be zero. Total supply of voting units will be adjusted with mints and burns.

WARNING: If voting units are based on an underlying transferable asset (like a token), you must call this function every time the asset is transferred to keep the internal voting power accounting in sync. For ERC20 and ERC721 tokens, this is typically handled using hooks.

May emit one or two {VotesComponent-DelegateVotesChanged} events.

[.contract-item]
[[VotesComponent-num_checkpoints]]
==== `[.contract-item-name]#++num_checkpoints++#++(self: @ContractState, account: ContractAddress) → u64++` [.item-kind]#internal#

Returns the number of checkpoints for `account`.

[.contract-item]
[[VotesComponent-checkpoints]]
==== `[.contract-item-name]#++checkpoints++#++(self: @ContractState, account: ContractAddress, pos: u64) → Checkpoint++` [.item-kind]#internal#

Returns the `pos`-th checkpoint for `account`.

[.contract-item]
[[VotesComponent-_delegate]]
==== `[.contract-item-name]#++_delegate++#++(ref self: ContractState, account: ContractAddress, delegatee: ContractAddress)++` [.item-kind]#internal#

Delegates all of ``account``'s voting units to `delegatee`.

Emits a {VotesComponent-DelegateChanged} event.

May emit one or two {VotesComponent-DelegateVotesChanged} events.

[#VotesComponent-Events]
==== Events

[.contract-item]
[[VotesComponent-DelegateChanged]]
==== `[.contract-item-name]#++DelegateChanged++#++(delegator: ContractAddress, from_delegate: ContractAddress, to_delegate: ContractAddress)++` [.item-kind]#event#

Emitted when an account changes their delegate.

[.contract-item]
[[VotesComponent-DelegateVotesChanged]]
==== `[.contract-item-name]#++DelegateVotesChanged++#++(delegate: ContractAddress, previous_votes: u256, new_votes: u256)++` [.item-kind]#event#

Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.

[.contract]
[[VotingUnitsTrait]]
=== `++VotingUnitsTrait++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/governance/src/votes/votes.cairo[{github-icon},role=heading-link]

```cairo
pub trait VotingUnitsTrait<TState> {
    fn get_voting_units(self: @TState, account: ContractAddress) -> u256;
}
```

A trait that must be implemented when integrating {VotesComponent} into a contract. It offers a mechanism to retrieve the number of voting units for a given account at the current time.

[.contract-index]
.Functions
--
* xref:#VotingUnitsTrait-get_voting_units[`++get_voting_units(self, account)++`]
--

[#VotingUnitsTrait-Functions]
==== Functions

[.contract-item]
[[VotingUnitsTrait-get_voting_units]]
==== `[.contract-item-name]#++get_voting_units++#++(self: @TState, account: ContractAddress) → u256++` [.item-kind]#external#

Returns the number of voting units for a given account. For ERC20, this is typically the token balance. For ERC721, this is typically the number of tokens owned.

WARNING: While any formula can be used as a measure of voting units, the internal vote accounting of the contract may be
compromised if voting units are transferred in any external flow by following a different formula. +
For example, when implementing the hook for ERC20, the number of voting units transferred should match the formula given by the
`get_voting_units` implementation.// llmstxt-short-description: Describes the introspection mechanisms of the library

:eip165: https://eips.ethereum.org/EIPS/eip-165[EIP165]
:src5: https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md[SRC5]
:src5-rs: https://github.com/ericnordelo/src5-rs[src5-rs]
:src5-component: xref:api/introspection.adoc#SRC5Component[SRC5Component]

= Introspection

To smooth interoperability, often standards require smart contracts to implement https://en.wikipedia.org/wiki/Type_introspection[introspection mechanisms].

In Ethereum, the {eip165} standard defines how contracts should declare
their support for a given interface, and how other contracts may query this support.

Starknet offers a similar mechanism for interface introspection defined by the {src5} standard.

== SRC5

Similar to its Ethereum counterpart, the {src5} standard requires contracts to implement the `supports_interface` function,
which can be used by others to query if a given interface is supported.

=== Usage

To expose this functionality, the contract must implement the {src5-component}, which defines the `supports_interface` function.
Here is an example contract:

[,cairo]
----
#[starknet::contract]
mod MyContract {
    use openzeppelin_introspection::src5::SRC5Component;

    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;
    impl SRC5InternalImpl = SRC5Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState) {
        self.src5.register_interface(selector!("some_interface"));
    }
}
----

=== Interface

[,cairo]
----
#[starknet::interface]
pub trait ISRC5 {
    /// Query if a contract implements an interface.
    /// Receives the interface identifier as specified in SRC-5.
    /// Returns `true` if the contract implements `interface_id`, `false` otherwise.
    fn supports_interface(interface_id: felt252) -> bool;
}
----

== Computing the interface ID

The interface ID, as specified in the standard, is the https://en.wikipedia.org/wiki/Exclusive_or[XOR] of all the
https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md#extended-function-selector[Extended Function Selectors]
of the interface. We strongly advise reading the SNIP to understand the specifics of computing these
extended function selectors. There are tools such as {src5-rs} that can help with this process.

== Registering interfaces

For a contract to declare its support for a given interface, we recommend using the SRC5 component to register support upon contract deployment through a constructor either directly or indirectly (as an initializer) like this:

[,cairo]
----
#[starknet::contract]
mod MyContract {
    use openzeppelin_account::interface;
    use openzeppelin_introspection::src5::SRC5Component;

    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;
    impl InternalImpl = SRC5Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState) {
        // Register the contract's support for the ISRC6 interface
        self.src5.register_interface(interface::ISRC6_ID);
    }

    (...)
}
----

== Querying interfaces

Use the `supports_interface` function to query a contract's support for a given interface.

[,cairo]
----
#[starknet::contract]
mod MyContract {
    use openzeppelin_account::interface;
    use openzeppelin_introspection::interface::ISRC5DispatcherTrait;
    use openzeppelin_introspection::interface::ISRC5Dispatcher;
    use starknet::ContractAddress;

    #[storage]
    struct Storage {}

    #[external(v0)]
    fn query_is_account(self: @ContractState, target: ContractAddress) -> bool {
        let dispatcher = ISRC5Dispatcher { contract_address: target };
        dispatcher.supports_interface(interface::ISRC6_ID)
    }
}
----

TIP: If you are unsure whether a contract implements SRC5 or not, you can follow the process described in
https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md#how-to-detect-if-a-contract-implements-src-5[here].
// llmstxt-short-description: Guide describing the process of migrating from ERC165 to SRC5

= Migrating ERC165 to SRC5

:eip165: https://eips.ethereum.org/EIPS/eip-165[EIP-165]
:snip5: https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md[SNIP-5]
:dual-interface-discussion: https://github.com/OpenZeppelin/cairo-contracts/discussions/640[Dual Introspection Detection]
:shamans-proposal: https://community.starknet.io/t/starknet-standard-interface-detection/92664[Starknet Shamans proposal]

In the smart contract ecosystem, having the ability to query if a contract supports a given interface is an extremely important feature.
The initial introspection design for Contracts for Cairo before version v0.7.0 followed Ethereum's {eip165}.
Since the Cairo language evolved introducing native types, we needed an introspection solution tailored to the Cairo ecosystem: the {snip5} standard.
SNIP-5 allows interface ID calculations to use Cairo types and the Starknet keccak (`sn_keccak`) function.
For more information on the decision, see the {shamans-proposal} or the {dual-interface-discussion} discussion.

== How to migrate

Migrating from ERC165 to SRC5 involves four major steps:

1. Integrate SRC5 into the contract.
2. Register SRC5 IDs.
3. Add a `migrate` function to apply introspection changes.
4. Upgrade the contract and call `migrate`.

The following guide will go through the steps with examples.

=== Component integration

:src5-component: xref:/api/introspection.adoc#SRC5Component[SRC5Component]
:initializable-component: xref:/api/security.adoc#InitializableComponent[InitializableComponent]

The first step is to integrate the necessary components into the new contract.
The contract should include the new introspection mechanism, {src5-component}.
It should also include the {initializable-component} which will be used in the `migrate` function.
Here's the setup:

[,cairo]
----
#[starknet::contract]
mod MigratingContract {
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_security::initializable::InitializableComponent;

    component!(path: SRC5Component, storage: src5, event: SRC5Event);
    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;
    impl SRC5InternalImpl = SRC5Component::InternalImpl<ContractState>;

    // Initializable
    impl InitializableInternalImpl = InitializableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        src5: SRC5Component::Storage,
        #[substorage(v0)]
        initializable: InitializableComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        SRC5Event: SRC5Component::Event,
        #[flat]
        InitializableEvent: InitializableComponent::Event
    }
}
----

=== Interface registration

:ierc721: xref:/api/erc721.adoc#IERC721[IERC721]
:ierc721-metadata: xref:/api/erc721.adoc#IERC721Metadata[IERC721Metadata]
:register_interface: xref:/api/introspection.adoc#SRC5Component-register_interface[register_interface]

To successfully migrate ERC165 to SRC5, the contract needs to register the interface IDs that the contract supports with SRC5.

For this example, let's say that this contract supports the {ierc721} and {ierc721-metadata} interfaces.
The contract should implement an `InternalImpl` and add a function to register those interfaces like this:

[,cairo]
----
#[starknet::contract]
mod MigratingContract {
    use openzeppelin_token::erc721::interface::{IERC721_ID, IERC721_METADATA_ID};

    (...)

    #[generate_trait]
    impl InternalImpl of InternalTrait {
        // Register SRC5 interfaces
        fn register_src5_interfaces(ref self: ContractState) {
            self.src5.register_interface(IERC721_ID);
            self.src5.register_interface(IERC721_METADATA_ID);
        }
    }
}
----

Since the new contract integrates `SRC5Component`, it can leverage SRC5's {register_interface} function to register the supported interfaces.

=== Migration initializer

:access-control: xref:/access.adoc[Access Control]

Next, the contract should define and expose a migration function that will invoke the `register_src5_interfaces` function.
Since the `migrate` function will be publicly callable, it should include some sort of {access-control} so that only permitted addresses can execute the migration.
Finally, `migrate` should include a reinitialization check to ensure that it cannot be called more than once.

WARNING: If the original contract implemented `Initializable` at any point and called the `initialize` method, the `InitializableComponent` will not be usable at this time.
Instead, the contract can take inspiration from `InitializableComponent` and create its own initialization mechanism.

[,cairo]
----
#[starknet::contract]
mod MigratingContract {
    (...)

    #[external(v0)]
    fn migrate(ref self: ContractState) {
        // WARNING: Missing Access Control mechanism. Make sure to add one

        // WARNING: If the contract ever implemented `Initializable` in the past,
        // this will not work. Make sure to create a new initialization mechanism
        self.initializable.initialize();

        // Register SRC5 interfaces
        self.register_src5_interfaces();
    }
}
----

=== Execute migration

Once the new contract is prepared for migration and *rigorously tested*, all that's left is to migrate!
Simply upgrade the contract and then call `migrate`.
// llmstxt-short-description: API of the Introspection module, including the SRC5 component and the ISRC5 interface

:github-icon: pass:[<svg class="icon"><use href="#github-icon"/></svg>]
:snip5: https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md[SNIP-5]
:inner-src5: xref:api/introspection.adoc#ISRC5[SRC5 ID]

= Introspection

This crate handles https://en.wikipedia.org/wiki/Type_introspection[type introspection] of contracts. In other words, it examines which functions can be called on a given contract. This is referred to as the contract's interface.

== Core

[.contract]
[[ISRC5]]
=== `++ISRC5++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/introspection/src/interface.cairo#L7[{github-icon},role=heading-link]

```cairo
use openzeppelin_introspection::interface::ISRC5;
```

Interface of the SRC5 Introspection Standard as defined in {snip5}.

[.contract-index]
.{inner-src5}
--
0x3f918d17e5ee77373b56385708f855659a07f75997f365cf87748628532a055
--

[.contract-index]
.Functions
--
* xref:#ISRC5-supports_interface[`++supports_interface(interface_id)++`]
--

[#ISRC5-Functions]
==== Functions

[.contract-item]
[[ISRC5-supports_interface]]
==== `[.contract-item-name]#++supports_interface++#++(interface_id: felt252) → bool++` [.item-kind]#external#

Checks whether the contract implements the given interface.

TIP: Check xref:introspection#computing_the_interface_id[Computing the Interface ID] for more information
on how to compute this ID.

[.contract]
[[SRC5Component]]
=== `++SRC5Component++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/introspection/src/src5.cairo[{github-icon},role=heading-link]

```cairo
use openzeppelin_introspection::src5::SRC5Component;
```

SRC5 component extending xref:ISRC5[`ISRC5`].

[.contract-index#SRC5Component-Embeddable-Impls]
.Embeddable Implementations
--
[.sub-index#SRC5Component-Embeddable-Impls-SRC5Impl]
.SRC5Impl

* xref:#SRC5Component-supports_interface[`++supports_interface(self, interface_id)++`]
--

[.contract-index]
.Internal Implementations
--
.InternalImpl

* xref:#SRC5Component-register_interface[`++register_interface(self, interface_id)++`]
* xref:#SRC5Component-deregister_interface[`++deregister_interface(self, interface_id)++`]
--

[#SRC5Component-Embeddable-Functions]
==== Embeddable functions

[.contract-item]
[[SRC5Component-supports_interface]]
==== `[.contract-item-name]#++supports_interface++#++(self: @ContractState, interface_id: felt252) → bool++` [.item-kind]#external#

See xref:ISRC5-supports_interface[`ISRC5::supports_interface`].

[#SRC5Component-Internal-Functions]
==== Internal functions

[.contract-item]
[[SRC5Component-register_interface]]
==== `[.contract-item-name]#++register_interface++#++(ref self: ComponentState, interface_id: felt252)++` [.item-kind]#internal#

Registers support for the given `interface_id`.

[.contract-item]
[[SRC5Component-deregister_interface]]
==== `[.contract-item-name]#++deregister_interface++#++(ref self: ComponentState, interface_id: felt252)++` [.item-kind]#internal#

Deregisters support for the given `interface_id`.
// llmstxt-short-description: API of the Merkle Tree module, including mechanisms for verifying Merkle Tree proofs on-chain

:github-icon: pass:[<svg class="icon"><use href="#github-icon"/></svg>]
:strk-merkle-tree: https://github.com/ericnordelo/strk-merkle-tree[JavaScript library]
:verify: xref:#merkle_proof-verify[verify]
:verify_pedersen: xref:#merkle_proof-verify_pedersen[verify_pedersen]
:verify_poseidon: xref:#merkle_proof-verify_poseidon[verify_poseidon]
:verify_multi_proof: xref:#merkle_proof-verify_multi_proof[verify_multi_proof]
:process_multi_proof: xref:#merkle_proof-process_multi_proof[process_multi_proof]

= Merkle Tree

This crate provides a set of utilities for verifying Merkle Tree proofs on-chain. The tree and the proofs can be
generated using this {strk-merkle-tree}.

This module provides:

- `{verify}` - can prove that some value is part of a Merkle tree.

- `{verify_multi_proof}` - can prove multiple values are part of a Merkle tree.

NOTE: `openzeppelin_merkle_tree` doesn't have dependencies outside of `corelib`, and can be used in projects that are not Starknet-related.

[TIP]
====
To use it as a standalone package, you can add it in your `Scarb.toml` as follows:

`openzeppelin_merkle_tree = "1.0.0"`
====

== Modules

[.contract]
[[merkle_proof]]
=== `++merkle_proof++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/merkle_tree/src/merkle_proof.cairo[{github-icon},role=heading-link]

```cairo
use openzeppelin_merkle_tree::merkle_proof;
```

These functions deal with verification of Merkle Tree proofs.

The tree and the proofs can be generated using this {strk-merkle-tree}. You will find a quickstart guide in the readme.

WARNING: You should avoid using leaf values that are two felt252 values long prior to hashing, or use a hash function
other than the one used to hash internal nodes for hashing leaves. This is because the concatenation of a sorted pair
of internal nodes in the Merkle tree could be reinterpreted as a leaf value. The JavaScript library generates Merkle
trees that are safe against this attack out of the box.

[.contract-index]
.Functions
--
* xref:#merkle_proof-verify[`++verify<Hasher>(proof, root, leaf)++`]
* xref:#merkle_proof-verify_pedersen[`++verify_pedersen(proof, root, leaf)++`]
* xref:#merkle_proof-verify_poseidon[`++verify_poseidon(proof, root, leaf)++`]
* xref:#merkle_proof-process_proof[`++process_proof<Hasher>(proof, leaf)++`]
* xref:#merkle_proof-verify_multi_proof[`++verify_multi_proof<Hasher>(proof, proof_flags, root, leaves)++`]
* xref:#merkle_proof-process_multi_proof[`++process_multi_proof<Hasher>(proof, proof_flags, leaf)++`]
--

[#merkle_proof-Functions]
==== Functions

[.contract-item]
[[merkle_proof-verify]]
==== `[.contract-item-name]#++verify<+CommutativeHasher>++#++(proof: Span<felt252>, root: felt252, leaf: felt252) → bool++` [.item-kind]#public#

Returns true if a `leaf` can be proved to be a part of a Merkle tree defined by `root`.

For this, a `proof` must be provided, containing sibling hashes on the branch from the leaf to the root of the tree.

Each pair of leaves and each pair of pre-images are assumed to be sorted.

[NOTE]
====
This function expects a `CommutativeHasher` implementation. See xref:#hashes-CommutativeHasher[hashes::CommutativeHasher] for more information.

`{verify_pedersen}` and `{verify_poseidon}` already include the corresponding `Hasher` implementations.
====

[.contract-item]
[[merkle_proof-verify_pedersen]]
==== `[.contract-item-name]#++verify_pedersen++#++(proof: Span<felt252>, root: felt252, leaf: felt252) → bool++` [.item-kind]#public#

Version of `{verify}` using Pedersen as the hashing function.

[.contract-item]
[[merkle_proof-verify_poseidon]]
==== `[.contract-item-name]#++verify_poseidon++#++(proof: Span<felt252>, root: felt252, leaf: felt252) → bool++` [.item-kind]#public#

Version of `{verify}` using Poseidon as the hashing function.

[.contract-item]
[[merkle_proof-process_proof]]
==== `[.contract-item-name]#++process_proof<+CommutativeHasher>++#++(proof: Span<felt252>, leaf: felt252) → felt252++` [.item-kind]#public#

Returns the rebuilt hash obtained by traversing a Merkle tree up from `leaf` using `proof`.

A `proof` is valid if and only if the rebuilt hash matches the root of the tree.

When processing the proof, the pairs of leaves & pre-images are assumed to be sorted.

NOTE: This function expects a `CommutativeHasher` implementation. See xref:#hashes-CommutativeHasher[hashes::CommutativeHasher] for more information.

[.contract-item]
[[merkle_proof-verify_multi_proof]]
==== `[.contract-item-name]#++verify_multi_proof<+CommutativeHasher>++#++(proof: Span<felt252>, proof_flags: Span<bool>, root: felt252, leaves: Span<felt252>) → bool++` [.item-kind]#public#

Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined
by `root`, according to `proof` and `proof_flags` as described in `{process_multi_proof}`.

The `leaves` must be validated independently.

CAUTION: Not all Merkle trees admit multiproofs. See `{process_multi_proof}` for details.

NOTE: Consider the case where `root == proof.at(0) && leaves.len() == 0` as it will return `true`.

NOTE: This function expects a `CommutativeHasher` implementation. See xref:#hashes-CommutativeHasher[hashes::CommutativeHasher] for more information.

[.contract-item]
[[merkle_proof-process_multi_proof]]
==== `[.contract-item-name]#++process_multi_proof<+CommutativeHasher>++#++(proof: Span<felt252>, proof_flags: Span<bool>, leaves: Span<felt252>) → felt252++` [.item-kind]#public#

Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`.

The reconstruction proceeds by incrementally reconstructing all inner nodes by combining a
leaf/inner node with either another leaf/inner node or a proof sibling node, depending on
whether each `proof_flags` item is true or false respectively.

[CAUTION]
====
Not all Merkle trees admit multiproofs.
To use multiproofs, it is sufficient to ensure that:

1. The tree is complete (but not necessarily perfect).
2. The leaves to be proven are in the opposite order than they are in the tree.
(i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).
====

NOTE: The _empty set_ (i.e. the case where `proof.len() == 1 && leaves.len() == 0`) is
considered a no-op, and therefore a valid multiproof (i.e. it returns `proof.at(0)`). Consider
disallowing this case if you're not validating the leaves elsewhere.

NOTE: This function expects a `CommutativeHasher` implementation. See xref:#hashes-CommutativeHasher[hashes::CommutativeHasher] for more information.


[.contract]
[[hashes]]
=== `++hashes++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/merkle_tree/src/hashes.cairo[{github-icon},role=heading-link]

```cairo
use openzeppelin_merkle_tree::hashes;
```

:pedersen-hasher: xref:#hashes-PedersenCHasher[PedersenCHasher]
:poseidon-hasher: xref:#hashes-PoseidonCHasher[PoseidonCHasher]

Module providing the trait and default implementations for the commutative hash functions used in
xref:#merkle_proof[`merkle_proof`].

NOTE: The `{pedersen-hasher}` implementation matches the default node hashing function used in the {strk-merkle-tree}.

[.contract-index]
.Traits
--
* xref:#hashes-CommutativeHasher[`++CommutativeHasher++`]
--

[.contract-index]
.Impls
--
* xref:#hashes-PedersenCHasher[`++PedersenCHasher++`]
* xref:#hashes-PoseidonCHasher[`++PoseidonCHasher++`]
--

[#hashes-Traits]
==== Traits

[.contract-item]
[[hashes-CommutativeHasher]]
==== `[.contract-item-name]#++CommutativeHasher++#` [.item-kind]#trait#

Declares a commutative hash function with the following signature:

`commutative_hash(a: felt252, b: felt252) -> felt252;`

which computes a commutative hash of a sorted pair of felt252 values.

This is usually implemented as an extension of a non-commutative hash function, like
Pedersen or Poseidon, returning the hash of the concatenation of the two values by first
sorting them.

Frequently used when working with merkle proofs.

NOTE: The `commutative_hash` function MUST follow the invariant that `commutative_hash(a, b) == commutative_hash(b, a)`.

[#hashes-Impls]
==== Impls

[.contract-item]
[[hashes-PedersenCHasher]]
==== `[.contract-item-name]#++PedersenCHasher++#` [.item-kind]#impl#

Implementation of the `CommutativeHasher` trait which computes the Pedersen hash of chaining the two input values
with the len (2), sorting the pair first.

[.contract-item]
[[hashes-PoseidonCHasher]]
==== `[.contract-item-name]#++PoseidonCHasher++#` [.item-kind]#impl#

Implementation of the `CommutativeHasher` trait which computes the Poseidon hash of the concatenation of two values, sorting the pair first.
// llmstxt-short-description: Describes the security components of the library and their usage

= Security

The following documentation provides context, reasoning, and examples of modules found under `openzeppelin_security`.

CAUTION: Expect these modules to evolve.

== Initializable

The xref:api/security.adoc#InitializableComponent[Initializable] component provides a simple mechanism that mimics
the functionality of a constructor.
More specifically, it enables logic to be performed once and only once which is useful to set up a contract's initial state when a constructor cannot be used, for example when there are circular dependencies at construction time.

=== Usage

You can use the component in your contracts like this:

[,cairo]
----
#[starknet::contract]
mod MyInitializableContract {
    use openzeppelin_security::InitializableComponent;

    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);

    impl InternalImpl = InitializableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        initializable: InitializableComponent::Storage,
        param: felt252
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        InitializableEvent: InitializableComponent::Event
    }

    fn initializer(ref self: ContractState, some_param: felt252) {
        // Makes the method callable only once
        self.initializable.initialize();

        // Initialization logic
        self.param.write(some_param);
    }
}
----

CAUTION: This Initializable pattern should only be used in one function.

=== Interface

The component provides the following external functions as part of the `InitializableImpl` implementation:

[,cairo]
----
#[starknet::interface]
pub trait InitializableABI {
    fn is_initialized() -> bool;
}
----

== Pausable

:assert_not_paused: xref:api/security.adoc#PausableComponent-assert_not_paused[assert_not_paused]
:assert_paused: xref:api/security.adoc#PausableComponent-assert_paused[assert_paused]

The xref:api/security.adoc#PausableComponent[Pausable] component allows contracts to implement an emergency stop mechanism.
This can be useful for scenarios such as preventing trades until the end of an evaluation period or having an emergency switch to freeze all transactions in the event of a large bug.

To become pausable, the contract should include `pause` and `unpause` functions (which should be protected).
For methods that should be available only when paused or not, insert calls to `{assert_paused}` and `{assert_not_paused}`
respectively.

=== Usage

For example (using the xref:api/access.adoc#OwnableComponent[Ownable] component for access control):

[,cairo]
----
#[starknet::contract]
mod MyPausableContract {
    use openzeppelin_access::ownable::OwnableComponent;
    use openzeppelin_security::PausableComponent;
    use starknet::ContractAddress;

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);
    component!(path: PausableComponent, storage: pausable, event: PausableEvent);

    // Ownable Mixin
    #[abi(embed_v0)]
    impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;
    impl OwnableInternalImpl = OwnableComponent::InternalImpl<ContractState>;

    // Pausable
    #[abi(embed_v0)]
    impl PausableImpl = PausableComponent::PausableImpl<ContractState>;
    impl PausableInternalImpl = PausableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        ownable: OwnableComponent::Storage,
        #[substorage(v0)]
        pausable: PausableComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        OwnableEvent: OwnableComponent::Event,
        #[flat]
        PausableEvent: PausableComponent::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: ContractAddress) {
        self.ownable.initializer(owner);
    }

    #[external(v0)]
    fn pause(ref self: ContractState) {
        self.ownable.assert_only_owner();
        self.pausable.pause();
    }

    #[external(v0)]
    fn unpause(ref self: ContractState) {
        self.ownable.assert_only_owner();
        self.pausable.unpause();
    }

    #[external(v0)]
    fn when_not_paused(ref self: ContractState) {
        self.pausable.assert_not_paused();
        // Do something
    }

    #[external(v0)]
    fn when_paused(ref self: ContractState) {
        self.pausable.assert_paused();
        // Do something
    }
}
----

=== Interface

The component provides the following external functions as part of the `PausableImpl` implementation:

[,cairo]
----
#[starknet::interface]
pub trait PausableABI {
    fn is_paused() -> bool;
}
----

== Reentrancy Guard

:start: xref:api/security.adoc#ReentrancyGuardComponent-start[start]
:end: xref:api/security.adoc#ReentrancyGuardComponent-end[end]

A https://gus-tavo-guim.medium.com/reentrancy-attack-on-smart-contracts-how-to-identify-the-exploitable-and-an-example-of-an-attack-4470a2d8dfe4[reentrancy attack] occurs when the caller is able to obtain more resources than allowed by recursively calling a target's function.

=== Usage

Since Cairo does not support modifiers like Solidity, the xref:api/security.adoc#ReentrancyGuardComponent[ReentrancyGuard]
component exposes two methods `{start}` and `{end}` to protect functions against reentrancy attacks.
The protected function must call `start` before the first function statement, and `end` before the return statement, as shown below:

[,cairo]
----
#[starknet::contract]
mod MyReentrancyContract {
    use openzeppelin_security::ReentrancyGuardComponent;

    component!(
        path: ReentrancyGuardComponent, storage: reentrancy_guard, event: ReentrancyGuardEvent
    );

    impl InternalImpl = ReentrancyGuardComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        reentrancy_guard: ReentrancyGuardComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ReentrancyGuardEvent: ReentrancyGuardComponent::Event
    }

    #[external(v0)]
    fn protected_function(ref self: ContractState) {
        self.reentrancy_guard.start();

        // Do something

        self.reentrancy_guard.end();
    }

    #[external(v0)]
    fn another_protected_function(ref self: ContractState) {
        self.reentrancy_guard.start();

        // Do something

        self.reentrancy_guard.end();
    }
}
----

NOTE: The guard prevents the execution flow occurring inside `protected_function`
to call itself or `another_protected_function`, and vice versa.// llmstxt-short-description: API of the Security module, including the Initializable, Pausable and ReentrancyGuard components

:github-icon: pass:[<svg class="icon"><use href="#github-icon"/></svg>]

= Security

This crate provides components to handle common security-related tasks.

== Initializable

[.contract]
[[InitializableComponent]]
=== `++InitializableComponent++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/security/src/initializable.cairo[{github-icon},role=heading-link]

```cairo
use openzeppelin_security::InitializableComponent;
```

Component enabling one-time initialization for contracts.

[.contract-index]
.Embeddable Implementations
--
.InitializableImpl

* xref:#InitializableComponent-is_initialized[`++is_initialized(self)++`]
--

[.contract-index]
.Internal Implementations
--
.InternalImpl

* xref:#InitializableComponent-initialize[`++initialize(self)++`]
--

[#InitializableComponent-Embeddable-Functions]
==== Embeddable functions

[.contract-item]
[[InitializableComponent-is_initialized]]
==== `[.contract-item-name]#++is_initialized++#++(self: @ComponentState)++ → bool` [.item-kind]#external#

Returns whether the contract has been initialized.

[#InitializableComponent-Internal-Functions]
==== Internal functions

[.contract-item]
[[InitializableComponent-initialize]]
==== `[.contract-item-name]#++initialize++#++(ref self: ComponentState)++` [.item-kind]#internal#

Initializes the contract. Can only be called once.

Requirements:

- the contract must not have been initialized before.

== Pausable

[.contract]
[[PausableComponent]]
=== `++PausableComponent++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/security/src/pausable.cairo[{github-icon},role=heading-link]

:Paused: xref:PausableComponent-Paused[Paused]
:Unpaused: xref:PausableComponent-Unpaused[Unpaused]

```cairo
use openzeppelin_security::PausableComponent;
```

Component to implement an emergency stop mechanism.

[.contract-index]
.Embeddable Implementations
--
.PausableImpl

* xref:#PausableComponent-is_paused[`++is_paused(self)++`]
--

[.contract-index]
.Internal Implementations
--
.InternalImpl

* xref:#PausableComponent-assert_not_paused[`++assert_not_paused(self)++`]
* xref:#PausableComponent-assert_paused[`++assert_paused(self)++`]
* xref:#PausableComponent-pause[`++pause(self)++`]
* xref:#PausableComponent-unpause[`++unpause(self)++`]
--

[.contract-index]
.Events
--
* xref:#PausableComponent-Paused[`++Paused(account)++`]
* xref:#PausableComponent-Unpaused[`++Unpaused(account)++`]
--

[#PausableComponent-Embeddable-Functions]
==== Embeddable functions

[.contract-item]
[[PausableComponent-is_paused]]
==== `[.contract-item-name]#++is_paused++#++(self: @ComponentState)++ → bool` [.item-kind]#external#

Returns whether the contract is currently paused.

[#PausableComponent-Internal-Functions]
==== Internal functions

[.contract-item]
[[PausableComponent-assert_not_paused]]
==== `[.contract-item-name]#++assert_not_paused++#++(self: @ComponentState)++` [.item-kind]#internal#

Panics if the contract is paused.

[.contract-item]
[[PausableComponent-assert_paused]]
==== `[.contract-item-name]#++assert_paused++#++(self: @ComponentState)++` [.item-kind]#internal#

Panics if the contract is not paused.

[.contract-item]
[[PausableComponent-pause]]
==== `[.contract-item-name]#++pause++#++(ref self: ComponentState)++` [.item-kind]#internal#

Pauses the contract.

Requirements:

- the contract must not be paused.

Emits a {Paused} event.

[.contract-item]
[[PausableComponent-unpause]]
==== `[.contract-item-name]#++unpause++#++(ref self: ComponentState)++` [.item-kind]#internal#

Unpauses the contract.

Requirements:

- the contract must be paused.

Emits an {Unpaused} event.


[#PausableComponent-Events]
==== Events

[.contract-item]
[[PausableComponent-Paused]]
==== `[.contract-item-name]#++Paused++#++(account: ContractAddress)++` [.item-kind]#event#

Emitted when the contract is paused by `account`.

[.contract-item]
[[PausableComponent-Unpaused]]
==== `[.contract-item-name]#++Unpaused++#++(account: ContractAddress)++` [.item-kind]#event#

Emitted when the contract is unpaused by `account`.

== ReentrancyGuard

[.contract]
[[ReentrancyGuardComponent]]
=== `++ReentrancyGuardComponent++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/security/src/reentrancyguard.cairo[{github-icon},role=heading-link]

```cairo
use openzeppelin_security::ReentrancyGuardComponent;
```

Component to help prevent reentrant calls.

[.contract-index]
.Internal Implementations
--
.InternalImpl

* xref:#ReentrancyGuardComponent-start[`++start(self)++`]
* xref:#ReentrancyGuardComponent-end[`++end(self)++`]
--

[#ReentrancyGuardComponent-Internal-Functions]
==== Internal functions

[.contract-item]
[[ReentrancyGuardComponent-start]]
==== `[.contract-item-name]#++start++#++(ref self: ComponentState)++` [.item-kind]#internal#

Prevents a contract's function from calling itself or another protected function, directly or indirectly.

Requirements:

- the guard must not be currently enabled.

[.contract-item]
[[ReentrancyGuardComponent-end]]
==== `[.contract-item-name]#++end++#++(ref self: ComponentState)++` [.item-kind]#internal#

Removes the reentrant guard.
// llmstxt-short-description: Describes the ERC20 token standard and its usage

= ERC20

:fungible-tokens: https://docs.openzeppelin.com/contracts/4.x/tokens#different-kinds-of-tokens[fungible tokens]
:eip20: https://eips.ethereum.org/EIPS/eip-20[EIP-20]
:version: https://github.com/OpenZeppelin/cairo-contracts/releases/tag/v0.7.0[Contracts v0.7.0]
:custom-decimals: xref:/erc20.adoc#customizing_decimals[Customizing decimals]

The ERC20 token standard is a specification for {fungible-tokens}, a type of token where all the units are exactly equal to each other.
`token::erc20::ERC20Component` provides an approximation of {eip20} in Cairo for Starknet.

WARNING: Prior to {version}, ERC20 contracts store and read `decimals` from storage; however, this implementation returns a static `18`.
If upgrading an older ERC20 contract that has a decimals value other than `18`, the upgraded contract *must* use a custom `decimals` implementation.
See the {custom-decimals} guide.

== Usage

:erc20-supply: xref:/guides/erc20-supply.adoc[Creating ERC20 Supply]

Using Contracts for Cairo, constructing an ERC20 contract requires setting up the constructor and instantiating the token implementation.
Here's what that looks like:

[,cairo]
----
#[starknet::contract]
mod MyToken {
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    // ERC20 Mixin
    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc20: ERC20Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC20Event: ERC20Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        initial_supply: u256,
        recipient: ContractAddress
    ) {
        let name = "MyToken";
        let symbol = "MTK";

        self.erc20.initializer(name, symbol);
        self.erc20.mint(recipient, initial_supply);
    }
}
----

`MyToken` integrates both the `ERC20Impl` and `ERC20MetadataImpl` with the embed directive which marks the implementations as external in the contract.
While the `ERC20MetadataImpl` is optional, it's generally recommended to include it because the vast majority of ERC20 tokens provide the metadata methods.
The above example also includes the `ERC20InternalImpl` instance.
This allows the contract's constructor to initialize the contract and create an initial supply of tokens.

TIP: For a more complete guide on ERC20 token mechanisms, see {erc20-supply}.

== Interface

:dual-interfaces: xref:/interfaces.adoc#dual_interfaces[Dual interfaces]
:ierc20-interface: xref:/api/erc20.adoc#IERC20[IERC20]
:ierc20metadata-interface: xref:/api/erc20.adoc#IERC20Metadata[IERC20Metadata]
:erc20-component: xref:/api/erc20.adoc#ERC20Component[ERC20Component]
:erc20-supply: xref:/guides/erc20-supply.adoc[Creating ERC20 Supply]

The following interface represents the full ABI of the Contracts for Cairo {erc20-component}.
The interface includes the {ierc20-interface} standard interface as well as the optional {ierc20metadata-interface}.

To support older token deployments, as mentioned in {dual-interfaces}, the component also includes an implementation of the interface written in camelCase.

[,cairo]
----
#[starknet::interface]
pub trait ERC20ABI {
    // IERC20
    fn total_supply() -> u256;
    fn balance_of(account: ContractAddress) -> u256;
    fn allowance(owner: ContractAddress, spender: ContractAddress) -> u256;
    fn transfer(recipient: ContractAddress, amount: u256) -> bool;
    fn transfer_from(
        sender: ContractAddress, recipient: ContractAddress, amount: u256
    ) -> bool;
    fn approve(spender: ContractAddress, amount: u256) -> bool;

    // IERC20Metadata
    fn name() -> ByteArray;
    fn symbol() -> ByteArray;
    fn decimals() -> u8;

    // IERC20Camel
    fn totalSupply() -> u256;
    fn balanceOf(account: ContractAddress) -> u256;
    fn transferFrom(
        sender: ContractAddress, recipient: ContractAddress, amount: u256
    ) -> bool;
}
----

== ERC20 compatibility

:cairo-selectors: https://github.com/starkware-libs/cairo/blob/7dd34f6c57b7baf5cd5a30c15e00af39cb26f7e1/crates/cairo-lang-starknet/src/contract.rs#L39-L48[Cairo]
:solidity-selectors: https://solidity-by-example.org/function-selector/[Solidity]
:dual-interface: xref:/interfaces.adoc#dual_interfaces[dual interface]

Although Starknet is not EVM compatible, this component aims to be as close as possible to the ERC20 token standard.
Some notable differences, however, can still be found, such as:

* The `ByteArray` type is used to represent strings in Cairo.
* The component offers a {dual-interface} which supports both snake_case and camelCase methods, as opposed to just camelCase in Solidity.
* `transfer`, `transfer_from` and `approve` will never return anything different from `true` because they will revert on any error.
* Function selectors are calculated differently between {cairo-selectors} and {solidity-selectors}.

== Customizing decimals

:floating-point: https://en.wikipedia.org//wiki/Floating-point_arithmetic[floating-point numbers]
:eip-discussion: https://github.com/ethereum/EIPs/issues/724[EIP discussion]

Cairo, like Solidity, does not support {floating-point}.
To get around this limitation, ERC20 token contracts may offer a `decimals` field which communicates to outside interfaces (wallets, exchanges, etc.) how the token should be displayed.
For instance, suppose a token had a `decimals` value of `3` and the total token supply was `1234`.
An outside interface would display the token supply as `1.234`.
In the actual contract, however, the supply would still be the integer `1234`.
In other words, *the decimals field in no way changes the actual arithmetic* because all operations are still performed on integers.

Most contracts use `18` decimals and this was even proposed to be compulsory (see the {eip-discussion}).
The Contracts for Cairo `ERC20` component includes a `decimals` function that returns `18` by default to save on gas fees.
For those who want an ERC20 token with a configurable number of decimals, the following guide shows two ways to achieve this.

NOTE: Both approaches require creating a custom implementation of the `IERC20Metadata` interface.

=== The static approach

The simplest way to customize `decimals` consists of returning the target value from the `decimals` method.
For example:

[,cairo]
----
#[abi(embed_v0)]
impl ERC20MetadataImpl of interface::IERC20Metadata<ContractState> {
    fn decimals(self: @ContractState) -> u8 {
        // Change the `3` below to the desired number of decimals
        3
    }

    (...)
}

----

=== The storage approach

For more complex scenarios, such as a factory deploying multiple tokens with differing values for decimals, a flexible solution might be appropriate.

TIP: Note that we are not using the MixinImpl in this case, since we need to customize the IERC20Metadata implementation.

[,cairo]
----
#[starknet::contract]
mod MyToken {
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    #[abi(embed_v0)]
    impl ERC20Impl = ERC20Component::ERC20Impl<ContractState>;
    #[abi(embed_v0)]
    impl ERC20CamelOnlyImpl = ERC20Component::ERC20CamelOnlyImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc20: ERC20Component::Storage,
        // The decimals value is stored locally
        decimals: u8
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC20Event: ERC20Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        decimals: u8,
        initial_supply: u256,
        recipient: ContractAddress,
    ) {
        // Call the internal function that writes decimals to storage
        self._set_decimals(decimals);

        // Initialize ERC20
        let name = "MyToken";
        let symbol = "MTK";

        self.erc20.initializer(name, symbol);
        self.erc20.mint(recipient, initial_supply);
    }

    #[abi(embed_v0)]
    impl ERC20MetadataImpl of interface::IERC20Metadata<ContractState> {
        fn name(self: @ContractState) -> ByteArray {
            self.erc20.name()
        }

        fn symbol(self: @ContractState) -> ByteArray {
            self.erc20.symbol()
        }

        fn decimals(self: @ContractState) -> u8 {
            self.decimals.read()
        }
    }

    #[generate_trait]
    impl InternalImpl of InternalTrait {
        fn _set_decimals(ref self: ContractState, decimals: u8) {
            self.decimals.write(decimals);
        }
    }
}
----

This contract expects a `decimals` argument in the constructor and uses an internal function to write the decimals to storage.
Note that the `decimals` state variable must be defined in the contract's storage because this variable does not exist in the component offered by OpenZeppelin Contracts for Cairo.
It's important to include a custom ERC20 metadata implementation and NOT use the Contracts for Cairo `ERC20MetadataImpl` in this specific case since the `decimals` method will always return `18`.
// llmstxt-short-description: Describes different strategies for handling ERC20 supply

= Creating ERC20 Supply

:eip-20: https://eips.ethereum.org/EIPS/eip-20[EIP20]

The standard interface implemented by tokens built on Starknet comes from the popular token standard on Ethereum called ERC20.
{eip-20}, from which ERC20 contracts are derived, does not specify how tokens are created.
This guide will go over strategies for creating both a fixed and dynamic token supply.

== Fixed Supply

Let's say we want to create a token named `MyToken` with a fixed token supply.
We can achieve this by setting the token supply in the constructor which will execute upon deployment.

[,cairo]
----
#[starknet::contract]
mod MyToken {
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    // ERC20 Mixin
    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc20: ERC20Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC20Event: ERC20Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        fixed_supply: u256,
        recipient: ContractAddress
    ) {
        let name = "MyToken";
        let symbol = "MTK";

        self.erc20.initializer(name, symbol);
        self.erc20.mint(recipient, fixed_supply);
    }
}
----

In the constructor, we're first calling the ERC20 initializer to set the token name and symbol.
Next, we're calling the internal `mint` function which creates `fixed_supply` of tokens and allocates them to `recipient`.
Since the internal `mint` is not exposed in our contract, it will not be possible to create any more tokens.
In other words, we've implemented a fixed token supply!

== Dynamic Supply

:access-control: xref:/access.adoc[Access Control]

ERC20 contracts with a dynamic supply include a mechanism for creating or destroying tokens.
Let's make a few changes to the almighty `MyToken` contract and create a minting mechanism.

[,cairo]
----
#[starknet::contract]
mod MyToken {
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

   // ERC20 Mixin
    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc20: ERC20Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC20Event: ERC20Component::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState) {
        let name = "MyToken";
        let symbol = "MTK";

        self.erc20.initializer(name, symbol);
    }

    #[external(v0)]
    fn mint(
        ref self: ContractState,
        recipient: ContractAddress,
        amount: u256
    ) {
        // This function is NOT protected which means
        // ANYONE can mint tokens
        self.erc20.mint(recipient, amount);
    }
}
----

The exposed `mint` above will create `amount` tokens and allocate them to `recipient`.
We now have our minting mechanism!

There is, however, a big problem.
`mint` does not include any restrictions on who can call this function.
For the sake of good practices, let's implement a simple permissioning mechanism with `Ownable`.

[,cairo]
----
#[starknet::contract]
mod MyToken {

    (...)

    // Integrate Ownable

    #[external(v0)]
    fn mint(
        ref self: ContractState,
        recipient: ContractAddress,
        amount: u256
    ) {
        // Set permissions with Ownable
        self.ownable.assert_only_owner();

        // Mint tokens if called by the contract owner
        self.erc20.mint(recipient, amount);
    }
}
----

In the constructor, we pass the owner address to set the owner of the `MyToken` contract.
The `mint` function includes `assert_only_owner` which will ensure that only the contract owner can call this function.
Now, we have a protected ERC20 minting mechanism to create a dynamic token supply.

TIP: For a more thorough explanation of permission mechanisms, see {access-control}.
// llmstxt-short-description: Describes the ERC20Permit extension key features and its usage

= ERC20Permit

:permit-fn: xref:/api/erc20.adoc#ERC20Component-permit[permit]
:approve-fn: xref:/api/erc20.adoc#ERC20Component-approve[permit]
:snip-12: https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md[SNIP12]
:snip-12-guide: xref:/guides/snip12.adoc[SNIP12 guide]
:snip12-metadata: xref:api/utilities.adoc#snip12[SNIP12Metadata]
:eip-2612: https://eips.ethereum.org/EIPS/eip-2612[EIP-2612]
:erc20-component: xref:/api/erc20.adoc#ERC20Component[ERC20Component]
:erc20-permit-trait: xref:/api/erc20.adoc#ERC20Component-Embeddable-Impls-ERC20PermitImpl[ERC20Permit]
:nonces-component: xref:/api/utilities.adoc#NoncesComponent[NoncesComponent]
:permit-solidity-impl: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20Permit.sol[Solidity implementation]

The {eip-2612} standard, commonly referred to as ERC20Permit, is designed to support gasless token approvals. This is achieved with an off-chain 
signature following the {snip-12} standard, rather than with an on-chain transaction. The {permit-fn} function verifies the signature and sets 
the spender's allowance if the signature is valid. This approach improves user experience and reduces gas costs.

== Differences from Solidity

Although this extension is mostly similar to the {permit-solidity-impl} of {eip-2612}, there are some notable differences in the parameters of the {permit-fn} function:

- The `deadline` parameter is represented by `u64` rather than `u256`.
- The `signature` parameter is represented by a span of felts rather than `v`, `r`, and `s` values.

NOTE: Unlike Solidity, there is no enforced format for signatures on Starknet. A signature is represented by an array or span of felts, 
and there is no universal method for validating signatures of unknown formats. Consequently, a signature provided to the {permit-fn} function 
is validated through an external `is_valid_signature` call to the contract at the `owner` address.

== Usage

The functionality is provided as an embeddable {erc20-permit-trait} trait of the {erc20-component}.

```cairo
#[abi(embed_v0)]
impl ERC20PermitImpl = ERC20Component::ERC20PermitImpl<ContractState>;
```

A contract must meet the following requirements to be able to use the {erc20-permit-trait} trait:

- Implement {erc20-component}.
- Implement {nonces-component}.
- Implement {snip12-metadata} trait (used in signature generation).

== Typed message

To safeguard against replay attacks and ensure the uniqueness of each approval via {permit-fn}, the data signed includes:

- The address of the `owner`.
- The parameters specified in the {approve-fn} function (`spender` and `amount`)
- The address of the `token` contract itself.
- A `nonce`, which must be unique for each operation.
- The `chain_id`, which protects against cross-chain replay attacks.

The format of the `Permit` structure in a signed permit message is as follows:
```cairo
struct Permit {
    token: ContractAddress,
    spender: ContractAddress,
    amount: u256,
    nonce: felt252,
    deadline: u64,
}
```

NOTE: The owner of the tokens is also part of the signed message. It is used as the `signer` parameter in the `get_message_hash` call.

Further details on preparing and signing a typed message can be found in the {snip-12-guide}.// llmstxt-short-description: API of the ERC20 component, interface, presets and extensions

:github-icon: pass:[<svg class="icon"><use href="#github-icon"/></svg>]
:eip20: https://eips.ethereum.org/EIPS/eip-20[EIP-20]
:erc20-guide: xref:erc20.adoc[ERC20 guide]
:casing-discussion: https://github.com/OpenZeppelin/cairo-contracts/discussions/34[here]
:custom-decimals: xref:/erc20.adoc#customizing_decimals[Customizing decimals]
:snip-12: https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md[SNIP12]
:snip12-metadata: xref:api/utilities.adoc#snip12[SNIP12Metadata]
:eip-2612: https://eips.ethereum.org/EIPS/eip-2612[EIP-2612]

= ERC20

include::../utils/_common.adoc[]

This module provides interfaces, presets, and utilities related to ERC20 contracts.

TIP: For an overview of ERC20, read our {erc20-guide}.

== Core

[.contract]
[[IERC20]]
=== `++IERC20++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/token/src/erc20/interface.cairo[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_token::erc20::interface::IERC20;
```

Interface of the IERC20 standard as defined in {eip20}.

[.contract-index]
.Functions
--
* xref:#IERC20-total_supply[`++total_supply()++`]
* xref:#IERC20-balance_of[`++balance_of()++`]
* xref:#IERC20-allowance[`++allowance(owner, spender)++`]
* xref:#IERC20-transfer[`++transfer(recipient, amount)++`]
* xref:#IERC20-transfer_from[`++transfer_from(sender, recipient, amount)++`]
* xref:#IERC20-approve[`++approve(spender, amount)++`]
--

[.contract-index]
.Events
--
* xref:#IERC20-Transfer[`++Transfer(from, to, value)++`]
* xref:#IERC20-Approval[`++Approval(owner, spender, value)++`]
--

[#IERC20-Functions]
==== Functions

[.contract-item]
[[IERC20-total_supply]]
==== `[.contract-item-name]#++total_supply++#++() → u256++` [.item-kind]#external#

Returns the amount of tokens in existence.

[.contract-item]
[[IERC20-balance_of]]
==== `[.contract-item-name]#++balance_of++#++(account: ContractAddress) → u256++` [.item-kind]#external#

Returns the amount of tokens owned by `account`.

[.contract-item]
[[IERC20-allowance]]
==== `[.contract-item-name]#++allowance++#++(owner: ContractAddress, spender: ContractAddress) → u256++` [.item-kind]#external#

Returns the remaining number of tokens that `spender` is allowed to spend on behalf of `owner` through <<transfer_from,transfer_from>>. This is zero by default.

This value changes when <<IERC20-approve,approve>> or <<IERC20-transfer_from,transfer_from>> are called.

[.contract-item]
[[IERC20-transfer]]
==== `[.contract-item-name]#++transfer++#++(recipient: ContractAddress, amount: u256) → bool++` [.item-kind]#external#

Moves `amount` tokens from the caller's token balance to `to`.
Returns `true` on success, reverts otherwise.

Emits a <<IERC20-Transfer,Transfer>> event.

[.contract-item]
[[IERC20-transfer_from]]
==== `[.contract-item-name]#++transfer_from++#++(sender: ContractAddress, recipient: ContractAddress, amount: u256) → bool++` [.item-kind]#external#

Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism.
`amount` is then deducted from the caller's allowance.
Returns `true` on success, reverts otherwise.

Emits a <<IERC20-Transfer,Transfer>> event.

[.contract-item]
[[IERC20-approve]]
==== `[.contract-item-name]#++approve++#++(spender: ContractAddress, amount: u256) → bool++` [.item-kind]#external#

Sets `amount` as the allowance of `spender` over the caller's tokens.
Returns `true` on success, reverts otherwise.

Emits an <<ERC20-Approval,Approval>> event.

[#IERC20-Events]
==== Events

[.contract-item]
[[IERC20-Transfer]]
==== `[.contract-item-name]#++Transfer++#++(from: ContractAddress, to: ContractAddress, value: u256)++` [.item-kind]#event#

Emitted when `value` tokens are moved from one address (`from`) to another (`to`).

Note that `value` may be zero.

[.contract-item]
[[IERC20-Approval]]
==== `[.contract-item-name]#++Approval++#++(owner: ContractAddress, spender: ContractAddress, value: u256)++` [.item-kind]#event#

Emitted when the allowance of a `spender` for an `owner` is set.
`value` is the new allowance.

[.contract]
[[IERC20Metadata]]
=== `++IERC20Metadata++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/token/src/erc20/interface.cairo#L19[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_token::erc20::interface::IERC20Metadata;
```

Interface for the optional metadata functions in {eip20}.

[.contract-index]
.Functions
--
* xref:#IERC20Metadata-name[`++name()++`]
* xref:#IERC20Metadata-symbol[`++symbol()++`]
* xref:#IERC20Metadata-decimals[`++decimals()++`]
--

[#IERC20Metadata-Functions]
==== Functions

[.contract-item]
[[IERC20Metadata-name]]
==== `[.contract-item-name]#++name++#++() → ByteArray++` [.item-kind]#external#

Returns the name of the token.

[.contract-item]
[[IERC20Metadata-symbol]]
==== `[.contract-item-name]#++symbol++#++() → ByteArray++` [.item-kind]#external#

Returns the ticker symbol of the token.

[.contract-item]
[[IERC20Metadata-decimals]]
==== `[.contract-item-name]#++decimals++#++() → u8++` [.item-kind]#external#

Returns the number of decimals the token uses - e.g. `8` means to divide the token amount by `100000000` to get its user-readable representation.

For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5.05` (`505 / 10 ** 2`).

Tokens usually opt for a value of `18`, imitating the relationship between Ether and Wei.
This is the default value returned by this function.
To create a custom decimals implementation, see {custom-decimals}.

NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract.

[.contract]
[[ERC20Component]]
=== `++ERC20Component++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/token/src/erc20/erc20.cairo[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_token::erc20::ERC20Component;
```
ERC20 component extending <<IERC20,IERC20>> and <<IERC20Metadata,IERC20Metadata>>.

NOTE: See xref:#ERC20Component-Hooks[Hooks] to understand how are hooks used.

[.contract-index]
.Hooks
--
[.sub-index#ERC20Component-ERC20HooksTrait]
.ERC20HooksTrait
* xref:#ERC20Component-before_update[`++before_update(self, from, recipient, amount)++`]
* xref:#ERC20Component-after_update[`++after_update(self, from, recipient, amount)++`]
--

[.contract-index#ERC20Component-Embeddable-Mixin-Impl]
.{mixin-impls}
--
.ERC20MixinImpl
* xref:#ERC20Component-Embeddable-Impls-ERC20Impl[`++ERC20Impl++`]
* xref:#ERC20Component-Embeddable-Impls-ERC20MetadataImpl[`++ERC20MetadataImpl++`]
* xref:#ERC20Component-Embeddable-Impls-ERC20CamelOnlyImpl[`++ERC20CamelOnlyImpl++`]
--

[.contract-index#ERC20Component-Embeddable-Impls]
.Embeddable Implementations
--
[.sub-index#ERC20Component-Embeddable-Impls-ERC20Impl]
.ERC20Impl
* xref:#ERC20Component-total_supply[`++total_supply(self)++`]
* xref:#ERC20Component-balance_of[`++balance_of(self, account)++`]
* xref:#ERC20Component-allowance[`++allowance(self, owner, spender)++`]
* xref:#ERC20Component-transfer[`++transfer(self, recipient, amount)++`]
* xref:#ERC20Component-transfer_from[`++transfer_from(self, sender, recipient, amount)++`]
* xref:#ERC20Component-approve[`++approve(self, spender, amount)++`]

[.sub-index#ERC20Component-Embeddable-Impls-ERC20MetadataImpl]
.ERC20MetadataImpl
* xref:#ERC20Component-name[`++name(self)++`]
* xref:#ERC20Component-symbol[`++symbol(self)++`]
* xref:#ERC20Component-decimals[`++decimals(self)++`]

[.sub-index#ERC20Component-Embeddable-Impls-ERC20CamelOnlyImpl]
.ERC20CamelOnlyImpl
* xref:#ERC20Component-totalSupply[`++totalSupply(self)++`]
* xref:#ERC20Component-balanceOf[`++balanceOf(self, account)++`]
* xref:#ERC20Component-transferFrom[`++transferFrom(self, sender, recipient, amount)++`]

[.sub-index#ERC20Component-Embeddable-Impls-ERC20PermitImpl]
.ERC20PermitImpl
* xref:#ERC20Component-permit[`++permit(self, owner, spender, amount, deadline, signature)++`]
* xref:#ERC20Component-nonces[`++nonces(self, owner)++`]
* xref:#ERC20Component-DOMAIN_SEPARATOR[`++DOMAIN_SEPARATOR(self)++`]

[.sub-index#ERC20Component-Embeddable-Impls-SNIP12MetadataExternalImpl]
.SNIP12MetadataExternalImpl
* xref:#ERC20Component-snip12_metadata[`++snip12_metadata(self)++`]
--

[.contract-index]
.Internal implementations
--
.InternalImpl
* xref:#ERC20Component-initializer[`++initializer(self, name, symbol)++`]
* xref:#ERC20Component-mint[`++mint(self, recipient, amount)++`]
* xref:#ERC20Component-burn[`++burn(self, account, amount)++`]
* xref:#ERC20Component-update[`++update(self, from, to, amount)++`]
* xref:#ERC20Component-_transfer[`++_transfer(self, sender, recipient, amount)++`]
* xref:#ERC20Component-_approve[`++_approve(self, owner, spender, amount)++`]
* xref:#ERC20Component-_spend_allowance[`++_spend_allowance(self, owner, spender, amount)++`]
--

[.contract-index]
.Events
--
* xref:#ERC20Component-Transfer[`++Transfer(from, to, value)++`]
* xref:#ERC20Component-Approval[`++Approval(owner, spender, value)++`]
--

[#ERC20Component-Hooks]
==== Hooks

Hooks are functions which implementations can extend the functionality of the component source code. Every contract
using ERC20Component is expected to provide an implementation of the ERC20HooksTrait. For basic token contracts, an
empty implementation with no logic must be provided.

TIP: You can use `openzeppelin_token::erc20::ERC20HooksEmptyImpl` which is already available as part of the library
for this purpose.

[.contract-item]
[[ERC20Component-before_update]]
==== `[.contract-item-name]#++before_update++#++(ref self: ContractState, from: ContractAddress, recipient: ContractAddress, amount: u256)++` [.item-kind]#hook#

Function executed at the beginning of the xref:#ERC20Component-update[update] function prior to any other logic.

[.contract-item]
[[ERC20Component-after_update]]
==== `[.contract-item-name]#++after_update++#++(ref self: ContractState, from: ContractAddress, recipient: ContractAddress, amount: u256)++` [.item-kind]#hook#

Function executed at the end of the xref:#ERC20Component-update[update] function.

[#ERC20Component-Embeddable-functions]
==== Embeddable functions

[.contract-item]
[[ERC20Component-total_supply]]
==== `[.contract-item-name]#++total_supply++#++(@self: ContractState) → u256++` [.item-kind]#external#

See <<IERC20-total_supply,IERC20::total_supply>>.

[.contract-item]
[[ERC20Component-balance_of]]
==== `[.contract-item-name]#++balance_of++#++(@self: ContractState, account: ContractAddress) → u256++` [.item-kind]#external#

See <<IERC20-balance_of,IERC20::balance_of>>.

[.contract-item]
[[ERC20Component-allowance]]
==== `[.contract-item-name]#++allowance++#++(@self: ContractState, owner: ContractAddress, spender: ContractAddress) → u256++` [.item-kind]#external#

See <<IERC20-allowance,IERC20::allowance>>.

[.contract-item]
[[ERC20Component-transfer]]
==== `[.contract-item-name]#++transfer++#++(ref self: ContractState, recipient: ContractAddress, amount: u256) → bool++` [.item-kind]#external#

See <<IERC20-transfer,IERC20::transfer>>.

Requirements:

- `recipient` cannot be the zero address.
- The caller must have a balance of at least `amount`.

[.contract-item]
[[ERC20Component-transfer_from]]
==== `[.contract-item-name]#++transfer_from++#++(ref self: ContractState, sender: ContractAddress, recipient: ContractAddress, amount: u256) → bool++` [.item-kind]#external#

See <<IERC20-transfer_from,IERC20::transfer_from>>.

Requirements:

- `sender` cannot be the zero address.
- `sender` must have a balance of at least `amount`.
- `recipient` cannot be the zero address.
- The caller must have allowance for ``sender``'s tokens of at least `amount`.

[.contract-item]
[[ERC20Component-approve]]
==== `[.contract-item-name]#++approve++#++(ref self: ContractState, spender: ContractAddress, amount: u256) → bool++` [.item-kind]#external#

See <<IERC20-approve,IERC20::approve>>.

Requirements:

- `spender` cannot be the zero address.

[.contract-item]
[[ERC20Component-name]]
==== `[.contract-item-name]#++name++#++() → ByteArray++` [.item-kind]#external#

See <<IERC20Metadata-name,IERC20Metadata::name>>.

[.contract-item]
[[ERC20Component-symbol]]
==== `[.contract-item-name]#++symbol++#++() → ByteArray++` [.item-kind]#external#

See <<IERC20Metadata-symbol,IERC20Metadata::symbol>>.

[.contract-item]
[[ERC20Component-decimals]]
==== `[.contract-item-name]#++decimals++#++() → u8++` [.item-kind]#external#

See <<IERC20Metadata-decimals,IERC20Metadata::decimals>>.

[.contract-item]
[[ERC20Component-totalSupply]]
==== `[.contract-item-name]#++totalSupply++#++(self: @ContractState) → u256++` [.item-kind]#external#

See <<IERC20-total_supply,IERC20::total_supply>>.

Supports the Cairo v0 convention of writing external methods in camelCase as discussed {casing-discussion}.

[.contract-item]
[[ERC20Component-balanceOf]]
==== `[.contract-item-name]#++balanceOf++#++(self: @ContractState, account: ContractAddress) → u256++` [.item-kind]#external#

See <<IERC20-balance_of,IERC20::balance_of>>.

Supports the Cairo v0 convention of writing external methods in camelCase as discussed {casing-discussion}.

[.contract-item]
[[ERC20Component-transferFrom]]
==== `[.contract-item-name]#++transferFrom++#++(ref self: ContractState, sender: ContractAddress, recipient: ContractAddress) → bool++` [.item-kind]#external#

See <<IERC20-transfer_from,IERC20::transfer_from>>.

Supports the Cairo v0 convention of writing external methods in camelCase as discussed {casing-discussion}.

[.contract-item]
[[ERC20Component-permit]]
==== `[.contract-item-name]#++permit++#++(ref self: ContractState, owner: ContractAddress, spender: ContractAddress, amount: u256, deadline: u64, signature: Span<felt252>) → bool++` [.item-kind]#external#

Sets `amount` as the allowance of `spender` over ``owner``'s tokens after validating the
signature.

Requirements:

- `owner` is a deployed account contract.
- `spender` is not the zero address.
- `deadline` is not a timestamp in the past.
- `signature` is a valid signature that can be validated with a call to `owner` account.
- `signature` must use the current nonce of the `owner`.

Emits an <<ERC20-Approval,Approval>> event.
Every successful call increases `owner`'s nonce by one.

[.contract-item]
[[ERC20Component-nonces]]
==== `[.contract-item-name]#++nonces++#++(self: @ContractState, owner: ContractAddress) → felt252++` [.item-kind]#external#

Returns the current nonce of `owner`. A nonce value must be included 
whenever a signature for `permit` call is generated.

[.contract-item]
[[ERC20Component-DOMAIN_SEPARATOR]]
==== `[.contract-item-name]#++DOMAIN_SEPARATOR++#++(self: @ContractState) → felt252++` [.item-kind]#external#

Returns the domain separator used in generating a message hash for `permit` signature. 
The domain hashing logic follows the {snip-12} standard.

[.contract-item]
[[ERC20Component-snip12_metadata]]
==== `[.contract-item-name]#++snip12_metadata++#++(self: @ContractState) → (felt252, felt252)++` [.item-kind]#external#

Returns the domain name and version used to generate the message hash for permit signature.

The returned tuple contains:

- `t.0`: The name used in the {snip12-metadata} implementation.
- `t.1`: The version used in the {snip12-metadata} implementation.

[#ERC20Component-Internal-functions]
==== Internal functions

[.contract-item]
[[ERC20Component-initializer]]
==== `[.contract-item-name]#++initializer++#++(ref self: ContractState, name: ByteArray, symbol: ByteArray)++` [.item-kind]#internal#

Initializes the contract by setting the token name and symbol.
This should be used inside of the contract's constructor.

[.contract-item]
[[ERC20Component-mint]]
==== `[.contract-item-name]#++mint++#++(ref self: ContractState, recipient: ContractAddress, amount: u256)++` [.item-kind]#internal#

Creates an `amount` number of tokens and assigns them to `recipient`.

Emits a <<ERC20Component-Transfer,Transfer>> event with `from` being the zero address.

Requirements:

- `recipient` cannot be the zero address.

[.contract-item]
[[ERC20Component-burn]]
==== `[.contract-item-name]#++burn++#++(ref self: ContractState, account: ContractAddress, amount: u256)++` [.item-kind]#internal#

Destroys `amount` number of tokens from `account`.

Emits a <<ERC20Component-Transfer,Transfer>> event with `to` set to the zero address.

Requirements:

- `account` cannot be the zero address.

[.contract-item]
[[ERC20Component-update]]
==== `[.contract-item-name]#++update++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, amount: u256)++` [.item-kind]#internal#

Transfers an `amount` of tokens from `from` to `to`, or alternatively mints (or burns) if `from` (or `to`) is
the zero address.

NOTE: This function can be extended using the xref:ERC20Component-ERC20HooksTrait[ERC20HooksTrait], to add
functionality before and/or after the transfer, mint, or burn.

Emits a <<ERC20Component-Transfer,Transfer>> event.

[.contract-item]
[[ERC20Component-_transfer]]
==== `[.contract-item-name]#++_transfer++#++(ref self: ContractState, sender: ContractAddress, recipient: ContractAddress, amount: u256)++` [.item-kind]#internal#

Moves `amount` of tokens from `from` to `to`.

This internal function does not check for access permissions but can be useful as a building block, for example to implement automatic token fees, slashing mechanisms, etc.

Emits a <<ERC20Component-Transfer,Transfer>> event.

Requirements:

- `from` cannot be the zero address.
- `to` cannot be the zero address.
- `from` must have a balance of at least `amount`.

[.contract-item]
[[ERC20Component-_approve]]
==== `[.contract-item-name]#++_approve++#++(ref self: ContractState, owner: ContractAddress, spender: ContractAddress, amount: u256)++` [.item-kind]#internal#

Sets `amount` as the allowance of `spender` over ``owner``'s tokens.

This internal function does not check for access permissions but can be useful as a building block, for example to implement automatic allowances on behalf of other addresses.

Emits an <<ERC20Component-Approval,Approval>> event.

Requirements:

- `owner` cannot be the zero address.
- `spender` cannot be the zero address.

[.contract-item]
[[ERC20Component-_spend_allowance]]
==== `[.contract-item-name]#++_spend_allowance++#++(ref self: ContractState, owner: ContractAddress, spender: ContractAddress, amount: u256)++` [.item-kind]#internal#

Updates ``owner``'s allowance for `spender` based on spent `amount`.

This internal function does not update the allowance value in the case of infinite allowance.

Possibly emits an <<ERC20Component-Approval,Approval>> event.

[#ERC20Component-Events]
==== Events

[.contract-item]
[[ERC20Component-Transfer]]
==== `[.contract-item-name]#++Transfer++#++(from: ContractAddress, to: ContractAddress, value: u256)++` [.item-kind]#event#

See <<IERC20-Transfer,IERC20::Transfer>>.

[.contract-item]
[[ERC20Component-Approval]]
==== `[.contract-item-name]#++Approval++#++(owner: ContractAddress, spender: ContractAddress, value: u256)++` [.item-kind]#event#

See <<IERC20-Approval,IERC20::Approval>>.

== Extensions

[.contract]
[[IERC20Permit]]
=== `++IERC20Permit++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/token/src/erc20/interface.cairo#L19[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_token::erc20::interface::IERC20Permit;
```

Interface of the ERC20Permit standard to support gasless token approvals as defined in {eip-2612}. 

[.contract-index]
.Functions
--
* xref:#IERC20Permit-permit[`++permit(owner, spender, amount, deadline, signature)++`]
* xref:#IERC20Permit-nonces[`++nonces(owner)++`]
* xref:#IERC20Permit-DOMAIN_SEPARATOR[`++DOMAIN_SEPARATOR()++`]
--

[#IERC20Permit-Functions]
==== Functions

[.contract-item]
[[IERC20Permit-permit]]
==== `[.contract-item-name]#++permit++#++(owner: ContractAddress, spender: ContractAddress, amount: u256, deadline: u64, signature: Span<felt252>)++` [.item-kind]#external#

Sets `amount` as the allowance of `spender` over ``owner``'s tokens after validating the signature.

[.contract-item]
[[IERC20Permit-nonces]]
==== `[.contract-item-name]#++nonces++#++(owner: ContractAddress) → felt252++` [.item-kind]#external#

Returns the current nonce of `owner`. A nonce value must be included 
whenever a signature for `permit` call is generated.

[.contract-item]
[[IERC20Permit-DOMAIN_SEPARATOR]]
==== `[.contract-item-name]#++DOMAIN_SEPARATOR++#++() → felt252++` [.item-kind]#external#

Returns the domain separator used in generating a message hash for `permit` signature. 
The domain hashing logic follows the {snip-12} standard.

== Presets

[.contract]
[[ERC20Upgradeable]]
=== `++ERC20Upgradeable++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/presets/src/erc20.cairo[{github-icon},role=heading-link]

```cairo
use openzeppelin_presets::ERC20Upgradeable;
```

Upgradeable ERC20 contract leveraging xref:#ERC20Component[ERC20Component] with a fixed-supply mechanism for token distribution.

include::../utils/_class_hashes.adoc[]

[.contract-index]
.{presets-page}
--
{ERC20Upgradeable-class-hash}
--

[.contract-index]
.Constructor
--
* xref:#ERC20Upgradeable-constructor[`++constructor(self, name, symbol, fixed_supply, recipient, owner)++`]
--

[.contract-index]
.Embedded Implementations
--
.ERC20MixinImpl

* xref:#ERC20Component-Embeddable-Mixin-Impl[`++ERC20MixinImpl++`]

.OwnableMixinImpl

* xref:/api/access.adoc#OwnableComponent-Mixin-Impl[`++OwnableMixinImpl++`]
--

[.contract-index]
.External Functions
--
* xref:#ERC20Upgradeable-upgrade[`++upgrade(self, new_class_hash)++`]
--

[#ERC20Upgradeable-constructor-section]
==== Constructor

[.contract-item]
[[ERC20Upgradeable-constructor]]
==== `[.contract-item-name]#++constructor++#++(ref self: ContractState, name: ByteArray, symbol: ByteArray, fixed_supply: u256, recipient: ContractAddress, owner: ContractAddress)++` [.item-kind]#constructor#

Sets the `name` and `symbol` and mints `fixed_supply` tokens to `recipient`.
Assigns `owner` as the contract owner with permissions to upgrade.

[#ERC20Upgradeable-external-functions]
==== External functions

[.contract-item]
[[ERC20Upgradeable-upgrade]]
==== `[.contract-item-name]#++upgrade++#++(ref self: ContractState, new_class_hash: ClassHash)++` [.item-kind]#external#

Upgrades the contract to a new implementation given by `new_class_hash`.

Requirements:

- The caller is the contract owner.
- `new_class_hash` cannot be zero.// llmstxt-short-description: Describes the ERC721 token standard and its usage

= ERC721

:token-types: https://docs.openzeppelin.com/contracts/5.x/tokens#different-kinds-of-tokens[non-fungible tokens]
:eip721: https://eips.ethereum.org/EIPS/eip-721[EIP-721]

The ERC721 token standard is a specification for {token-types}, or more colloquially: NFTs.
`token::erc721::ERC721Component` provides an approximation of {eip721} in Cairo for Starknet.

== Usage

:mint-api: xref:api/erc721.adoc#ERC721-mint[mint]

Using Contracts for Cairo, constructing an ERC721 contract requires integrating both `ERC721Component` and `SRC5Component`.
The contract should also set up the constructor to initialize the token's name, symbol, and interface support.
Here's an example of a basic contract:

[,cairo]
----
#[starknet::contract]
mod MyNFT {
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_token::erc721::{ERC721Component, ERC721HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: ERC721Component, storage: erc721, event: ERC721Event);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // ERC721 Mixin
    #[abi(embed_v0)]
    impl ERC721MixinImpl = ERC721Component::ERC721MixinImpl<ContractState>;
    impl ERC721InternalImpl = ERC721Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc721: ERC721Component::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC721Event: ERC721Component::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        recipient: ContractAddress
    ) {
        let name = "MyNFT";
        let symbol = "NFT";
        let base_uri = "https://api.example.com/v1/";
        let token_id = 1;

        self.erc721.initializer(name, symbol, base_uri);
        self.erc721.mint(recipient, token_id);
    }
}
----

== Interface

:compatibility: xref:/erc721.adoc#erc721_compatibility[ERC721 Compatibility]
:ierc721-interface: xref:/api/erc721.adoc#IERC721[IERC721]
:ierc721metadata-interface: xref:/api/erc721.adoc#IERC721Metadata[IERC721Metadata]
:erc721-component: xref:/api/erc721.adoc#ERC721Component[ERC721Component]
:dual-interfaces: xref:interfaces.adoc#dual_interfaces[Dual interfaces]

The following interface represents the full ABI of the Contracts for Cairo {erc721-component}.
The interface includes the {ierc721-interface} standard interface and the optional {ierc721metadata-interface} interface.

To support older token deployments, as mentioned in {dual-interfaces}, the component also includes implementations of the interface written in camelCase.

[,cairo]
----
#[starknet::interface]
pub trait ERC721ABI {
    // IERC721
    fn balance_of(account: ContractAddress) -> u256;
    fn owner_of(token_id: u256) -> ContractAddress;
    fn safe_transfer_from(
        from: ContractAddress,
        to: ContractAddress,
        token_id: u256,
        data: Span<felt252>
    );
    fn transfer_from(from: ContractAddress, to: ContractAddress, token_id: u256);
    fn approve(to: ContractAddress, token_id: u256);
    fn set_approval_for_all(operator: ContractAddress, approved: bool);
    fn get_approved(token_id: u256) -> ContractAddress;
    fn is_approved_for_all(owner: ContractAddress, operator: ContractAddress) -> bool;

    // IERC721Metadata
    fn name() -> ByteArray;
    fn symbol() -> ByteArray;
    fn token_uri(token_id: u256) -> ByteArray;

    // IERC721CamelOnly
    fn balanceOf(account: ContractAddress) -> u256;
    fn ownerOf(tokenId: u256) -> ContractAddress;
    fn safeTransferFrom(
        from: ContractAddress,
        to: ContractAddress,
        tokenId: u256,
        data: Span<felt252>
    );
    fn transferFrom(from: ContractAddress, to: ContractAddress, tokenId: u256);
    fn setApprovalForAll(operator: ContractAddress, approved: bool);
    fn getApproved(tokenId: u256) -> ContractAddress;
    fn isApprovedForAll(owner: ContractAddress, operator: ContractAddress) -> bool;

    // IERC721MetadataCamelOnly
    fn tokenURI(tokenId: u256) -> ByteArray;
}
----

== ERC721 compatibility

:erc165-storage: https://docs.openzeppelin.com/contracts/4.x/api/utils#ERC165Storage[ERC165Storage]
:src5-api: xref:introspection.adoc#src5[SRC5]
:introspection: xref:introspection.adoc[Introspection]
:eip165: https://eips.ethereum.org/EIPS/eip-165[EIP165]

Although Starknet is not EVM compatible, this implementation aims to be as close as possible to the ERC721 standard.
This implementation does, however, include a few notable differences such as:

* ``interface_id``s are hardcoded and initialized by the constructor.
The hardcoded values derive from Starknet's selector calculations.
See the {introspection} docs.
* `safe_transfer_from` can only be expressed as a single function in Cairo as opposed to the two functions declared in EIP721, because function overloading is currently not possible in Cairo.
The difference between both functions consists of accepting `data` as an argument.
`safe_transfer_from` by default accepts the `data` argument which is interpreted as `Span<felt252>`.
If `data` is not used, simply pass an empty array.
* ERC721 utilizes {src5-api} to declare and query interface support on Starknet as opposed to Ethereum's {eip165}.
The design for `SRC5` is similar to OpenZeppelin's {erc165-storage}.
* `IERC721Receiver` compliant contracts return a hardcoded interface ID according to Starknet selectors (as opposed to selector calculation in Solidity).

== Token transfers

:transfer_from-api: xref:api/erc721.adoc#IERC721-transfer_from[transfer_from]
:safe_transfer_from-api: xref:api/erc721.adoc#IERC721-safe_transfer_from[safe_transfer_from]

This library includes {transfer_from-api} and {safe_transfer_from-api} to transfer NFTs.
If using `transfer_from`, *the caller is responsible to confirm that the recipient is capable of receiving NFTs or else they may be permanently lost.*
The `safe_transfer_from` method mitigates this risk by querying the recipient contract's interface support.

WARNING: Usage of `safe_transfer_from` prevents loss, though the caller must understand this adds an external call which potentially creates a reentrancy vulnerability.

== Receiving tokens

:src5: xref:introspection.adoc#src5[SRC5]
:on_erc721_received-api: xref:api/erc721.adoc#IERC721Receiver-on_erc721_received[on_erc721_received]
:computing-interface-id: xref:introspection.adoc#computing_the_interface_id[Computing the interface ID]
:safe_transfer_from-api: xref:api/erc721.adoc#IERC721-safe_transfer_from[safe_transfer_from]
:safe_mint-api: xref:api/erc721.adoc#ERC721-safe_mint[safe_mint]

In order to be sure a non-account contract can safely accept ERC721 tokens, said contract must implement the `IERC721Receiver` interface.
The recipient contract must also implement the {src5} interface which, as described earlier, supports interface introspection.

=== IERC721Receiver

:receiver-id: xref:/api/erc721.adoc#IERC721Receiver[IERC721Receiver interface ID]

[,cairo]
----
#[starknet::interface]
pub trait IERC721Receiver {
    fn on_erc721_received(
        operator: ContractAddress,
        from: ContractAddress,
        token_id: u256,
        data: Span<felt252>
    ) -> felt252;
}
----

Implementing the `IERC721Receiver` interface exposes the {on_erc721_received-api} method.
When safe methods such as {safe_transfer_from-api} and {safe_mint-api} are called, they invoke the recipient contract's `on_erc721_received` method which *must* return the {receiver-id}.
Otherwise, the transaction will fail.

TIP: For information on how to calculate interface IDs, see {computing-interface-id}.

=== Creating a token receiver contract

The Contracts for Cairo `IERC721ReceiverImpl` already returns the correct interface ID for safe token transfers.
To integrate the `IERC721Receiver` interface into a contract, simply include the ABI embed directive to the implementation and add the `initializer` in the contract's constructor.
Here's an example of a simple token receiver contract:

[,cairo]
----
#[starknet::contract]
mod MyTokenReceiver {
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_token::erc721::ERC721ReceiverComponent;
    use starknet::ContractAddress;

    component!(path: ERC721ReceiverComponent, storage: erc721_receiver, event: ERC721ReceiverEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // ERC721Receiver Mixin
    #[abi(embed_v0)]
    impl ERC721ReceiverMixinImpl = ERC721ReceiverComponent::ERC721ReceiverMixinImpl<ContractState>;
    impl ERC721ReceiverInternalImpl = ERC721ReceiverComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc721_receiver: ERC721ReceiverComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC721ReceiverEvent: ERC721ReceiverComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState) {
        self.erc721_receiver.initializer();
    }
}
----

== Storing ERC721 URIs

:solidity-impl: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/932fddf69a699a9a80fd2396fd1a2ab91cdda123/contracts/token/ERC721/ERC721.sol#L85-L93[Solidity implementation]
:token-uri: xref:/api/erc721.adoc#IERC721Metadata-token_uri[token_uri]

Token URIs were previously stored as single field elements prior to Cairo v0.2.5.
ERC721Component now stores only the base URI as a `ByteArray` and the full token URI is returned as the `ByteArray` concatenation of the base URI and the token ID through the {token-uri} method.
This design mirrors OpenZeppelin's default {solidity-impl} for ERC721.
// llmstxt-short-description: API of the ERC721 component, interface, presets and extensions

:github-icon: pass:[<svg class="icon"><use href="#github-icon"/></svg>]
:eip721: https://eips.ethereum.org/EIPS/eip-721[EIP721]
:receiving-tokens: xref:/erc721.adoc#receiving_tokens[Receiving Tokens]
:casing-discussion: https://github.com/OpenZeppelin/cairo-contracts/discussions/34[here]
:inner-src5: xref:api/introspection.adoc#ISRC5[SRC5 ID]

= ERC721

include::../utils/_common.adoc[]

This module provides interfaces, presets, and utilities related to ERC721 contracts.

TIP: For an overview of ERC721, read our xref:erc721.adoc[ERC721 guide].

== Core

[.contract]
[[IERC721]]
=== `++IERC721++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/token/src/erc721/interface.cairo#L13-L31[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_token::erc721::interface::IERC721;
```

Interface of the IERC721 standard as defined in {eip721}.

[.contract-index]
.{inner-src5}
--
0x33eb2f84c309543403fd69f0d0f363781ef06ef6faeb0131ff16ea3175bd943
--

[.contract-index]
.Functions
--
* xref:#IERC721-balance_of[`++balance_of(account)++`]
* xref:#IERC721-owner_of[`++owner_of(token_id)++`]
* xref:#IERC721-safe_transfer_from[`++safe_transfer_from(from, to, token_id, data)++`]
* xref:#IERC721-transfer_from[`++transfer_from(from, to, token_id)++`]
* xref:#IERC721-approve[`++approve(to, token_id)++`]
* xref:#IERC721-set_approval_for_all[`++set_approval_for_all(operator, approved)++`]
* xref:#IERC721-get_approved[`++get_approved(token_id)++`]
* xref:#IERC721-is_approved_for_all[`++is_approved_for_all(owner, operator)++`]
--

[.contract-index]
.Events
--
* xref:#IERC721-Approval[`++Approval(owner, approved, token_id)++`]
* xref:#IERC721-ApprovalForAll[`++ApprovalForAll(owner, operator, approved)++`]
* xref:#IERC721-Transfer[`++Transfer(from, to, token_id)++`]
--

==== Functions

[.contract-item]
[[IERC721-balance_of]]
==== `[.contract-item-name]#++balance_of++#++(account: ContractAddress) → u256++` [.item-kind]#external#

Returns the number of NFTs owned by `account`.

[.contract-item]
[[IERC721-owner_of]]
==== `[.contract-item-name]#++owner_of++#++(token_id: u256) → ContractAddress++` [.item-kind]#external#

Returns the owner address of `token_id`.

[.contract-item]
[[IERC721-safe_transfer_from]]
==== `[.contract-item-name]#++safe_transfer_from++#++(from: ContractAddress, to: ContractAddress, token_id: u256, data: Span<felt252>)++` [.item-kind]#external#

Transfer ownership of `token_id` from `from` to `to`, checking first that `to` is aware of the ERC721 protocol to prevent tokens being locked forever.
For information regarding how contracts communicate their awareness of the ERC721 protocol, see {receiving-tokens}.

Emits a <<IERC721-Transfer,Transfer>> event.

[.contract-item]
[[IERC721-transfer_from]]
==== `[.contract-item-name]#++transfer_from++#++(from: ContractAddress, to: ContractAddress, token_id: u256)++` [.item-kind]#external#

Transfer ownership of `token_id` from `from` to `to`.

Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721 transfers or else they may be permanently lost.
Usage of <<IERC721-safe_transfer_from,IERC721::safe_transfer_from>> prevents loss, though the caller must understand this adds an external call which potentially creates a reentrancy vulnerability.

Emits a <<IERC721-Transfer,Transfer>> event.

[.contract-item]
[[IERC721-approve]]
==== `[.contract-item-name]#++approve++#++(to: ContractAddress, token_id: u256)++` [.item-kind]#external#

Change or reaffirm the approved address for an NFT.

Emits an <<IERC721-Approval,Approval>> event.

[.contract-item]
[[IERC721-set_approval_for_all]]
==== `[.contract-item-name]#++set_approval_for_all++#++(operator: ContractAddress, approved: bool)++` [.item-kind]#external#

Enable or disable approval for `operator` to manage all of the caller's assets.

Emits an <<IERC721-ApprovalForAll,ApprovalForAll>> event.

[.contract-item]
[[IERC721-get_approved]]
==== `[.contract-item-name]#++get_approved++#++(token_id: u256) -> u256++` [.item-kind]#external#

Returns the address approved for `token_id`.

[.contract-item]
[[IERC721-is_approved_for_all]]
==== `[.contract-item-name]#++is_approved_for_all++#++(owner: ContractAddress, operator: ContractAddress) -> bool++` [.item-kind]#external#

Query if `operator` is an authorized operator for `owner`.

==== Events

[.contract-item]
[[IERC721-Approval]]
==== `[.contract-item-name]#++Approval++#++(owner: ContractAddress, approved: ContractAddress, token_id: u256)++` [.item-kind]#event#

Emitted when `owner` enables `approved` to manage the `token_id` token.

[.contract-item]
[[IERC721-ApprovalForAll]]
==== `[.contract-item-name]#++ApprovalForAll++#++(owner: ContractAddress, operator: ContractAddress, approved: bool)++` [.item-kind]#event#

Emitted when `owner` enables or disables `operator` to manage the `token_id` token.

[.contract-item]
[[IERC721-Transfer]]
==== `[.contract-item-name]#++Transfer++#++(from: ContractAddress, to: ContractAddress, token_id: u256)++` [.item-kind]#event#

Emitted when `token_id` token is transferred from `from` to `to`.

[.contract]
[[IERC721Metadata]]
=== `++IERC721Metadata++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/token/src/erc721/interface.cairo#L54-L59[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_token::erc721::interface::IERC721Metadata;
```

Interface for the optional metadata functions in {eip721}.

[.contract-index]
.{inner-src5}
--
0xabbcd595a567dce909050a1038e055daccb3c42af06f0add544fa90ee91f25
--

[.contract-index]
.Functions
--
* xref:#IERC721Metadata-name[`++name()++`]
* xref:#IERC721Metadata-symbol[`++symbol()++`]
* xref:#IERC721Metadata-token_uri[`++token_uri(token_id)++`]
--

==== Functions

[.contract-item]
[[IERC721Metadata-name]]
==== `[.contract-item-name]#++name++#++() -> ByteArray++` [.item-kind]#external#

Returns the NFT name.

[.contract-item]
[[IERC721Metadata-symbol]]
==== `[.contract-item-name]#++symbol++#++() -> ByteArray++` [.item-kind]#external#

Returns the NFT ticker symbol.

[.contract-item]
[[IERC721Metadata-token_uri]]
==== `[.contract-item-name]#++token_uri++#++(token_id: u256) -> ByteArray++` [.item-kind]#external#

Returns the Uniform Resource Identifier (URI) for the `token_id` token.
If the URI is not set for `token_id`, the return value will be an empty `ByteArray`.

[.contract]
[[ERC721Component]]
=== `++ERC721Component++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/token/src/erc721/erc721.cairo#L7[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_token::erc721::ERC721Component;
```

ERC721 component implementing <<IERC721,IERC721>> and <<IERC721Metadata,IERC721Metadata>>.

NOTE: {src5-component-required-note}

NOTE: See xref:#ERC721Component-Hooks[Hooks] to understand how are hooks used.

[.contract-index]
.Hooks
--
[.sub-index#ERC721Component-ERC721HooksTrait]
.ERC721HooksTrait
* xref:#ERC721Component-before_update[`++before_update(self, to, token_id, auth)++`]
* xref:#ERC721Component-after_update[`++after_update(self, to, token_id, auth)++`]
--

[.contract-index#ERC721Component-Embeddable-Mixin-Impl]
.{mixin-impls}

--
.ERC721MixinImpl
* xref:#ERC721Component-Embeddable-Impls-ERC721Impl[`++ERC721Impl++`]
* xref:#ERC721Component-Embeddable-Impls-ERC721MetadataImpl[`++ERC721MetadataImpl++`]
* xref:#ERC721Component-Embeddable-Impls-ERC721CamelOnlyImpl[`++ERC721CamelOnlyImpl++`]
* xref:#ERC721Component-Embeddable-Impls-ERC721MetadataCamelOnlyImpl[`++ERC721MetadataCamelOnlyImpl++`]
* xref:api/introspection.adoc#SRC5Component-Embeddable-Impls[`++SRC5Impl++`]
--

[.contract-index#ERC721Component-Embeddable-Impls]
.Embeddable Implementations
--
[.sub-index#ERC721Component-Embeddable-Impls-ERC721Impl]
.ERC721Impl
* xref:#ERC721Component-balance_of[`++balance_of(self, account)++`]
* xref:#ERC721Component-owner_of[`++owner_of(self, token_id)++`]
* xref:#ERC721Component-safe_transfer_from[`++safe_transfer_from(self, from, to, token_id, data)++`]
* xref:#ERC721Component-transfer_from[`++transfer_from(self, from, to, token_id)++`]
* xref:#ERC721Component-approve[`++approve(self, to, token_id)++`]
* xref:#ERC721Component-set_approval_for_all[`++set_approval_for_all(self, operator, approved)++`]
* xref:#ERC721Component-get_approved[`++get_approved(self, token_id)++`]
* xref:#ERC721Component-is_approved_for_all[`++is_approved_for_all(self, owner, operator)++`]

[.sub-index#ERC721Component-Embeddable-Impls-ERC721MetadataImpl]
.ERC721MetadataImpl
* xref:#ERC721Component-name[`++name(self)++`]
* xref:#ERC721Component-symbol[`++symbol(self)++`]
* xref:#ERC721Component-token_uri[`++token_uri(self, token_id)++`]

[.sub-index#ERC721Component-Embeddable-Impls-ERC721CamelOnlyImpl]
.ERC721CamelOnlyImpl
* xref:#ERC721Component-balanceOf[`++balanceOf(self, account)++`]
* xref:#ERC721Component-ownerOf[`++ownerOf(self, tokenId)++`]
* xref:#ERC721Component-safeTransferFrom[`++safeTransferFrom(self, from, to, tokenId, data)++`]
* xref:#ERC721Component-transferFrom[`++transferFrom(self, from, to, tokenId)++`]
* xref:#ERC721Component-setApprovalForAll[`++setApprovalForAll(self, operator, approved)++`]
* xref:#ERC721Component-getApproved[`++getApproved(self, tokenId)++`]
* xref:#ERC721Component-isApprovedForAll[`++isApprovedForAll(self, owner, operator)++`]

[.sub-index#ERC721Component-Embeddable-Impls-ERC721MetadataCamelOnlyImpl]
.ERC721MetadataCamelOnlyImpl
* xref:#ERC721Component-tokenURI[`++tokenURI(self, tokenId)++`]

.SRC5Impl
* xref:api/introspection.adoc#ISRC5-supports_interface[`supports_interface(self, interface_id: felt252)`]
--

[.contract-index]
.Internal functions
--
.InternalImpl
* xref:#ERC721Component-initializer[`++initializer(self, name, symbol, base_uri)++`]
* xref:#ERC721Component-initializer_no_metadata[`++initializer_no_metadata(self)++`]
* xref:#ERC721Component-exists[`++exists(self, token_id)++`]
* xref:#ERC721Component-transfer[`++transfer(self, from, to, token_id)++`]
* xref:#ERC721Component-mint[`++mint(self, to, token_id)++`]
* xref:#ERC721Component-safe_transfer[`++safe_transfer(self, from, to, token_id, data)++`]
* xref:#ERC721Component-safe_mint[`++safe_mint(self, to, token_id, data)++`]
* xref:#ERC721Component-burn[`++burn(self, token_id)++`]
* xref:#ERC721Component-update[`++update(self, to, token_id, auth)++`]
* xref:#ERC721Component-_owner_of[`++_owner_of(self, token_id)++`]
* xref:#ERC721Component-_require_owned[`++_require_owned(self, token_id)++`]
* xref:#ERC721Component-_approve[`++_approve(self, to, token_id, auth)++`]
* xref:#ERC721Component-_approve_with_optional_event[`++_approve_with_optional_event(self, to, token_id, auth, emit_event)++`]
* xref:#ERC721Component-_set_approval_for_all[`++_set_approval_for_all(self, owner, operator, approved)++`]
* xref:#ERC721Component-_set_base_uri[`++_set_base_uri(self, base_uri)++`]
* xref:#ERC721Component-_base_uri[`++_base_uri(self)++`]
* xref:#ERC721Component-_is_authorized[`++_is_authorized(self, owner, spender, token_id)++`]
* xref:#ERC721Component-_check_authorized[`++_check_authorized(self, owner, spender, token_id)++`]
--

[.contract-index]
.Events
--
.IERC721
* xref:#ERC721Component-Approval[`++Approval(owner, approved, token_id)++`]
* xref:#ERC721Component-ApprovalForAll[`++ApprovalForAll(owner, operator, approved)++`]
* xref:#ERC721Component-Transfer[`++Transfer(from, to, token_id)++`]
--

[#ERC721Component-Hooks]
==== Hooks

Hooks are functions which implementations can extend the functionality of the component source code. Every contract
using ERC721Component is expected to provide an implementation of the ERC721HooksTrait. For basic token contracts, an
empty implementation with no logic must be provided.

TIP: You can use `openzeppelin_token::erc721::ERC721HooksEmptyImpl` which is already available as part of the library
for this purpose.

[.contract-item]
[[ERC721Component-before_update]]
==== `[.contract-item-name]#++before_update++#++(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress)++` [.item-kind]#hook#

Function executed at the beginning of the xref:#ERC721Component-update[update] function prior to any other logic.

[.contract-item]
[[ERC721Component-after_update]]
==== `[.contract-item-name]#++after_update++#++(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress)++` [.item-kind]#hook#

Function executed at the end of the xref:#ERC721Component-update[update] function.

==== Embeddable functions

[.contract-item]
[[ERC721Component-balance_of]]
==== `[.contract-item-name]#++balance_of++#++(self: @ContractState, account: ContractAddress) → u256++` [.item-kind]#external#

See <<IERC721-balance_of,IERC721::balance_of>>.

[.contract-item]
[[ERC721Component-owner_of]]
==== `[.contract-item-name]#++owner_of++#++(self: @ContractState, token_id: u256) → ContractAddress++` [.item-kind]#external#

See <<IERC721-owner_of,IERC721::owner_of>>.

Requirements:

- `token_id` exists.

[.contract-item]
[[ERC721Component-safe_transfer_from]]
==== `[.contract-item-name]#++safe_transfer_from++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256, data: Span<felt252>)++` [.item-kind]#external#

See <<IERC721-safe_transfer_from,IERC721::safe_transfer_from>>.

Requirements:

- Caller is either approved or the `token_id` owner.
- `to` is not the zero address.
- `from` is not the zero address.
- `token_id` exists.
- `to` is either an account contract or supports the <<IERC721Receiver,IERC721Receiver>> interface.

[.contract-item]
[[ERC721Component-transfer_from]]
==== `[.contract-item-name]#++transfer_from++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256)++` [.item-kind]#external#

See <<IERC721-transfer_from,IERC721::transfer_from>>.

Requirements:

- Caller either approved or the `token_id` owner.
- `to` is not the zero address.
- `from` is not the zero address.
- `token_id` exists.

[.contract-item]
[[ERC721Component-approve]]
==== `[.contract-item-name]#++approve++#++(ref self: ContractState, to: ContractAddress, token_id: u256)++` [.item-kind]#external#

See <<IERC721-approve,IERC721::approve>>.

Requirements:

- The caller is either an approved operator or the `token_id` owner.
- `to` cannot be the token owner or the zero address.
- `token_id` exists.

[.contract-item]
[[ERC721Component-set_approval_for_all]]
==== `[.contract-item-name]#++set_approval_for_all++#++(ref self: ContractState, operator: ContractAddress, approved: bool)++` [.item-kind]#external#

See <<IERC721-set_approval_for_all,IERC721::set_approval_for_all>>.

Requirements:

- `operator` is not the zero address.

[.contract-item]
[[ERC721Component-get_approved]]
==== `[.contract-item-name]#++get_approved++#++(self: @ContractState, token_id: u256) -> u256++` [.item-kind]#external#

See <<IERC721-get_approved,IERC721::get_approved>>.

Requirements:

- `token_id` exists.

[.contract-item]
[[ERC721Component-is_approved_for_all]]
==== `[.contract-item-name]#++is_approved_for_all++#++(self: @ContractState, owner: ContractAddress, operator: ContractAddress) -> bool++` [.item-kind]#external#

See <<IERC721-is_approved_for_all,IERC721::is_approved_for_all>>.

[.contract-item]
[[ERC721Component-name]]
==== `[.contract-item-name]#++name++#++(self: @ContractState) -> ByteArray++` [.item-kind]#external#

See <<IERC721Metadata-name,IERC721Metadata::name>>.

[.contract-item]
[[ERC721Component-symbol]]
==== `[.contract-item-name]#++symbol++#++(self: @ContractState) -> ByteArray++` [.item-kind]#external#

See <<IERC721Metadata-symbol,IERC721Metadata::symbol>>.

[.contract-item]
[[ERC721Component-token_uri]]
==== `[.contract-item-name]#++token_uri++#++(self: @ContractState, token_id: u256) -> ByteArray++` [.item-kind]#external#

Returns the Uniform Resource Identifier (URI) for the `token_id` token.
If a base URI is set, the resulting URI for each token will be the concatenation of the base URI and the token ID.
For example, the base URI pass:[<code>https://token-cdn-domain/</code>] would be returned as pass:[<code>https://token-cdn-domain/123</code>] for token ID `123`.

If the URI is not set for `token_id`, the return value will be an empty `ByteArray`.

[.contract-item]
[[ERC721Component-balanceOf]]
==== `[.contract-item-name]#++balanceOf++#++(self: @ContractState, account: ContractAddress) -> u256++` [.item-kind]#external#

See <<ERC721Component-balance_of,ERC721Component::balance_of>>.

[.contract-item]
[[ERC721Component-ownerOf]]
==== `[.contract-item-name]#++ownerOf++#++(self: @ContractState, tokenId: u256) -> ContractAddress++` [.item-kind]#external#

See <<ERC721Component-owner_of,ERC721Component::owner_of>>.

[.contract-item]
[[ERC721Component-safeTransferFrom]]
==== `[.contract-item-name]#++safeTransferFrom++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, tokenId: u256, data: Span<felt252>)++` [.item-kind]#external#

See <<ERC721Component-safe_transfer_from,ERC721Component::safe_transfer_from>>.

[.contract-item]
[[ERC721Component-transferFrom]]
==== `[.contract-item-name]#++transferFrom++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, tokenId: u256)++` [.item-kind]#external#

See <<ERC721Component-transfer_from,ERC721Component::transfer_from>>.

[.contract-item]
[[ERC721Component-setApprovalForAll]]
==== `[.contract-item-name]#++setApprovalForAll++#++(ref self: ContractState, operator: ContractAddress, approved: bool)++` [.item-kind]#external#

See <<ERC721Component-set_approval_for_all,ERC721Component::set_approval_for_all>>.

[.contract-item]
[[ERC721Component-getApproved]]
==== `[.contract-item-name]#++getApproved++#++(self: @ContractState, tokenId: u256) -> ContractAddress++` [.item-kind]#external#

See <<ERC721Component-get_approved,ERC721Component::get_approved>>.

[.contract-item]
[[ERC721Component-isApprovedForAll]]
==== `[.contract-item-name]#++isApprovedForAll++#++(self: @ContractState, owner: ContractAddress, operator: ContractAddress) -> bool++` [.item-kind]#external#

See <<ERC721Component-is_approved_for_all,ERC721Component::is_approved_for_all>>.

[.contract-item]
[[ERC721Component-tokenURI]]
==== `[.contract-item-name]#++tokenURI++#++(self: @ContractState, tokenId: u256) -> ByteArray++` [.item-kind]#external#

See <<ERC721Component-token_uri,ERC721Component::token_uri>>.

==== Internal functions

[.contract-item]
[[ERC721Component-initializer]]
==== `[.contract-item-name]#++initializer++#++(ref self: ContractState, name: ByteArray, symbol: ByteArray, base_uri: ByteArray)++` [.item-kind]#internal#

Initializes the contract by setting the token name and symbol.
This should be used inside the contract's constructor.

WARNING: Most ERC721 contracts expose the <<IERC721Metadata,IERC721Metadata>> interface which
is what this initializer is meant to support.
If the contract DOES NOT expose the <<IERC721Metadata,IERC721Metadata>> interface,
meaning the token does not have a name, symbol, or URI,
the contract must instead use <<ERC721Component-initializer_no_metadata,initializer_no_metadata>> in the constructor.
Failure to abide by these instructions can lead to unexpected issues especially with
UIs.

[.contract-item]
[[ERC721Component-initializer_no_metadata]]
==== `[.contract-item-name]#++initializer_no_metadata++#++(ref self: ContractState)++` [.item-kind]#internal#

Initializes the contract with no metadata by registering only the IERC721 interface.

WARNING: This initializer should ONLY be used during construction in the very
specific instance when the contract does NOT expose the <<IERC721Metadata,IERC721Metadata>> interface.
Initializing a contract with this initializer means that tokens will not
have a name, symbol, or URI.

[.contract-item]
[[ERC721Component-exists]]
==== `[.contract-item-name]#++exists++#++(self: @ContractState, token_id: u256) -> bool++` [.item-kind]#internal#

Internal function that returns whether `token_id` exists.

Tokens start existing when they are minted (<<ERC721-mint,mint>>), and stop existing when they are burned (<<ERC721-burn,burn>>).

[.contract-item]
[[ERC721Component-transfer]]
==== `[.contract-item-name]#++transfer++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256)++` [.item-kind]#internal#

Transfers `token_id` from `from` to `to`.

Internal function without access restriction.

WARNING: This method may lead to the loss of tokens if `to` is not aware of the ERC721 protocol.

Requirements:

- `to` is not the zero address.
- `from` is the token owner.
- `token_id` exists.

Emits a <<IERC721-Transfer,Transfer>> event.

[.contract-item]
[[ERC721Component-mint]]
==== `[.contract-item-name]#++mint++#++(ref self: ContractState, to: ContractAddress, token_id: u256)++` [.item-kind]#internal#

Mints `token_id` and transfers it to `to`.
Internal function without access restriction.

WARNING: This method may lead to the loss of tokens if `to` is not aware of the ERC721 protocol.

Requirements:

- `to` is not the zero address.
- `token_id` does not exist.

Emits a <<IERC721-Transfer,Transfer>> event.

[.contract-item]
[[ERC721Component-safe_transfer]]
==== `[.contract-item-name]#++safe_transfer++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256, data: Span<felt252>)++` [.item-kind]#internal#

Transfers ownership of `token_id` from `from` if `to` is either an account or `IERC721Receiver`.

`data` is additional data, it has no specified format and is forwarded in `IERC721Receiver::on_erc721_received` to `to`.

WARNING: This method makes an external call to the recipient contract, which can lead to reentrancy vulnerabilities.

Requirements:

- `to` cannot be the zero address.
- `from` must be the token owner.
- `token_id` exists.
- `to` is either an account contract or supports the `IERC721Receiver` interface.

Emits a <<IERC721-Transfer,Transfer>> event.

[.contract-item]
[[ERC721Component-safe_mint]]
==== `[.contract-item-name]#++safe_mint++#++(ref self: ContractState, to: ContractAddress, token_id: u256, data: Span<felt252>)++` [.item-kind]#internal#

Mints `token_id` if `to` is either an account or `IERC721Receiver`.

`data` is additional data, it has no specified format and is forwarded in `IERC721Receiver::on_erc721_received` to `to`.

WARNING: This method makes an external call to the recipient contract, which can lead to reentrancy vulnerabilities.

Requirements:

- `token_id` does not exist.
- `to` is either an account contract or supports the `IERC721Receiver` interface.

Emits a <<IERC721-Transfer,Transfer>> event.

[.contract-item]
[[ERC721Component-burn]]
==== `[.contract-item-name]#++burn++#++(ref self: ContractState, token_id: u256)++` [.item-kind]#internal#

Destroys `token_id`. The approval is cleared when the token is burned.

This internal function does not check if the caller is authorized
to operate on the token.

Requirements:

- `token_id` exists.

Emits a <<IERC721-Transfer,Transfer>> event.

[.contract-item]
[[ERC721Component-update]]
==== `[.contract-item-name]#++update++#++(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress)++` [.item-kind]#internal#

Transfers `token_id` from its current owner to `to`, or alternatively mints (or burns) if the current owner
(or `to`) is the zero address. Returns the owner of the `token_id` before the update.

The `auth` argument is optional. If the value passed is non-zero, then this function will check that
`auth` is either the owner of the token, or approved to operate on the token (by the owner).

Emits a <<IERC721-Transfer,Transfer>> event.

NOTE: This function can be extended using the `ERC721HooksTrait`, to add
functionality before and/or after the transfer, mint, or burn.

[.contract-item]
[[ERC721Component-_owner_of]]
==== `[.contract-item-name]#++_owner_of++#++(self: @ContractState, token_id: felt252) -> ContractAddress++` [.item-kind]#internal#

Internal function that returns the owner address of `token_id`.

[.contract-item]
[[ERC721Component-_require_owned]]
==== `[.contract-item-name]#++_require_owned++#++(self: @ContractState, token_id: felt252) -> ContractAddress++` [.item-kind]#internal#

Version of xref:#ERC721Component-_owner_of[_owner_of] that panics if owner is the zero address.

[.contract-item]
[[ERC721Component-_approve]]
==== `[.contract-item-name]#++_approve++#++(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress)++` [.item-kind]#internal#

Approve `to` to operate on `token_id`

The `auth` argument is optional. If the value passed is non-zero, then this function will check that `auth` is
either the owner of the token, or approved to operate on all tokens held by this owner.

Emits an <<IERC721-Approval,Approval>> event.

[.contract-item]
[[ERC721Component-_approve_with_optional_event]]
==== `[.contract-item-name]#++_approve_with_optional_event++#++(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress, emit_event: bool)++` [.item-kind]#internal#

Variant of xref:#ERC721Component-_approve[_approve] with an optional flag to enable or disable the `Approval` event.
The event is not emitted in the context of transfers.

WARNING: If `auth` is zero and `emit_event` is false, this function will not check that the token exists.

Requirements:

- if `auth` is non-zero, it must be either the owner of the token or approved to
operate on all of its tokens.

May emit an <<IERC721-Approval,Approval>> event.

[.contract-item]
[[ERC721Component-_set_approval_for_all]]
==== `[.contract-item-name]#++_set_approval_for_all++#++(ref self: ContractState, owner: ContractAddress, operator: ContractAddress, approved: bool)++` [.item-kind]#internal#

Enables or disables approval for `operator` to manage
all of the `owner` assets.

Requirements:

- `operator` is not the zero address.

Emits an <<IERC721-Approval,Approval>> event.

[.contract-item]
[[ERC721Component-_set_base_uri]]
==== `[.contract-item-name]#++_set_base_uri++#++(ref self: ContractState, base_uri: ByteArray)++` [.item-kind]#internal#

Internal function that sets the `base_uri`.

[.contract-item]
[[ERC721Component-_base_uri]]
==== `[.contract-item-name]#++_base_uri++#++(self: @ContractState) -> ByteArray++` [.item-kind]#internal#

Base URI for computing <<IERC721Metadata-token_uri, token_uri>>.

If set, the resulting URI for each token will be the concatenation of the base URI and the token ID.
Returns an empty `ByteArray` if not set.

[.contract-item]
[[ERC721Component-_is_authorized]]
==== `[.contract-item-name]#++_is_authorized++#++(self: @ContractState, owner: ContractAddress, spender: ContractAddress, token_id: u256) -> bool++` [.item-kind]#internal#

Returns whether `spender` is allowed to manage ``owner``'s tokens, or `token_id` in
particular (ignoring whether it is owned by `owner`).

WARNING: This function assumes that `owner` is the actual owner of `token_id` and does not verify this
assumption.

[.contract-item]
[[ERC721Component-_check_authorized]]
==== `[.contract-item-name]#++_check_authorized++#++(self: @ContractState, owner: ContractAddress, spender: ContractAddress, token_id: u256) -> bool++` [.item-kind]#internal#

Checks if `spender` can operate on `token_id`, assuming the provided `owner` is the actual owner.

Requirements:

- `owner` cannot be the zero address.
- `spender` cannot be the zero address.
- `spender` must be the owner of `token_id` or be approved to operate on it.

WARNING: This function assumes that `owner` is the actual owner of `token_id` and does not verify this
assumption.

==== Events

[.contract-item]
[[ERC721Component-Approval]]
==== `[.contract-item-name]#++Approval++#++(owner: ContractAddress, approved: ContractAddress, token_id: u256)++` [.item-kind]#event#

See <<IERC721-Approval,IERC721::Approval>>.

[.contract-item]
[[ERC721Component-ApprovalForAll]]
==== `[.contract-item-name]#++ApprovalForAll++#++(owner: ContractAddress, operator: ContractAddress, approved: bool)++` [.item-kind]#event#

See <<IERC721-ApprovalForAll,IERC721::ApprovalForAll>>.

[.contract-item]
[[ERC721Component-Transfer]]
==== `[.contract-item-name]#++Transfer++#++(from: ContractAddress, to: ContractAddress, token_id: u256)++` [.item-kind]#event#

See <<IERC721-Transfer,IERC721::Transfer>>.

== Receiver

[.contract]
[[IERC721Receiver]]
=== `++IERC721Receiver++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/token/src/erc721/interface.cairo#L70-L79[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_token::erc721::interface::IERC721Receiver;
```

Interface for contracts that support receiving `safe_transfer_from` transfers.

[.contract-index]
.{inner-src5}
--
0x3a0dff5f70d80458ad14ae37bb182a728e3c8cdda0402a5daa86620bdf910bc
--

[.contract-index]
.Functions
--
* xref:#IERC721Receiver-on_erc721_received[`++on_erc721_received(operator, from, token_id, data)++`]
--

==== Functions

[.contract-item]
[[IERC721Receiver-on_erc721_received]]
==== `[.contract-item-name]#++on_erc721_received++#++(operator: ContractAddress, from: ContractAddress, token_id: u256, data: Span<felt252>) -> felt252++` [.item-kind]#external#

Whenever an IERC721 `token_id` token is transferred to this non-account contract via <<IERC721-safe_transfer_from,IERC721::safe_transfer_from>> by `operator` from `from`, this function is called.

[.contract]
[[ERC721ReceiverComponent]]
=== `++ERC721ReceiverComponent++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/token/src/erc721/erc721_receiver.cairo[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_token::erc721::ERC721ReceiverComponent;
```

ERC721Receiver component implementing <<IERC721Receiver,IERC721Receiver>>.

NOTE: {src5-component-required-note}

[.contract-index#ERC721ReceiverComponent-Embeddable-Mixin-Impl]
.{mixin-impls}

--
.ERCReceiverMixinImpl
* xref:#ERC721ReceiverComponent-Embeddable-Impls-ERC721ReceiverImpl[`++ERC721ReceiverImpl++`]
* xref:#ERC721ReceiverComponent-Embeddable-Impls-ERC721ReceiverCamelImpl[`++ERC721ReceiverCamelImpl++`]
* xref:api/introspection.adoc#SRC5Component-Embeddable-Impls[`++SRC5Impl++`]
--

[.contract-index#ERC721ReceiverComponent-Embeddable-Impls]
.Embeddable Implementations
--
[.sub-index#ERC721ReceiverComponent-Embeddable-Impls-ERC721ReceiverImpl]
.ERC721ReceiverImpl
* xref:#ERC721ReceiverComponent-on_erc721_received[`++on_erc721_received(self, operator, from, token_id, data)++`]

[.sub-index#ERC721ReceiverComponent-Embeddable-Impls-ERC721ReceiverCamelImpl]
.ERC721ReceiverCamelImpl
* xref:#ERC721ReceiverComponent-onERC721Received[`++onERC721Received(self, operator, from, tokenId, data)++`]
--

[.contract-index]
.Internal Functions
--
.InternalImpl
* xref:#ERC721ReceiverComponent-initializer[`++initializer(self)++`]
--

==== Embeddable functions

[.contract-item]
[[ERC721ReceiverComponent-on_erc721_received]]
==== `[.contract-item-name]#++on_erc721_received++#++(self: @ContractState, operator: ContractAddress, from: ContractAddress, token_id: u256, data Span<felt252>) -> felt252++` [.item-kind]#external#

Returns the `IERC721Receiver` interface ID.

[.contract-item]
[[ERC721ReceiverComponent-onERC721Received]]
==== `[.contract-item-name]#++onERC721Received++#++(self: @ContractState, operator: ContractAddress, from: ContractAddress, token_id: u256, data Span<felt252>) -> felt252++` [.item-kind]#external#

See <<ERC721ReceiverComponent-on_erc721_received,ERC721ReceiverComponent::on_erc721_received>>.

==== Internal functions

[.contract-item]
[[ERC721ReceiverComponent-initializer]]
==== `[.contract-item-name]#++initializer++#++(ref self: ContractState)++` [.item-kind]#internal#

Registers the `IERC721Receiver` interface ID as supported through introspection.

== Extensions

[.contract]
[[IERC721Enumerable]]
=== `++IERC721Enumerable++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/token/src/erc721/extensions/erc721_enumerable/interface.cairo[{github-icon},role=heading-link]

Interface for the optional enumerable functions in {eip721}.

[.contract-index]
.{inner-src5}
--
0x16bc0f502eeaf65ce0b3acb5eea656e2f26979ce6750e8502a82f377e538c87
--

[.contract-index]
.Functions
--
* xref:#IERC721Enumerable-total_supply[`++total_supply()++`]
* xref:#IERC721Enumerable-token_by_index[`++token_by_index(index)++`]
* xref:#IERC721Enumerable-token_of_owner_by_index[`++token_of_owner_by_index(owner, index)++`]
--

==== Functions

[.contract-item]
[[IERC721Enumerable-total_supply]]
==== `[.contract-item-name]#++total_supply++#++() -> u256++` [.item-kind]#external#

Returns the total amount of tokens stored by the contract.

[.contract-item]
[[IERC721Enumerable-token_by_index]]
==== `[.contract-item-name]#++token_by_index++#++(index: u256) -> u256++` [.item-kind]#external#

Returns a token id at a given `index` of all the tokens stored by the contract.
Use along with xref:#IERC721Enumerable-total_supply[IERC721Enumerable::total_supply] to enumerate all tokens.

[.contract-item]
[[IERC721Enumerable-token_of_owner_by_index]]
==== `[.contract-item-name]#++token_of_owner_by_index++#++(owner: ContractAddress, index: u256) -> u256++` [.item-kind]#external#

Returns the token id owned by `owner` at a given `index` of its token list.
Use along with xref:#IERC721-balance_of[IERC721::balance_of] to enumerate all of ``owner``'s tokens.

[.contract]
[[ERC721EnumerableComponent]]
=== `++ERC721EnumerableComponent++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/token/src/erc721/extensions/erc721_enumerable.cairo[{github-icon},role=heading-link]

```cairo
use openzeppelin_token::erc721::extensions::ERC721EnumerableComponent;
```

Extension of ERC721 as defined in the EIP that adds enumerability of all the token ids in the contract as well as all token ids owned by each account.
This extension allows contracts to publish their entire list of NFTs and make them discoverable.

NOTE: Implementing xref:#ERC721Component[ERC721Component] is a requirement for this component to be implemented.

To properly track token ids, this extension requires that the xref:#ERC721EnumerableComponent-before_update[ERC721EnumerableComponent::before_update] function is called before every transfer, mint, or burn operation.
For this, the xref:ERC721Component-before_update[ERC721HooksTrait::before_update] hook must be used.
Here's how the hook should be implemented in a contract:

```[,cairo]
#[starknet::contract]
mod ERC721EnumerableContract {
    (...)

    component!(path: ERC721Component, storage: erc721, event: ERC721Event);
    component!(path: ERC721EnumerableComponent, storage: erc721_enumerable, event: ERC721EnumerableEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    impl ERC721HooksImpl of ERC721Component::ERC721HooksTrait<ContractState> {
        fn before_update(
            ref self: ERC721Component::ComponentState<ContractState>,
            to: ContractAddress,
            token_id: u256,
            auth: ContractAddress
        ) {
            let mut contract_state = self.get_contract_mut();
            contract_state.erc721_enumerable.before_update(to, token_id);
        }
    }
}
```

[.contract-index#ERC721EnumerableComponent-Embeddable-Impls]
.Embeddable Implementations
--
[.sub-index#ERC721EnumerableComponent-Embeddable-Impls-ERC721EnumerableImpl]
.ERC721EnumerableImpl
* xref:#ERC721EnumerableComponent-total_supply[`++total_supply(self)++`]
* xref:#ERC721EnumerableComponent-token_by_index[`++token_by_index(self, index)++`]
* xref:#ERC721EnumerableComponent-token_of_owner_by_index[`++token_of_owner_by_index(self, address, index)++`]
--

[.contract-index]
.Internal functions
--
.InternalImpl
* xref:#ERC721EnumerableComponent-initializer[`++initializer(self)++`]
* xref:#ERC721EnumerableComponent-before_update[`++before_update(self, to, token_id)++`]
* xref:#ERC721EnumerableComponent-all_tokens_of_owner[`++all_tokens_of_owner(self, owner)++`]
* xref:#ERC721EnumerableComponent-_add_token_to_owner_enumeration[`++_add_token_to_owner_enumeration(self, to, token_id)++`]
* xref:#ERC721EnumerableComponent-_add_token_to_all_tokens_enumeration[`++_add_token_to_all_tokens_enumeration(self, token_id)++`]
* xref:#ERC721EnumerableComponent-_remove_token_from_owner_enumeration[`++_remove_token_from_owner_enumeration(self, from, token_id)++`]
* xref:#ERC721EnumerableComponent-_remove_token_from_all_tokens_enumeration[`++_remove_token_from_all_tokens_enumeration(self, token_id)++`]
--

[#ERC721EnumerableComponent-Embeddable-functions]
==== Embeddable functions

[.contract-item]
[[ERC721EnumerableComponent-total_supply]]
==== `[.contract-item-name]#++total_supply++#++(self: @ContractState) → u256++` [.item-kind]#external#

Returns the current amount of votes that `account` has.

[.contract-item]
[[ERC721EnumerableComponent-token_by_index]]
==== `[.contract-item-name]#++token_by_index++#++(self: @ContractState, index: u256) → u256++` [.item-kind]#external#

See xref:#IERC721Enumerable-token_by_index[IERC721Enumerable::token_by_index].

Requirements:

- `index` is less than the total token supply.

[.contract-item]
[[ERC721EnumerableComponent-token_of_owner_by_index]]
==== `[.contract-item-name]#++token_of_owner_by_index++#++(self: @ContractState, owner: ContractAddress, index: u256) → u256++` [.item-kind]#external#

See xref:#IERC721Enumerable-token_of_owner_by_index[IERC721Enumerable::token_of_owner_by_index].

Requirements:

- `index` is less than ``owner``'s token balance.
- `owner` is not the zero address.

[#ERC721EnumerableComponent-Internal-functions]
==== Internal functions

[.contract-item]
[[ERC721EnumerableComponent-initializer]]
==== `[.contract-item-name]#++initializer++#++(ref self: ContractState)++` [.item-kind]#internal#

Registers the `IERC721Enumerable` interface ID as supported through introspection.

[.contract-item]
[[ERC721EnumerableComponent-before_update]]
==== `[.contract-item-name]#++before_update++#++(ref self: ContractState, to: ContractAddress, token_id: u256)++` [.item-kind]#internal#

Updates the ownership and token-tracking data structures.

When a token is minted (or burned), `token_id` is added to (or removed from) the token-tracking structures.

When a token is transferred, minted, or burned, the ownership-tracking data structures reflect the change in ownership of `token_id`.

This must be added to the implementing contract's xref:ERC721Component-before_update[ERC721HooksTrait::before_update] hook.

[.contract-item]
[[ERC721EnumerableComponent-all_tokens_of_owner]]
==== `[.contract-item-name]#++all_tokens_of_owner++#++(self: @ContractState, owner: ContractAddress) → Span<u256>++` [.item-kind]#internal#

Returns a list of all token ids owned by the specified `owner`.
This function provides a more efficient alternative to calling `ERC721::balance_of`
and iterating through tokens with `ERC721Enumerable::token_of_owner_by_index`.

Requirements:

- `owner` is not the zero address.

[.contract-item]
[[ERC721EnumerableComponent-_add_token_to_owner_enumeration]]
==== `[.contract-item-name]#++_add_token_to_owner_enumeration++#++(ref self: ContractState, to: ContractAddress, token_id: u256)++` [.item-kind]#internal#

Adds token to this extension's ownership-tracking data structures.

[.contract-item]
[[ERC721EnumerableComponent-_add_token_to_all_tokens_enumeration]]
==== `[.contract-item-name]#++_add_token_to_all_tokens_enumeration++#++(ref self: ContractState, token_id: u256)++` [.item-kind]#internal#

Adds token to this extension's token-tracking data structures.

[.contract-item]
[[ERC721EnumerableComponent-_remove_token_from_owner_enumeration]]
==== `[.contract-item-name]#++_remove_token_from_owner_enumeration++#++(ref self: ContractState, from: ContractAddress, token_id: u256)++` [.item-kind]#internal#

Removes a token from this extension's ownership-tracking data structures.

This has 0(1) time complexity but alters the indexed order of owned tokens by swapping `token_id` and the index thereof with the last token id and the index thereof e.g. removing `1` from `[1, 2, 3, 4]` results in `[4, 2, 3]`.

[.contract-item]
[[ERC721EnumerableComponent-_remove_token_from_all_tokens_enumeration]]
==== `[.contract-item-name]#++_remove_token_from_all_tokens_enumeration++#++(ref self: ContractState, token_id: u256)++` [.item-kind]#internal#

Removes `token_id` from this extension's token-tracking data structures.

This has 0(1) time complexity but alters the indexed order by swapping `token_id` and the index thereof with the last token id and the index thereof e.g. removing `1` from `[1, 2, 3, 4]` results in `[4, 2, 3]`.

== Presets

[.contract]
[[ERC721Upgradeable]]
=== `++ERC721Upgradeable++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/presets/src/erc721.cairo[{github-icon},role=heading-link]

```cairo
use openzeppelin_presets::ERC721Upgradeable;
```

Upgradeable ERC721 contract leveraging xref:#ERC721Component[ERC721Component].

include::../utils/_class_hashes.adoc[]

[.contract-index]
.{presets-page}
--
{ERC721Upgradeable-class-hash}
--

[.contract-index]
.Constructor
--
* xref:#ERC721Upgradeable-constructor[`++constructor(self, name, symbol, recipient, token_ids, base_uri, owner)++`]
--

[.contract-index]
.Embedded Implementations
--
.ERC721MixinImpl

* xref:#ERC721Component-Embeddable-Mixin-Impl[`++ERC721MixinImpl++`]

.OwnableMixinImpl

* xref:/api/access.adoc#OwnableComponent-Mixin-Impl[`++OwnableMixinImpl++`]
--

[.contract-index]
.External Functions
--
* xref:#ERC721Upgradeable-upgrade[`++upgrade(self, new_class_hash)++`]
--

[#ERC721Upgradeable-constructor-section]
==== Constructor

[.contract-item]
[[ERC721Upgradeable-constructor]]
==== `[.contract-item-name]#++constructor++#++(ref self: ContractState, name: ByteArray, symbol: ByteArray, recipient: ContractAddress, token_ids: Span<u256>, base_uri: ByteArray, owner: ContractAddress)++` [.item-kind]#constructor#

Sets the `name` and `symbol`.
Mints `token_ids` tokens to `recipient` and sets the `base_uri`.
Assigns `owner` as the contract owner with permissions to upgrade.

[#ERC721Upgradeable-external-functions]
==== External functions

[.contract-item]
[[ERC721Upgradeable-upgrade]]
==== `[.contract-item-name]#++upgrade++#++(ref self: ContractState, new_class_hash: ClassHash)++` [.item-kind]#external#

Upgrades the contract to a new implementation given by `new_class_hash`.

Requirements:

- The caller is the contract owner.
- `new_class_hash` cannot be zero.
// llmstxt-short-description: Describes the ERC1155 token standard and its usage

:eip-1155: https://eips.ethereum.org/EIPS/eip-1155[EIP-1155]
:fungibility-agnostic: https://docs.openzeppelin.com/contracts/5.x/tokens#different-kinds-of-tokens[fungibility-agnostic]

= ERC1155

The ERC1155 multi token standard is a specification for {fungibility-agnostic} token contracts.
The ERC1155 library implements an approximation of {eip-1155} in Cairo for StarkNet.

== Multi Token Standard

:balance_of-api: xref:api/erc1155.adoc#IERC1155-balance_of[balance_of]
:erc721-balance_of-api: xref:api/erc721.adoc#IERC721-balance_of[balance_of]

The distinctive feature of ERC1155 is that it uses a single smart contract to represent multiple tokens at once. This
is why its {balance_of-api} function differs from ERC20’s and ERC777’s: it has an additional ID argument for the
identifier of the token that you want to query the balance of.

This is similar to how ERC721 does things, but in that standard a token ID has no concept of balance: each token is
non-fungible and exists or doesn’t. The ERC721 {erc721-balance_of-api} function refers to how many different tokens an account
has, not how many of each. On the other hand, in ERC1155 accounts have a distinct balance for each token ID, and
non-fungible tokens are implemented by simply minting a single one of them.

This approach leads to massive gas savings for projects that require multiple tokens. Instead of deploying a new
contract for each token type, a single ERC1155 token contract can hold the entire system state, reducing deployment
costs and complexity.

== Usage

Using Contracts for Cairo, constructing an ERC1155 contract requires integrating both `ERC1155Component` and `SRC5Component`.
The contract should also set up the constructor to initialize the token's URI and interface support.
Here's an example of a basic contract:

[,cairo]
----
#[starknet::contract]
mod MyERC1155 {
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_token::erc1155::{ERC1155Component, ERC1155HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: ERC1155Component, storage: erc1155, event: ERC1155Event);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // ERC1155 Mixin
    #[abi(embed_v0)]
    impl ERC1155MixinImpl = ERC1155Component::ERC1155MixinImpl<ContractState>;
    impl ERC1155InternalImpl = ERC1155Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc1155: ERC1155Component::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC1155Event: ERC1155Component::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        token_uri: ByteArray,
        recipient: ContractAddress,
        token_ids: Span<u256>,
        values: Span<u256>
    ) {
        self.erc1155.initializer(token_uri);
        self
            .erc1155
            .batch_mint_with_acceptance_check(recipient, token_ids, values, array![].span());
    }
}
----

== Interface

:compatibility: xref:/erc1155.adoc#erc1155_compatibility[ERC1155 Compatibility]
:isrc5-interface: xref:/api/introspection.adoc#ISRC5[ISRC5]
:ierc1155-interface: xref:/api/erc1155.adoc#IERC1155[IERC1155]
:ierc1155metadata-interface: xref:/api/erc1155.adoc#IERC1155MetadataURI[IERC1155MetadataURI]
:erc1155-component: xref:/api/erc1155.adoc#ERC1155Component[ERC1155Component]
:dual-interfaces: xref:interfaces.adoc#dual_interfaces[Dual interfaces]

The following interface represents the full ABI of the Contracts for Cairo {erc1155-component}.
The interface includes the {ierc1155-interface} standard interface and the optional {ierc1155metadata-interface} interface together with {isrc5-interface}.

To support older token deployments, as mentioned in {dual-interfaces}, the component also includes implementations of the interface written in camelCase.

[,cairo]
----
#[starknet::interface]
pub trait ERC1155ABI {
    // IERC1155
    fn balance_of(account: ContractAddress, token_id: u256) -> u256;
    fn balance_of_batch(
        accounts: Span<ContractAddress>, token_ids: Span<u256>
    ) -> Span<u256>;
    fn safe_transfer_from(
        from: ContractAddress,
        to: ContractAddress,
        token_id: u256,
        value: u256,
        data: Span<felt252>
    );
    fn safe_batch_transfer_from(
        from: ContractAddress,
        to: ContractAddress,
        token_ids: Span<u256>,
        values: Span<u256>,
        data: Span<felt252>
    );
    fn is_approved_for_all(
        owner: ContractAddress, operator: ContractAddress
    ) -> bool;
    fn set_approval_for_all(operator: ContractAddress, approved: bool);

    // IERC1155MetadataURI
    fn uri(token_id: u256) -> ByteArray;

    // ISRC5
    fn supports_interface(interface_id: felt252) -> bool;

    // IERC1155Camel
    fn balanceOf(account: ContractAddress, tokenId: u256) -> u256;
    fn balanceOfBatch(
        accounts: Span<ContractAddress>, tokenIds: Span<u256>
    ) -> Span<u256>;
    fn safeTransferFrom(
        from: ContractAddress,
        to: ContractAddress,
        tokenId: u256,
        value: u256,
        data: Span<felt252>
    );
    fn safeBatchTransferFrom(
        from: ContractAddress,
        to: ContractAddress,
        tokenIds: Span<u256>,
        values: Span<u256>,
        data: Span<felt252>
    );
    fn isApprovedForAll(owner: ContractAddress, operator: ContractAddress) -> bool;
    fn setApprovalForAll(operator: ContractAddress, approved: bool);
}
----

== ERC1155 Compatibility

Although Starknet is not EVM compatible, this implementation aims to be as close as possible to the ERC1155 standard but some differences can still be found, such as:

* The optional `data` argument in both `safe_transfer_from` and `safe_batch_transfer_from` is implemented as `Span<felt252>`.
* `IERC1155Receiver` compliant contracts must implement SRC5 and register the `IERC1155Receiver` interface ID.
* `IERC1155Receiver::on_erc1155_received` must return that interface ID on success.

== Batch operations

:safe_transfer_from: xref:/api/erc1155.adoc#IERC1155-safe_transfer_from[safe_transfer_from]
:balance_of_batch: xref:/api/erc1155.adoc#IERC1155-balance_of_batch[balance_of_batch]
:safe_batch_transfer_from: xref:/api/erc1155.adoc#IERC1155-safe_batch_transfer_from[safe_batch_transfer_from]
:batch_mint_with_acceptance_check: xref:/api/erc1155.adoc#ERC1155Component-batch_mint_with_acceptance_check[batch_mint_with_acceptance_check]

Because all state is held in a single contract, it is possible to operate over multiple tokens in a single transaction very efficiently. The standard provides two functions, {balance_of_batch} and {safe_batch_transfer_from}, that make querying multiple balances and transferring multiple tokens simpler and less gas-intensive. We also have {safe_transfer_from} for non-batch operations.

In the spirit of the standard, we’ve also included batch operations in the non-standard functions, such as
{batch_mint_with_acceptance_check}.

WARNING: While {safe_transfer_from} and {safe_batch_transfer_from} prevent loss by checking the receiver can handle the
tokens, this yields execution to the receiver which can result in a xref:security.adoc#reentrancy_guard[reentrant call].

== Receiving tokens

:src5: xref:introspection.adoc#src5[SRC5]
:on_erc1155_received: xref:/api/erc1155.adoc#IERC1155Receiver-on_erc1155_received[on_erc1155_received]
:on_erc1155_batch_received: xref:/api/erc1155.adoc#IERC1155Receiver-on_erc1155_batch_received[on_erc1155_batch_received]
:computing-interface-id: xref:introspection.adoc#computing_the_interface_id[Computing the interface ID]

In order to be sure a non-account contract can safely accept ERC1155 tokens, said contract must implement the `IERC1155Receiver` interface.
The recipient contract must also implement the {src5} interface which supports interface introspection.

=== IERC1155Receiver

:receiver-id: xref:/api/erc1155.adoc#IERC1155Receiver[IERC1155Receiver interface ID]

[,cairo]
----
#[starknet::interface]
pub trait IERC1155Receiver {
    fn on_erc1155_received(
        operator: ContractAddress,
        from: ContractAddress,
        token_id: u256,
        value: u256,
        data: Span<felt252>
    ) -> felt252;
    fn on_erc1155_batch_received(
        operator: ContractAddress,
        from: ContractAddress,
        token_ids: Span<u256>,
        values: Span<u256>,
        data: Span<felt252>
    ) -> felt252;
}
----

Implementing the `IERC1155Receiver` interface exposes the {on_erc1155_received} and {on_erc1155_batch_received} methods.
When {safe_transfer_from} and {safe_batch_transfer_from} are called, they invoke the recipient contract's `on_erc1155_received` or `on_erc1155_batch_received` methods respectively which *must* return the {receiver-id}.
Otherwise, the transaction will fail.

TIP: For information on how to calculate interface IDs, see {computing-interface-id}.

=== Creating a token receiver contract

:ERC1155ReceiverComponent: xref:/api/erc1155.adoc#ERC1155ReceiverComponent[ERC1155ReceiverComponent]

The Contracts for Cairo {ERC1155ReceiverComponent} already returns the correct interface ID for safe token transfers.
To integrate the `IERC1155Receiver` interface into a contract, simply include the ABI embed directive to the implementations and add the `initializer` in the contract's constructor.
Here's an example of a simple token receiver contract:

[,cairo]
----
#[starknet::contract]
mod MyTokenReceiver {
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_token::erc1155::ERC1155ReceiverComponent;
    use starknet::ContractAddress;

    component!(path: ERC1155ReceiverComponent, storage: erc1155_receiver, event: ERC1155ReceiverEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // ERC1155Receiver Mixin
    #[abi(embed_v0)]
    impl ERC1155ReceiverMixinImpl = ERC1155ReceiverComponent::ERC1155ReceiverMixinImpl<ContractState>;
    impl ERC1155ReceiverInternalImpl = ERC1155ReceiverComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc1155_receiver: ERC1155ReceiverComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC1155ReceiverEvent: ERC1155ReceiverComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState) {
        self.erc1155_receiver.initializer();
    }
}
----
// llmstxt-short-description: API of the ERC1155 component, interface, presets and extensions

:github-icon: pass:[<svg class="icon"><use href="#github-icon"/></svg>]
:eip1155: https://eips.ethereum.org/EIPS/eip-1155[EIP1155]
:eip1155-metadata: https://eips.ethereum.org/EIPS/eip-1155#metadata
:receiving-tokens: xref:/erc1155.adoc#receiving_tokens[Receiving tokens]
:inner-src5: xref:api/introspection.adoc#ISRC5[SRC5 ID]

= ERC1155

include::../utils/_common.adoc[]

This module provides interfaces, presets, and utilities related to ERC1155 contracts.

TIP: For an overview of ERC1155, read our xref:erc1155.adoc[ERC1155 guide].

== Core

[.contract]
[[IERC1155]]
=== `++IERC1155++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/token/src/erc1155/interface.cairo[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_token::erc1155::interface::IERC1155;
```
Interface of the IERC1155 standard as defined in {eip1155}.

[.contract-index]
.{inner-src5}
--
0x6114a8f75559e1b39fcba08ce02961a1aa082d9256a158dd3e64964e4b1b52
--

[.contract-index]
.Functions
--
* xref:#IERC1155-balance_of[`++balance_of(account, token_id)++`]
* xref:#IERC1155-balance_of_batch[`++balance_of_batch(accounts, token_ids)++`]
* xref:#IERC1155-safe_transfer_from[`++safe_transfer_from(from, to, token_id, value, data)++`]
* xref:#IERC1155-safe_batch_transfer_from[`++safe_batch_transfer_from(from, to, token_ids, values, data)++`]
* xref:#IERC1155-set_approval_for_all[`++set_approval_for_all(operator, approved)++`]
* xref:#IERC1155-is_approved_for_all[`++is_approved_for_all(owner, operator)++`]
--

[.contract-index]
.Events
--
* xref:#IERC1155-TransferSingle[`++TransferSingle(operator, from, to, id, value)++`]
* xref:#IERC1155-TransferBatch[`++TransferBatch(operator, from, to, ids, values)++`]
* xref:#IERC1155-ApprovalForAll[`++ApprovalForAll(owner, operator, approved)++`]
* xref:#IERC1155-URI[`++URI(value, id)++`]
--

==== Functions

[.contract-item]
[[IERC1155-balance_of]]
==== `[.contract-item-name]#++balance_of++#++(account: ContractAddress, token_id: u256) → u256++` [.item-kind]#external#

Returns the amount of `token_id` tokens owned by `account`.

[.contract-item]
[[IERC1155-balance_of_batch]]
==== `[.contract-item-name]#++balance_of_batch++#++(accounts: Span<ContractAddress>, token_ids: Span<u256>) → Span<u256>++` [.item-kind]#external#

Returns a list of balances derived from the `accounts` and `token_ids` pairs.

[.contract-item]
[[IERC1155-safe_transfer_from]]
==== `[.contract-item-name]#++safe_transfer_from++#++(from: ContractAddress, to: ContractAddress, token_id: u256,  value: u256, data: Span<felt252>)++` [.item-kind]#external#

Transfers ownership of `value` amount of `token_id` from `from` if `to` is either `IERC1155Receiver` or an account.

`data` is additional data, it has no specified format and it is passed to `to`.

Emits a <<IERC1155-TransferSingle,TransferSingle>> event.

[.contract-item]
[[IERC1155-safe_batch_transfer_from]]
==== `[.contract-item-name]#++safe_batch_transfer_from++#++(from: ContractAddress, to: ContractAddress, token_ids: Span<u256>, values: Span<u256>, data: Span<felt252>)++` [.item-kind]#external#

Transfers ownership of `token_ids` and `values` pairs from `from` if `to` is either `IERC1155Receiver` or an account.

`data` is additional data, it has no specified format and it is passed to `to`.

Emits a <<IERC1155-TransferBatch,TransferBatch>> event.

[.contract-item]
[[IERC1155-set_approval_for_all]]
==== `[.contract-item-name]#++set_approval_for_all++#++(operator: ContractAddress, approved: bool)++` [.item-kind]#external#

Enables or disables approval for `operator` to manage all of the caller's assets.

Emits an <<IERC1155-ApprovalForAll,ApprovalForAll>> event.

[.contract-item]
[[IERC1155-is_approved_for_all]]
==== `[.contract-item-name]#++is_approved_for_all++#++(owner: ContractAddress, operator: ContractAddress) -> bool++` [.item-kind]#external#

Queries if `operator` is an authorized operator for `owner`.

==== Events

[.contract-item]
[[IERC1155-TransferSingle]]
==== `[.contract-item-name]#++TransferSingle++#++(operator: ContractAddress, from: ContractAddress, to: ContractAddress, id: u256, value: u256)++` [.item-kind]#event#

Emitted when `value` amount of `id` token is transferred from `from` to `to` through `operator`.

[.contract-item]
[[IERC1155-TransferBatch]]
==== `[.contract-item-name]#++TransferBatch++#++(operator: ContractAddress, from: ContractAddress, to: ContractAddress, ids: Span<u256>, values: Span<u256>)++` [.item-kind]#event#

Emitted when a batch of `values` amount of `ids` tokens are transferred from `from` to `to` through `operator`.

[.contract-item]
[[IERC1155-ApprovalForAll]]
==== `[.contract-item-name]#++ApprovalForAll++#++(owner: ContractAddress, operator: ContractAddress, approved: bool)++` [.item-kind]#event#

Emitted when `owner` enables or disables `operator` to manage all of the owner's assets.

[.contract-item]
[[IERC1155-URI]]
==== `[.contract-item-name]#++URI++#++(value: ByteArray, id: u256)++` [.item-kind]#event#

Emitted when the token URI is updated to `value` for the `id` token.

[.contract]
[[IERC1155MetadataURI]]
=== `++IERC1155MetadataURI++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/token/src/erc1155/interface.cairo[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_token::erc1155::interface::IERC1155MetadataURI;
```
Interface for the optional metadata function in {eip1155-metadata}[EIP1155].

[.contract-index]
.{inner-src5}
--
0xcabe2400d5fe509e1735ba9bad205ba5f3ca6e062da406f72f113feb889ef7
--

[.contract-index]
.Functions
--
* xref:#IERC1155MetadataURI-uri[`++uri(token_id)++`]
--

==== Functions

[.contract-item]
[[IERC1155MetadataURI-uri]]
==== `[.contract-item-name]#++uri++#++(token_id: u256) -> ByteArray++` [.item-kind]#external#

Returns the Uniform Resource Identifier (URI) for the `token_id` token.

[.contract]
[[ERC1155Component]]
=== `++ERC1155Component++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/token/src/erc1155/erc1155.cairo[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_token::erc1155::ERC1155Component;
```

ERC1155 component implementing <<IERC1155,IERC1155>> and <<IERC1155MetadataURI,IERC1155MetadataURI>>.

NOTE: {src5-component-required-note}

NOTE: See xref:#ERC1155Component-Hooks[Hooks] to understand how are hooks used.

[.contract-index]
.Hooks
--
[.sub-index#ERC1155Component-ERC1155HooksTrait]
.ERC1155HooksTrait
* xref:#ERC1155Component-before_update[`++before_update(self, from, to, token_ids, values)++`]
* xref:#ERC1155Component-after_update[`++after_update(self, from, to, token_ids, values)++`]
--

[.contract-index#ERC1155Component-Embeddable-Mixin-Impl]
.{mixin-impls}

--
.ERC1155MixinImpl
* xref:#ERC1155Component-Embeddable-Impls-ERC1155Impl[`++ERC1155Impl++`]
* xref:#ERC1155Component-Embeddable-Impls-ERC1155MetadataURIImpl[`++ERC1155MetadataURIImpl++`]
* xref:#ERC1155Component-Embeddable-Impls-ERC1155CamelImpl[`++ERC1155CamelImpl++`]
* xref:api/introspection.adoc#SRC5Component-Embeddable-Impls-SRC5Impl[`++SRC5Impl++`]
--

[.contract-index#ERC1155Component-Embeddable-Impls]
.Embeddable Implementations
--
[.sub-index#ERC1155Component-Embeddable-Impls-ERC1155Impl]
.ERC1155Impl
* xref:#ERC1155Component-balance_of[`++balance_of(self, account, token_id)++`]
* xref:#ERC1155Component-balance_of_batch[`++balance_of_batch(self, accounts, token_ids)++`]
* xref:#ERC1155Component-safe_transfer_from[`++safe_transfer_from(self, from, to, token_id, value, data)++`]
* xref:#ERC1155Component-safe_batch_transfer_from[`++safe_batch_transfer_from(self, from, to, token_ids, values, data)++`]
* xref:#ERC1155Component-set_approval_for_all[`++set_approval_for_all(self, operator, approved)++`]
* xref:#ERC1155Component-is_approved_for_all[`++is_approved_for_all(self, owner, operator)++`]

[.sub-index#ERC1155Component-Embeddable-Impls-ERC1155MetadataURIImpl]
.ERC1155MetadataURIImpl
* xref:#ERC1155Component-uri[`++uri(self, token_id)++`]

[.sub-index#ERC1155Component-Embeddable-Impls-ERC1155CamelImpl]
.ERC1155CamelImpl
* xref:#ERC1155Component-balanceOf[`++balanceOf(self, account, tokenId)++`]
* xref:#ERC1155Component-balanceOfBatch[`++balanceOfBatch(self, accounts, tokenIds)++`]
* xref:#ERC1155Component-safeTransferFrom[`++safeTransferFrom(self, from, to, tokenId, value, data)++`]
* xref:#ERC1155Component-safeBatchTransferFrom[`++safeBatchTransferFrom(self, from, to, tokenIds, values, data)++`]
* xref:#ERC1155Component-setApprovalForAll[`++setApprovalForAll(self, operator, approved)++`]
* xref:#ERC1155Component-isApprovedForAll[`++isApprovedForAll(self, owner, operator)++`]
--

[.contract-index]
.Internal Functions
--
.InternalImpl
* xref:#ERC1155Component-initializer[`++initializer(self, base_uri)++`]
* xref:#ERC1155Component-initializer_no_metadata[`++initializer_no_metadata(self)++`]
* xref:#ERC1155Component-mint_with_acceptance_check[`++mint_with_acceptance_check(self, to, token_id, value, data)++`]
* xref:#ERC1155Component-batch_mint_with_acceptance_check[`++batch_mint_with_acceptance_check(self, to, token_ids, values, data)++`]
* xref:#ERC1155Component-burn[`++burn(self, from, token_id, value)++`]
* xref:#ERC1155Component-batch_burn[`++batch_burn(self, from, token_ids, values)++`]
* xref:#ERC1155Component-update_with_acceptance_check[`++update_with_acceptance_check(self, from, to, token_ids, values, data)++`]
* xref:#ERC1155Component-update[`++update(self, from, to, token_ids, values)++`]
* xref:#ERC1155Component-_set_base_uri[`++_set_base_uri(self, base_uri)++`]
--

[.contract-index]
.Events
--
.IERC1155
* xref:#ERC1155Component-TransferSingle[`++TransferSingle(operator, from, to, id, value)++`]
* xref:#ERC1155Component-TransferBatch[`++TransferBatch(operator, from, to, ids, values)++`]
* xref:#ERC1155Component-ApprovalForAll[`++ApprovalForAll(owner, operator, approved)++`]
* xref:#ERC1155Component-URI[`++URI(value, id)++`]
--

[#ERC1155Component-Hooks]
==== Hooks

Hooks are functions which implementations can extend the functionality of the component source code. Every contract
using ERC1155Component is expected to provide an implementation of the ERC1155HooksTrait. For basic token contracts, an
empty implementation with no logic must be provided.

TIP: You can use `openzeppelin_token::erc1155::ERC1155HooksEmptyImpl` which is already available as part of the library
for this purpose.

[.contract-item]
[[ERC1155Component-before_update]]
==== `[.contract-item-name]#++before_update++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_ids: Span<u256>, values: Span<u256>)++` [.item-kind]#hook#

Function executed at the beginning of the xref:#ERC1155Component-update[update] function prior to any other logic.

[.contract-item]
[[ERC1155Component-after_update]]
==== `[.contract-item-name]#++after_update++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_ids: Span<u256>, values: Span<u256>)++` [.item-kind]#hook#

Function executed at the end of the xref:#ERC1155Component-update[update] function.

==== Embeddable functions

[.contract-item]
[[ERC1155Component-balance_of]]
==== `[.contract-item-name]#++balance_of++#++(self: @ContractState, account: ContractAddress, token_id: u256) → u256++` [.item-kind]#external#

Returns the amount of `token_id` tokens owned by `account`.

[.contract-item]
[[ERC1155Component-balance_of_batch]]
==== `[.contract-item-name]#++balance_of_batch++#++(self: @ContractState, accounts: Span<ContractAddress>, token_ids: Span<u256>) → Span<u256>++` [.item-kind]#external#

Returns a list of balances derived from the `accounts` and `token_ids` pairs.

Requirements:

- `token_ids` and `accounts` must have the same length.

[.contract-item]
[[ERC1155Component-safe_transfer_from]]
==== `[.contract-item-name]#++safe_transfer_from++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256,  value: u256, data: Span<felt252>)++` [.item-kind]#external#

Transfers ownership of `value` amount of `token_id` from `from` if `to` is either an account or `IERC1155Receiver`.

`data` is additional data, it has no specified format and it is passed to `to`.

WARNING: This function can potentially allow a reentrancy attack when transferring tokens
to an untrusted contract, when invoking `on_ERC1155_received` on the receiver.
Ensure to follow the checks-effects-interactions pattern and consider employing
reentrancy guards when interacting with untrusted contracts.

Requirements:

- Caller is either approved or the `token_id` owner.
- `from` is not the zero address.
- `to` is not the zero address.
- If `to` refers to a non-account contract, it must implement `IERC1155Receiver::on_ERC1155_received`
  and return the required magic value.

Emits a <<ERC1155Component-TransferSingle,TransferSingle>> event.

[.contract-item]
[[ERC1155Component-safe_batch_transfer_from]]
==== `[.contract-item-name]#++safe_batch_transfer_from++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_ids: Span<u256>, values: Span<u256>, data: Span<felt252>)++` [.item-kind]#external#

Transfers ownership of `values` and `token_ids` pairs from `from` if `to` is either an account or `IERC1155Receiver`.

`data` is additional data, it has no specified format and it is passed to `to`.

WARNING: This function can potentially allow a reentrancy attack when transferring tokens
to an untrusted contract, when invoking `on_ERC1155_batch_received` on the receiver.
Ensure to follow the checks-effects-interactions pattern and consider employing
reentrancy guards when interacting with untrusted contracts.

Requirements:

- Caller is either approved or the `token_id` owner.
- `from` is not the zero address.
- `to` is not the zero address.
- `token_ids` and `values` must have the same length.
- If `to` refers to a non-account contract, it must implement `IERC1155Receiver::on_ERC1155_batch_received`
  and return the acceptance magic value.

Emits a <<ERC1155Component-TransferSingle,TransferSingle>> event if the arrays contain one element,
and <<ERC1155Component-TransferBatch,TransferBatch>> otherwise.

[.contract-item]
[[ERC1155Component-set_approval_for_all]]
==== `[.contract-item-name]#++set_approval_for_all++#++(ref self: ContractState, operator: ContractAddress, approved: bool)++` [.item-kind]#external#

Enables or disables approval for `operator` to manage all of the callers assets.

Requirements:

- `operator` cannot be the caller.

Emits an <<ERC1155Component-ApprovalForAll,ApprovalForAll>> event.

[.contract-item]
[[ERC1155Component-is_approved_for_all]]
==== `[.contract-item-name]#++is_approved_for_all++#++(self: @ContractState, owner: ContractAddress, operator: ContractAddress) -> bool++` [.item-kind]#external#

Queries if `operator` is an authorized operator for `owner`.

[.contract-item]
[[ERC1155Component-uri]]
==== `[.contract-item-name]#++uri++#++(self: @ContractState, token_id: u256) -> ByteArray++` [.item-kind]#external#

This implementation returns the same URI for *all* token types. It relies
on the token type ID substitution mechanism
{eip1155-metadata}[specified in the EIP].

Clients calling this function must replace the `\{id\}` substring with the
actual token type ID.

[.contract-item]
[[ERC1155Component-balanceOf]]
==== `[.contract-item-name]#++balanceOf++#++(self: @ContractState, account: ContractAddress, tokenId: u256) → u256++` [.item-kind]#external#

See <<ERC1155Component-balance_of,ERC1155Component::balance_of>>.

[.contract-item]
[[ERC1155Component-balanceOfBatch]]
==== `[.contract-item-name]#++balanceOfBatch++#++(self: @ContractState, accounts: Span<ContractAddress>, tokenIds: Span<u256>) → Span<u256>++` [.item-kind]#external#

See <<ERC1155Component-balance_of_batch,ERC1155Component::balance_of_batch>>.

[.contract-item]
[[ERC1155Component-safeTransferFrom]]
==== `[.contract-item-name]#++safeTransferFrom++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, tokenId: u256,  value: u256, data: Span<felt252>)++` [.item-kind]#external#

See <<ERC1155Component-safe_transfer_from,ERC1155Component::safe_transfer_from>>.

[.contract-item]
[[ERC1155Component-safeBatchTransferFrom]]
==== `[.contract-item-name]#++safeBatchTransferFrom++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, tokenIds: Span<u256>, values: Span<u256>, data: Span<felt252>)++` [.item-kind]#external#

See <<ERC1155Component-safe_batch_transfer_from,ERC1155Component::safe_batch_transfer_from>>.

[.contract-item]
[[ERC1155Component-setApprovalForAll]]
==== `[.contract-item-name]#++setApprovalForAll++#++(ref self: ContractState, operator: ContractAddress, approved: bool)++` [.item-kind]#external#

See <<ERC1155Component-set_approval_for_all,ERC1155Component::set_approval_for_all>>.

[.contract-item]
[[ERC1155Component-isApprovedForAll]]
==== `[.contract-item-name]#++isApprovedForAll++#++(self: @ContractState, owner: ContractAddress, operator: ContractAddress) -> bool++` [.item-kind]#external#

See <<ERC1155Component-is_approved_for_all,ERC1155Component::is_approved_for_all>>.

==== Internal functions

[.contract-item]
[[ERC1155Component-initializer]]
==== `[.contract-item-name]#++initializer++#++(ref self: ContractState, base_uri: ByteArray)++` [.item-kind]#internal#

Initializes the contract by setting the token's base URI as `base_uri`, and registering the supported interfaces.
This should only be used inside the contract's constructor.

WARNING: Most ERC1155 contracts expose the <<IERC1155MetadataURI,IERC1155MetadataURI>> interface which is what this initializer is meant to support.
If the contract DOES NOT expose the <<IERC1155MetadataURI,IERC1155MetadataURI>> interface, meaning tokens do not have a URI,
the contract must instead use <<ERC1155Component-initializer_no_metadata,initializer_no_metadata>> in the constructor.
Failure to abide by these instructions can lead to unexpected issues especially with UIs.

[.contract-item]
[[ERC1155Component-initializer_no_metadata]]
==== `[.contract-item-name]#++initializer_no_metadata++#++(ref self: ContractState)++` [.item-kind]#internal#

Initializes the contract with no metadata by registering only the IERC1155 interface.

WARNING: This initializer should ONLY be used during construction in the very
specific instance when the contract does NOT expose the <<IERC1155MetadataURI,IERC1155MetadataURI>> interface.
Initializing a contract with this initializer means that tokens will not have a URI.

[.contract-item]
[[ERC1155Component-mint_with_acceptance_check]]
==== `[.contract-item-name]#++mint_with_acceptance_check++#++(ref self: ContractState, to: ContractAddress, token_id: u256, value: u256, data: Span<felt252>)++` [.item-kind]#internal#

Creates a `value` amount of tokens of type `token_id`, and assigns them to `to`.

Requirements:

- `to` cannot be the zero address.
- If `to` refers to a smart contract, it must implement `IERC1155Receiver::on_ERC1155_received`
and return the acceptance magic value.

Emits a <<ERC1155Component-TransferSingle,TransferSingle>> event.

[.contract-item]
[[ERC1155Component-batch_mint_with_acceptance_check]]
==== `[.contract-item-name]#++batch_mint_with_acceptance_check++#++(ref self: ContractState, to: ContractAddress, token_ids: Span<u256>, values: Span<u256>, data: Span<felt252>)++` [.item-kind]#internal#

Batched version of <<ERC1155Component-mint_with_acceptance_check,mint_with_acceptance_check>>.

Requirements:

- `to` cannot be the zero address.
- `token_ids` and `values` must have the same length.
- If `to` refers to a smart contract, it must implement `IERC1155Receiver::on_ERC1155_batch_received`
and return the acceptance magic value.

Emits a <<ERC1155Component-TransferBatch,TransferBatch>> event.

[.contract-item]
[[ERC1155Component-burn]]
==== `[.contract-item-name]#++burn++#++(ref self: ContractState, from: ContractAddress, token_id: u256, value: u256)++` [.item-kind]#internal#

Destroys a `value` amount of tokens of type `token_id` from `from`.

Requirements:

- `from` cannot be the zero address.
- `from` must have at least `value` amount of tokens of type `token_id`.

Emits a <<ERC1155Component-TransferSingle,TransferSingle>> event.

[.contract-item]
[[ERC1155Component-batch_burn]]
==== `[.contract-item-name]#++batch_burn++#++(ref self: ContractState, from: ContractAddress, token_ids: Span<u256>, values: Span<u256>)++` [.item-kind]#internal#

Batched version of <<ERC1155Component-burn,burn>>.

Requirements:

- `from` cannot be the zero address.
- `from` must have at least `value` amount of tokens of type `token_id`.
- `token_ids` and `values` must have the same length.

Emits a <<ERC1155Component-TransferBatch,TransferBatch>> event.

[.contract-item]
[[ERC1155Component-update_with_acceptance_check]]
==== `[.contract-item-name]#++update_with_acceptance_check++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_ids: Span<u256>, values: Span<u256>, data: Span<felt252>)++` [.item-kind]#internal#

Version of `update` that performs the token acceptance check by calling
`onERC1155Received` or `onERC1155BatchReceived` in the receiver if
it implements `IERC1155Receiver`, otherwise by checking if it is an account.

Requirements:

- `to` is either an account contract or supports the `IERC1155Receiver` interface.
- `token_ids` and `values` must have the same length.

Emits a <<ERC1155Component-TransferSingle,TransferSingle>> event if the arrays contain one element,
and <<ERC1155Component-TransferBatch,TransferBatch>> otherwise.

[.contract-item]
[[ERC1155Component-update]]
==== `[.contract-item-name]#++update++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_ids: Span<u256>, values: Span<u256>)++` [.item-kind]#internal#

Transfers a `value` amount of tokens of type `id` from `from` to `to`.
Will mint (or burn) if `from` (or `to`) is the zero address.

Requirements:

- `token_ids` and `values` must have the same length.

Emits a <<ERC1155Component-TransferSingle,TransferSingle>> event if the arrays contain one element,
and <<ERC1155Component-TransferBatch,TransferBatch>> otherwise.

NOTE: This function can be extended using the xref:ERC1155Component-ERC1155HooksTrait[ERC1155HooksTrait], to add
functionality before and/or after the transfer, mint, or burn.

NOTE: The ERC1155 acceptance check is not performed in this function.
See <<ERC1155Component-update_with_acceptance_check,update_with_acceptance_check>> instead.

[.contract-item]
[[ERC1155Component-_set_base_uri]]
==== `[.contract-item-name]#++_set_base_uri++#++(ref self: ContractState, base_uri: ByteArray)++` [.item-kind]#internal#

Sets a new URI for all token types, by relying on the token type ID
substitution mechanism
{eip1155-metadata}[specified in the EIP].

By this mechanism, any occurrence of the `\{id\}` substring in either the
URI or any of the values in the JSON file at said URI will be replaced by
clients with the token type ID.

For example, the pass:[<code>https://token-cdn-domain/\{id\}.json</code>] URI would be
interpreted by clients as
pass:[<code>https://token-cdn-domain/000000000000...000000000000004cce0.json</code>]
for token type ID `0x4cce0`.

Because these URIs cannot be meaningfully represented by the `URI` event,
this function emits no events.

==== Events

[.contract-item]
[[ERC1155Component-TransferSingle]]
==== `[.contract-item-name]#++TransferSingle++#++(operator: ContractAddress, from: ContractAddress, to: ContractAddress, id: u256, value: u256)++` [.item-kind]#event#

See <<IERC1155-TransferSingle,IERC1155::TransferSingle>>.

[.contract-item]
[[ERC1155Component-TransferBatch]]
==== `[.contract-item-name]#++TransferBatch++#++(operator: ContractAddress, from: ContractAddress, to: ContractAddress, ids: Span<u256>, values: Span<u256>)++` [.item-kind]#event#

See <<IERC1155-TransferBatch,IERC1155::TransferBatch>>.

[.contract-item]
[[ERC1155Component-ApprovalForAll]]
==== `[.contract-item-name]#++ApprovalForAll++#++(owner: ContractAddress, operator: ContractAddress, approved: bool)++` [.item-kind]#event#

See <<IERC1155-ApprovalForAll,IERC1155::ApprovalForAll>>.

[.contract-item]
[[ERC1155Component-URI]]
==== `[.contract-item-name]#++URI++#++(value: ByteArray, id: u256)++` [.item-kind]#event#

See <<IERC1155-URI,IERC1155::URI>>.

== Receiver

[.contract]
[[IERC1155Receiver]]
=== `++IERC1155Receiver++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/token/src/erc1155/interface.cairo[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_token::erc1155::interface::IERC1155Receiver;
```

Interface for contracts that support receiving token transfers from `ERC1155` contracts.

[.contract-index]
.{inner-src5}
--
0x15e8665b5af20040c3af1670509df02eb916375cdf7d8cbaf7bd553a257515e
--

[.contract-index]
.Functions
--
* xref:#IERC1155Receiver-on_erc1155_received[`++on_erc1155_received(operator, from, token_id, value, data)++`]
* xref:#IERC1155Receiver-on_erc1155_batch_received[`++on_erc1155_batch_received(operator, from, token_ids, values, data)++`]
--

==== Functions

[.contract-item]
[[IERC1155Receiver-on_erc1155_received]]
==== `[.contract-item-name]#++on_erc1155_received++#++(operator: ContractAddress, from: ContractAddress, token_id: u256, value: u256, data Span<felt252>) -> felt252++` [.item-kind]#external#

This function is called whenever an ERC1155 `token_id` token is transferred to this `IERC1155Receiver` implementer
via <<IERC1155-safe_transfer_from,IERC1155::safe_transfer_from>> by `operator` from `from`.

[.contract-item]
[[IERC1155Receiver-on_erc1155_batch_received]]
==== `[.contract-item-name]#++on_erc1155_batch_received++#++(operator: ContractAddress, from: ContractAddress, token_ids: Span<u256>, values: Span<u256>, data Span<felt252>) -> felt252++` [.item-kind]#external#

This function is called whenever multiple ERC1155 `token_ids` tokens are transferred to this `IERC1155Receiver` implementer
via <<IERC1155-safe_batch_transfer_from,IERC1155::safe_batch_transfer_from>> by `operator` from `from`.

[.contract]
[[ERC1155ReceiverComponent]]
=== `++ERC1155ReceiverComponent++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/token/src/erc1155/erc1155_receiver.cairo[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_token::erc1155::ERC1155ReceiverComponent;
```

ERC1155Receiver component implementing <<IERC1155Receiver,IERC1155Receiver>>.

NOTE: {src5-component-required-note}

[.contract-index#ERC1155ReceiverComponent-Embeddable-Mixin-Impl]
.{mixin-impls}
--
.ERC1155MixinImpl
* xref:#ERC1155ReceiverComponent-Embeddable-Impls-ERC1155ReceiverImpl[`++ERC1155ReceiverImpl++`]
* xref:#ERC1155ReceiverComponent-Embeddable-Impls-ERC1155ReceiverCamelImpl[`++ERC1155ReceiverCamelImpl++`]
* xref:api/introspection.adoc#SRC5Component-Embeddable-Impls-SRC5Impl[`++SRC5Impl++`]
--

[.contract-index#ERC1155ReceiverComponent-Embeddable-Impls]
.Embeddable Implementations
--
.ERC1155ReceiverImpl
* xref:#ERC1155ReceiverComponent-on_erc1155_received[`++on_erc1155_received(self, operator, from, token_id, value, data)++`]
* xref:#ERC1155ReceiverComponent-on_erc1155_batch_received[`++on_erc1155_batch_received(self, operator, from, token_ids, values, data)++`]

.ERC1155ReceiverCamelImpl
* xref:#ERC1155ReceiverComponent-onERC1155Received[`++onERC1155Received(self, operator, from, tokenId, value, data)++`]
* xref:#ERC1155ReceiverComponent-onERC1155BatchReceived[`++onERC1155BatchReceived(self, operator, from, tokenIds, values, data)++`]
--

[.contract-index]
.Internal Functions
--
.InternalImpl
* xref:#ERC1155ReceiverComponent-initializer[`++initializer(self)++`]
--

==== Embeddable functions

[.contract-item]
[[ERC1155ReceiverComponent-on_erc1155_received]]
==== `[.contract-item-name]#++on_erc1155_received++#++(self: @ContractState, operator: ContractAddress, from: ContractAddress, token_id: u256, value: u256, data Span<felt252>) -> felt252++` [.item-kind]#external#

Returns the `IERC1155Receiver` interface ID.

[.contract-item]
[[ERC1155ReceiverComponent-on_erc1155_batch_received]]
==== `[.contract-item-name]#++on_erc1155_batch_received++#++(self: @ContractState, operator: ContractAddress, from: ContractAddress, token_ids: Span<u256>, values: Span<u256>, data Span<felt252>) -> felt252++` [.item-kind]#external#

Returns the `IERC1155Receiver` interface ID.

[.contract-item]
[[ERC1155ReceiverComponent-onERC1155Received]]
==== `[.contract-item-name]#++onERC1155Received++#++(self: @ContractState, operator: ContractAddress, from: ContractAddress, tokenId: u256, value: u256, data Span<felt252>) -> felt252++` [.item-kind]#external#

See <<ERC1155ReceiverComponent-on_erc1155_received,ERC1155ReceiverComponent::on_erc1155_received>>.

[.contract-item]
[[ERC1155ReceiverComponent-onERC1155BatchReceived]]
==== `[.contract-item-name]#++onERC1155BatchReceived++#++(self: @ContractState, operator: ContractAddress, from: ContractAddress, tokenIds: Span<u256>, values: Span<u256>, data Span<felt252>) -> felt252++` [.item-kind]#external#

See <<ERC1155ReceiverComponent-on_erc1155_batch_received,ERC1155ReceiverComponent::on_erc1155_batch_received>>.

==== Internal functions

[.contract-item]
[[ERC1155ReceiverComponent-initializer]]
==== `[.contract-item-name]#++initializer++#++(ref self: ContractState)++` [.item-kind]#internal#

Registers the `IERC1155Receiver` interface ID as supported through introspection.

== Presets

[.contract]
[[ERC1155Upgradeable]]
=== `++ERC1155Upgradeable++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/presets/src/erc1155.cairo[{github-icon},role=heading-link]

```cairo
use openzeppelin_presets::ERC1155;
```

Upgradeable ERC1155 contract leveraging xref:#ERC1155Component[ERC1155Component].

include::../utils/_class_hashes.adoc[]

[.contract-index]
.{presets-page}
--
{ERC1155Upgradeable-class-hash}
--

[.contract-index]
.Constructor
--
* xref:#ERC1155Upgradeable-constructor[`++constructor(self, base_uri, recipient, token_ids, values, owner)++`]
--

[.contract-index]
.Embedded Implementations
--
.ERC1155Component

* xref:#ERC1155Component-Embeddable-Mixin-Impl[`++ERC1155MixinImpl++`]

.OwnableMixinImpl

* xref:/api/access.adoc#OwnableComponent-Mixin-Impl[`++OwnableMixinImpl++`]
--

[.contract-index]
.External Functions
--
* xref:#ERC1155Upgradeable-upgrade[`++upgrade(self, new_class_hash)++`]
--

[#ERC1155Upgradeable-constructor-section]
==== Constructor

[.contract-item]
[[ERC1155Upgradeable-constructor]]
==== `[.contract-item-name]#++constructor++#++(ref self: ContractState, base_uri: ByteArray, recipient: ContractAddress, token_ids: Span<u256>, values: Span<u256>, owner: ContractAddress)++` [.item-kind]#constructor#

Sets the `base_uri` for all tokens and registers the supported interfaces.
Mints the `values` for `token_ids` tokens to `recipient`.
Assigns `owner` as the contract owner with permissions to upgrade.

Requirements:

- `to` is either an account contract (supporting ISRC6) or
   supports the `IERC1155Receiver` interface.
- `token_ids` and `values` must have the same length.

[#ERC1155Upgradeable-external-functions]
==== External Functions

[.contract-item]
[[ERC1155Upgradeable-upgrade]]
==== `[.contract-item-name]#++upgrade++#++(ref self: ContractState, new_class_hash: ClassHash)++` [.item-kind]#external#

Upgrades the contract to a new implementation given by `new_class_hash`.

Requirements:

- The caller is the contract owner.
- `new_class_hash` cannot be zero.
// llmstxt-short-description: API of the common token extensions and utilities module, including the ERC2981 component, traits and interface

:github-icon: pass:[<svg class="icon"><use href="#github-icon"/></svg>]
:eip2981: https://eips.ethereum.org/EIPS/eip-2981[EIP-2981]
:inner-src5: xref:api/introspection.adoc#ISRC5[SRC5 ID]

= Common (Token)

include::../utils/_common.adoc[]

This module provides extensions and utilities that are common to multiple token standards.

== ERC2981

[.contract]
[[IERC2981]]
=== `++IERC2981++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/token/src/common/erc2981/interface.cairo[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_token::common::erc2981::interface::IERC2981;
```

[.contract-index]
.{inner-src5}
--
0x2d3414e45a8700c29f119a54b9f11dca0e29e06ddcb214018fc37340e165ed6
--

Interface of the ERC2981 standard as defined in {eip2981}.

[.contract-index]
.Functions
--
* xref:#IERC2981-royalty_info[`++royalty_info(token_id, sale_price)++`]
--

[#IERC2981-Functions]
==== Functions

[.contract-item]
[[IERC2981-royalty_info]]
==== `[.contract-item-name]#++royalty_info++#++(token_id: u256, sale_price: u256) → (ContractAddress, u256)++` [.item-kind]#external#

Returns how much royalty is owed and to whom, based on a sale price that may be denominated
in any unit of exchange. The royalty amount is denominated and must be paid in that same
unit of exchange.

[.contract]
[[IERC2981Info]]
=== `++IERC2981Info++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/token/src/common/erc2981/interface.cairo[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_token::common::erc2981::interface::IERC2981Info;
```

Interface providing external read functions for discovering the state of ERC2981 component.

[.contract-index]
.Functions
--
* xref:#IERC2981Info-default_royalty[`++default_royalty()++`]
* xref:#IERC2981Info-token_royalty[`++token_royalty(token_id)++`]
--

[#IERC2981Info-Functions]
==== Functions

[.contract-item]
[[IERC2981Info-default_royalty]]
==== `[.contract-item-name]#++default_royalty++#++() → (ContractAddress, u128, u128)++` [.item-kind]#external#

Returns the royalty information that all ids in this contract will default to.
    
The returned tuple contains:

- `t.0`: The receiver of the royalty payment.
- `t.1`: The numerator of the royalty fraction.
- `t.2`: The denominator of the royalty fraction.

[.contract-item]
[[IERC2981Info-token_royalty]]
==== `[.contract-item-name]#++token_royalty++#++(token_id: u256) → (ContractAddress, u128, u128)++` [.item-kind]#external#

Returns the royalty information specific to a token.

The returned tuple contains:

- `t.0`: The receiver of the royalty payment.
- `t.1`: The numerator of the royalty fraction.
- `t.2`: The denominator of the royalty fraction.

[.contract]
[[IERC2981Admin]]
=== `++IERC2981Admin++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/token/src/common/erc2981/interface.cairo[{github-icon},role=heading-link]

[.hljs-theme-dark]
```cairo
use openzeppelin_token::common::erc2981::interface::IERC2981Admin;
```

Interface providing external admin functions for managing the settings of ERC2981 component.

[.contract-index]
.Functions
--
* xref:#IERC2981Admin-set_default_royalty[`++set_default_royalty(receiver, fee_numerator)++`]
* xref:#IERC2981Admin-delete_default_royalty[`++delete_default_royalty()++`]
* xref:#IERC2981Admin-set_token_royalty[`++set_token_royalty(token_id, receiver, fee_numerator)++`]
* xref:#IERC2981Admin-reset_token_royalty[`++reset_token_royalty(token_id)++`]
--

[#IERC2981Admin-Functions]
==== Functions

[.contract-item]
[[IERC2981Admin-set_default_royalty]]
==== `[.contract-item-name]#++set_default_royalty++#++(receiver: ContractAddress, fee_numerator: u128)++` [.item-kind]#external#

Sets the royalty information that all ids in this contract will default to.

[.contract-item]
[[IERC2981Admin-delete_default_royalty]]
==== `[.contract-item-name]#++delete_default_royalty++#++()++` [.item-kind]#external#

Sets the default royalty percentage and receiver to zero.

[.contract-item]
[[IERC2981Admin-set_token_royalty]]
==== `[.contract-item-name]#++set_token_royalty++#++(token_id: u256, receiver: ContractAddress, fee_numerator: u128)++` [.item-kind]#external#

Sets the royalty information for a specific token id that takes precedence over the global default.

[.contract-item]
[[IERC2981Admin-reset_token_royalty]]
==== `[.contract-item-name]#++reset_token_royalty++#++(token_id: u256)++` [.item-kind]#external#

Resets royalty information for the token id back to unset.

[.contract]
[[ERC2981Component]]
=== `++ERC2981Component++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/token/src/common/erc2981/erc2981.cairo[{github-icon},role=heading-link]

```cairo
use openzeppelin_token::common::erc2981::ERC2981Component;
```

ERC2981 component extending <<IERC2981,IERC2981>>.

[.contract-index]
.{immutable-config}
--
.constants
* xref:#ERC2981Component-IC-FEE_DENOMINATOR[`++FEE_DENOMINATOR++`]

.functions
* xref:#ERC2981Component-IC-validate[`++validate()++`]
--

[.contract-index#ERC2981Component-Embeddable-Impls]
.Embeddable Implementations
--
[.sub-index#ERC2981Component-Embeddable-Impls-ERC20Impl]
.ERC2981Impl
* xref:#ERC2981Component-royalty_info[`++royalty_info(self, token_id, sale_price)++`]

[.sub-index#ERC2981Component-Embeddable-Impls-ERC2981InfoImpl]
.ERC2981InfoImpl
* xref:#ERC2981InfoImpl-default_royalty[`++default_royalty(self)++`]
* xref:#ERC2981InfoImpl-token_royalty[`++token_royalty(self, token_id)++`]

[.sub-index#ERC2981Component-Embeddable-Impls-ERC2981AdminOwnableImpl]
.ERC2981AdminOwnableImpl
* xref:#ERC2981AdminOwnableImpl-set_default_royalty[`++set_default_royalty(self, receiver, fee_numerator)++`]
* xref:#ERC2981AdminOwnableImpl-delete_default_royalty[`++delete_default_royalty(self)++`]
* xref:#ERC2981AdminOwnableImpl-set_token_royalty[`++set_token_royalty(self, token_id, receiver, fee_numerator)++`]
* xref:#ERC2981AdminOwnableImpl-reset_token_royalty[`++reset_token_royalty(self, token_id)++`]

[.sub-index#ERC2981Component-Embeddable-Impls-ERC2981AdminAccessControlImpl]
.ERC2981AdminAccessControlImpl
* xref:#ERC2981AdminAccessControlImpl-set_default_royalty[`++set_default_royalty(self, receiver, fee_numerator)++`]
* xref:#ERC2981AdminAccessControlImpl-delete_default_royalty[`++delete_default_royalty(self)++`]
* xref:#ERC2981AdminAccessControlImpl-set_token_royalty[`++set_token_royalty(self, token_id, receiver, fee_numerator)++`]
* xref:#ERC2981AdminAccessControlImpl-reset_token_royalty[`++reset_token_royalty(self, token_id)++`]
--

[.contract-index]
.Internal implementations
--
.InternalImpl
* xref:#ERC2981Component-initializer[`++initializer(self, default_receiver, default_royalty_fraction)++`]
* xref:#ERC2981Component-_default_royalty[`++_default_royalty(self)++`]
* xref:#ERC2981Component-_set_default_royalty[`++_set_default_royalty(self, receiver, fee_numerator)++`]
* xref:#ERC2981Component-_delete_default_royalty[`++_delete_default_royalty(self)++`]
* xref:#ERC2981Component-_token_royalty[`++_token_royalty(self, token_id)++`]
* xref:#ERC2981Component-_set_token_royalty[`++_set_token_royalty(self, token_id, receiver, fee_numerator)++`]
* xref:#ERC2981Component-_reset_token_royalty[`++_reset_token_royalty(self, token_id)++`]
--

[#ERC2981Component-Immutable-Config]
==== Immutable Config constants

[.contract-item]
[[ERC2981Component-IC-FEE_DENOMINATOR]]
==== `[.contract-item-name]#++FEE_DENOMINATOR:++#++ u128++` [.item-kind]#constant#

The denominator with which to interpret the fee set in
`_set_token_royalty` and `_set_default_royalty` as a fraction of the sale price.

[.contract-item]
[[ERC2981Component-IC-validate]]
==== `[.contract-item-name]#++validate++#++()++` [.item-kind]#internal#

Validates the given implementation of the contract's configuration.

Requirements:

- `FEE_DENOMINATOR` must be greater than 0.

NOTE: This function is called by the contract's initializer.

[#ERC2981Component-Embeddable-functions]
==== Embeddable functions

[.contract-item]
[[ERC2981Component-royalty_info]]
==== `[.contract-item-name]#++royalty_info++#++(@self: ContractState, token_id: u256, sale_price: u256) → (ContractAddress, u256)++` [.item-kind]#external#

Returns how much royalty is owed and to whom, based on a sale price that may be
denominated in any unit of exchange. The royalty amount is denominated and should be
paid in that same unit of exchange.

The returned tuple contains:

- `t.0`: The receiver of the royalty payment.
- `t.1`: The amount of royalty payment.

[.contract-item]
[[ERC2981InfoImpl-default_royalty]]
==== `[.contract-item-name]#++default_royalty++#++(@self: ContractState) → (ContractAddress, u128, u128)++` [.item-kind]#external#

Returns the royalty information that all ids in this contract will default to.

The returned tuple contains:

- `t.0`: The receiver of the royalty payment.
- `t.1`: The numerator of the royalty fraction.
- `t.2`: The denominator of the royalty fraction.

[.contract-item]
[[ERC2981InfoImpl-token_royalty]]
==== `[.contract-item-name]#++token_royalty++#++(self: @ContractState, token_id: u256) → (ContractAddress, u128, u128)++` [.item-kind]#external#

Returns the royalty information specific to a token.
If no specific royalty information is set for the token, the default is returned.

The returned tuple contains:

- `t.0`: The receiver of the royalty payment.
- `t.1`: The numerator of the royalty fraction.
- `t.2`: The denominator of the royalty fraction.

[#ERC2981Component-ERC2981AdminOwnableImpl]
==== ERC2981AdminOwnableImpl

:ownable-component: xref:/api/access.adoc#OwnableComponent[OwnableComponent]

Provides admin functions for managing royalty settings that are restricted to be called only by the contract's owner. 
Requires the contract to implement {ownable-component}.

[.contract-item]
[[ERC2981AdminOwnableImpl-set_default_royalty]]
==== `[.contract-item-name]#++set_default_royalty++#++(ref self: ContractState, receiver: ContractAddress, fee_numerator: u128)++` [.item-kind]#external#

Sets the royalty information that all ids in this contract will default to.

Requirements:

- The caller is the contract owner.
- `receiver` cannot be the zero address.
- `fee_numerator` cannot be greater than the fee denominator.

[.contract-item]
[[ERC2981AdminOwnableImpl-delete_default_royalty]]
==== `[.contract-item-name]#++delete_default_royalty++#++(ref self: ContractState)++` [.item-kind]#external#

Sets the default royalty percentage and receiver to zero.

Requirements:

- The caller is the contract owner.

[.contract-item]
[[ERC2981AdminOwnableImpl-set_token_royalty]]
==== `[.contract-item-name]#++set_token_royalty++#++(ref self: ContractState, token_id: u256, receiver: ContractAddress, fee_numerator: u128)++` [.item-kind]#external#

Sets the royalty information for a specific token id that takes precedence over the global default.

Requirements:

- The caller is the contract owner.
- `receiver` cannot be the zero address.
- `fee_numerator` cannot be greater than the fee denominator.

[.contract-item]
[[ERC2981AdminOwnableImpl-reset_token_royalty]]
==== `[.contract-item-name]#++reset_token_royalty++#++(ref self: ContractState, token_id: u256)++` [.item-kind]#external#

Resets royalty information for the token id back to unset.

Requirements:

- The caller is the contract owner.

[#ERC2981Component-ERC2981AdminAccessControlImpl]
==== ERC2981AdminAccessControlImpl

:accesscontrol-component: xref:api/access.adoc#AccessControlComponent[AccessControlComponent]

Provides admin functions for managing royalty settings that require `ROYALTY_ADMIN_ROLE` to be granted to the caller. 
Requires the contract to implement {accesscontrol-component}.

[.contract-item]
[[ERC2981AdminAccessControlImpl-ROYALTY_ADMIN_ROLE]]
==== `[.contract-item-name]#++ROYALTY_ADMIN_ROLE:++#++ felt252++` [.item-kind]#constant#

Role for the admin responsible for managing royalty settings.

[.contract-item]
[[ERC2981AdminAccessControlImpl-set_default_royalty]]
==== `[.contract-item-name]#++set_default_royalty++#++(ref self: ContractState, receiver: ContractAddress, fee_numerator: u128)++` [.item-kind]#external#

Sets the royalty information that all ids in this contract will default to.

Requirements:

- The caller must have `ROYALTY_ADMIN_ROLE` role.
- `receiver` cannot be the zero address.
- `fee_numerator` cannot be greater than the fee denominator.

[.contract-item]
[[ERC2981AdminAccessControlImpl-delete_default_royalty]]
==== `[.contract-item-name]#++delete_default_royalty++#++(ref self: ContractState)++` [.item-kind]#external#

Sets the default royalty percentage and receiver to zero.

Requirements:

- The caller must have `ROYALTY_ADMIN_ROLE` role.

[.contract-item]
[[ERC2981AdminAccessControlImpl-set_token_royalty]]
==== `[.contract-item-name]#++set_token_royalty++#++(ref self: ContractState, token_id: u256, receiver: ContractAddress, fee_numerator: u128)++` [.item-kind]#external#

Sets the royalty information for a specific token id that takes precedence over the global default.

Requirements:

- The caller must have `ROYALTY_ADMIN_ROLE` role.
- `receiver` cannot be the zero address.
- `fee_numerator` cannot be greater than the fee denominator.

[.contract-item]
[[ERC2981AdminAccessControlImpl-reset_token_royalty]]
==== `[.contract-item-name]#++reset_token_royalty++#++(ref self: ContractState, token_id: u256)++` [.item-kind]#external#

Resets royalty information for the token id back to unset.

Requirements:

- The caller must have `ROYALTY_ADMIN_ROLE` role.

[#ERC2981Component-Internal-functions]
==== Internal functions

[.contract-item]
[[ERC2981Component-initializer]]
==== `[.contract-item-name]#++initializer++#++(ref self: ContractState, default_receiver: ContractAddress, default_royalty_fraction: u128)++` [.item-kind]#internal#

Initializes the contract by setting the default royalty and registering the supported interface.

Requirements:

- `default_receiver` cannot be the zero address.
- `default_royalty_fraction` cannot be greater than the fee denominator.
- The fee denominator must be greater than 0.

NOTE: The fee denominator is set by the contract using the {immutable-config}.

[.contract-item]
[[ERC2981Component-_default_royalty]]
==== `[.contract-item-name]#++_default_royalty++#++(self: @ContractState) → (ContractAddress, u128, u128)++` [.item-kind]#internal#

Returns the royalty information that all ids in this contract will default to.

The returned tuple contains:

- `t.0`: The receiver of the royalty payment.
- `t.1`: The numerator of the royalty fraction.
- `t.2`: The denominator of the royalty fraction.

[.contract-item]
[[ERC2981Component-_set_default_royalty]]
==== `[.contract-item-name]#++_set_default_royalty++#++(ref self: ContractState, receiver: ContractAddress, fee_numerator: u128)++` [.item-kind]#internal#

Sets the royalty information that all ids in this contract will default to.

Requirements:

- `receiver` cannot be the zero address.
- `fee_numerator` cannot be greater than the fee denominator.

[.contract-item]
[[ERC2981Component-_delete_default_royalty]]
==== `[.contract-item-name]#++_delete_default_royalty++#++(ref self: ContractState)++` [.item-kind]#internal#

Sets the default royalty percentage and receiver to zero.

[.contract-item]
[[ERC2981Component-_token_royalty]]
==== `[.contract-item-name]#++_token_royalty++#++(self: @ContractState, token_id: u256) → (ContractAddress, u256, u256)++` [.item-kind]#internal#

Returns the royalty information that all ids in this contract will default to.

The returned tuple contains:

- `t.0`: The receiver of the royalty payment.
- `t.1`: The numerator of the royalty fraction.
- `t.2`: The denominator of the royalty fraction.

[.contract-item]
[[ERC2981Component-_set_token_royalty]]
==== `[.contract-item-name]#++_set_token_royalty++#++(ref self: ContractState, token_id: u256, receiver: ContractAddress, fee_numerator: u128)++` [.item-kind]#internal#

Sets the royalty information for a specific token id that takes precedence over the global default.

Requirements:

- `receiver` cannot be the zero address.
- `fee_numerator` cannot be greater than the fee denominator.

[.contract-item]
[[ERC2981Component-_reset_token_royalty]]
==== `[.contract-item-name]#++_reset_token_royalty++#++(ref self: ContractState, token_id: u256)++` [.item-kind]#internal#

Resets royalty information for the token id back to unset.
// llmstxt-short-description: Describes the Universal Deployer Contract (UDC) and its usage

= Universal Deployer Contract

:deploy-syscall: link:https://docs.starknet.io/architecture-and-concepts/smart-contracts/system-calls-cairo1/#deploy[deploy syscall]
:deployer-interface: link:https://community.starknet.io/t/snip-deployer-contract-interface/2772[Standard Deployer Interface]
:udc-proposal: link:https://community.starknet.io/t/universal-deployer-contract-proposal/1864[Universal Deployer Contract proposal]
:deploy_contract: xref:/api/udc.adoc#UniversalDeployer-deploy_contract[deploy_contract]
:contract-deployed: xref:/api/udc.adoc#IUniversalDeployer-ContractDeployed[ContractDeployed]

The Universal Deployer Contract (UDC) is a singleton smart contract that wraps the {deploy-syscall} to expose it to any contract that doesn't implement it, such as account contracts. You can think of it as a standardized generic factory for Starknet contracts.

Since Starknet has no deployment transaction type, it offers a standardized way to deploy smart contracts by following the {deployer-interface} and emitting a {contract-deployed} event.

For details on the motivation and the decision making process, see the {udc-proposal}.

== UDC contract address

The UDC address is deployed at address `0x04a64cd09a853868621d94cae9952b106f2c36a3f81260f85de6696c6b050221` in Mainnet and Sepolia testnet.

== Interface

[,cairo]
----
#[starknet::interface]
pub trait IUniversalDeployer {
    fn deploy_contract(
        class_hash: ClassHash,
        salt: felt252,
        from_zero: bool,
        calldata: Span<felt252>
    ) -> ContractAddress;
}
----

== Deploying a contract with the UDC

:declare: link:https://docs.starknet.io/architecture-and-concepts/network-architecture/transactions/#declare-transaction[declare]

First, {declare} the target contract (if it's not already declared).
Next, call the UDC's `deploy_contract` method.
Here's an implementation example in Cairo:

[,cairo]
----
use openzeppelin_utils::interfaces::{IUniversalDeployerDispatcher, IUniversalDeployerDispatcherTrait};

const UDC_ADDRESS: felt252 = 0x04a64cd09a853868621d94cae9952b106f2c36a3f81260f85de6696c6b050221;

fn deploy() -> ContractAddress {
    let dispatcher = IUniversalDeployerDispatcher {
        contract_address: UDC_ADDRESS.try_into().unwrap()
    };

    // Deployment parameters
    let class_hash = class_hash_const::<
       0x5c478ee27f2112411f86f207605b2e2c58cdb647bac0df27f660ef2252359c6
    >();
    let salt = 1234567879;
    let from_zero = false;
    let calldata = array![];

    // The UDC returns the deployed contract address
    dispatcher.deploy_contract(class_hash, salt, from_zero, calldata.span())
}
----

== Deployment types

The Universal Deployer Contract offers two types of addresses to deploy: origin-dependent and origin-independent.
As the names suggest, the origin-dependent type includes the deployer's address in the address calculation,
whereas, the origin-independent type does not.
The `from_zero` boolean parameter ultimately determines the type of deployment.

[IMPORTANT]
====
When deploying a contract that uses `get_caller_address` in the constructor calldata, remember that the UDC, not the account, deploys that contract.
Therefore, querying `get_caller_address` in a contract's constructor returns the UDC's address, _not the account's address_.
====

=== Origin-dependent

By making deployments dependent upon the origin address, users can reserve a whole address space to prevent someone else from taking ownership of the address.

Only the owner of the origin address can deploy to those addresses.

Achieving this type of deployment necessitates that the origin sets `from_zero` to `false` in the {deploy_contract} call.
Under the hood, the function passes a modified salt to the `deploy_syscall`, which is the hash of the origin's address with the given salt.

To deploy a unique contract address pass:

[,js]
----
let deployed_addr = udc.deploy_contract(class_hash, salt, false, calldata.span());
----

=== Origin-independent

Origin-independent contract deployments create contract addresses independent of the deployer and the UDC instance.
Instead, only the class hash, salt, and constructor arguments determine the address.
This type of deployment enables redeployments of accounts and known systems across multiple networks.
To deploy a reproducible deployment, set `from_zero` to `true`.

[source,cairo]
----
let deployed_addr = udc.deploy_contract(class_hash, salt, true, calldata.span());
----

== Version changes

:pedersen: link:https://docs.starknet.io/architecture-and-concepts/cryptography/#pedersen_hash[Pedersen]
:poseidon: link:https://docs.starknet.io/architecture-and-concepts/cryptography/#poseidon_hash[Poseidon]
:origin-dependent-deployments: xref:origin_dependent[origin-dependent deployments]
:previous-udc-api: https://docs.starknet.io/architecture-and-concepts/accounts/universal-deployer/[previous Universal Deployer API]
:contract-deployed-event: xref:/api/udc.adoc#IUniversalDeployer-ContractDeployed[ContractDeployed]

NOTE: See the {previous-udc-api} for the initial spec.

The latest iteration of the UDC includes some notable changes to the API which include:

* `deployContract` method is replaced with the snake_case {deploy_contract}.
* {pedersen} hashing algorithm is replaced with the {poseidon} hashing algorithm for computing the salt on {origin-dependent-deployments}.
* `unique` parameter is replaced with `from_zero` in both the `deploy_contract` method and {contract-deployed-event} event.

WARNING: Origin-dependent deployments previously meant that the `unique` argument would be `true`.
Origin-dependent deployments from the new UDC iteration, however, requires that `from_zero` is `false`.
It's especially important to keep this in mind when dealing with `ContractDeployed` events because this change will appear as the opposite boolean per deployment type.

== Precomputing contract addresses

:calculate_contract_address_from_deploy_syscall: xref:/api/utilities.adoc#deployments-calculate_contract_address_from_deploy_syscall[calculate_contract_address_from_deploy_syscall]
:calculate_contract_address_from_udc: xref:/api/utilities.adoc#deployments-calculate_contract_address_from_udc[calculate_contract_address_from_udc]
:deployments: xref:/api/utilities.adoc#deployments[deployments]

This library offers utility functions written in Cairo to precompute contract addresses.
They include the generic {calculate_contract_address_from_deploy_syscall} as well as the UDC-specific {calculate_contract_address_from_udc}.
Check out the {deployments} for more information.
// llmstxt-short-description: API of the Universal Deployer Contract (UDC) component, interface and preset

:github-icon: pass:[<svg class="icon"><use href="#github-icon"/></svg>]

= Universal Deployer

Reference of the Universal Deployer Contract (UDC) interface and preset.

== Core

[.contract]
[[IUniversalDeployer]]
=== `++IUniversalDeployer++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/utils/src/deployments/interface.cairo[{github-icon},role=heading-link]

```cairo
use openzeppelin_utils::interfaces::IUniversalDeployer;
```

[.contract-index]
.Functions
--
* xref:#IUniversalDeployer-deploy_contract[`++deploy_contract(class_hash, salt, from_zero, calldata)++`]
--

[.contract-index]
.Events
--
* xref:#IUniversalDeployer-ContractDeployed[`++ContractDeployed(address, deployer, from_zero, class_hash, calldata, salt)++`]
--

[#IUniversalDeployer-Functions]
==== Functions

[.contract-item]
[[IUniversalDeployer-deploy_contract]]
==== `[.contract-item-name]#++deploy_contract++#++(class_hash: ClassHash, salt: felt252, from_zero: bool, calldata: Span<felt252>) → ContractAddress++` [.item-kind]#external#

Deploys a contract through the Universal Deployer Contract.

[#IUniversalDeployer-Events]
==== Events

[.contract-item]
[[IUniversalDeployer-ContractDeployed]]
==== `[.contract-item-name]#++ContractDeployed++#++(address: ContractAddress, deployer: ContractAddress, from_zero: bool, class_hash: ClassHash, calldata: Span<felt252>, salt: felt252)++` [.item-kind]#event#

Emitted when `deployer` deploys a contract through the Universal Deployer Contract.

== Presets

:origin-dependent: xref:/udc.adoc#origin_dependent[origin-dependent]
:origin-independent: xref:/udc.adoc#origin_independent[origin-independent]

[.contract]
[[UniversalDeployer]]
=== `++UniversalDeployer++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/presets/src/universal_deployer.cairo[{github-icon},role=heading-link]

```cairo
use openzeppelin_presets::UniversalDeployer;
```

The standard Universal Deployer Contract.

include::../utils/_class_hashes.adoc[]

[.contract-index]
.{presets-page}
--
{UniversalDeployer-class-hash}
--

[.contract-index]
.Embedded Implementations
--
.UniversalDeployerImpl
* xref:#UniversalDeployer-deploy_contract[`++deploy_contract(self, address, deployer, from_zero, class_hash, calldata, salt)++`]
--

[.contract-item]
[[UniversalDeployer-deploy_contract]]
==== `[.contract-item-name]#++deploy_contract++#++(ref self: ContractState, address: ContractAddress, deployer: ContractAddress, from_zero: bool, class_hash: ClassHash, calldata: Span<felt252>, salt: felt252) -> ContractAddress++` [.item-kind]#external#

Deploys a contract through the Universal Deployer Contract.

When `from_zero` is `false`, `salt` is hashed with the caller address and the modified salt is passed to the inner `deploy_syscall`. This type of deployment is {origin-dependent}.

When `from_zero` is `true`, the deployment type is {origin-independent}.

Emits an <<IUniversalDeployer-ContractDeployed,ContractDeployed>> event.
// llmstxt-short-description: Describes the upgradeable components of the library and their usage

:contract_classes: https://docs.starknet.io/architecture-and-concepts/smart-contracts/contract-classes/[Contract Classes]
:class_hash: https://docs.starknet.io/architecture-and-concepts/smart-contracts/class-hash/[class hash]
:replace_class_syscall: https://docs.starknet.io/architecture-and-concepts/smart-contracts/system-calls-cairo1/#replace_class[replace_class]
:upgradeable: https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/upgrades/src/upgradeable.cairo[Upgradeable]
:ownable: xref:access.adoc#ownership_and_ownable[Ownable]
:i_upgradeable: xref:api/upgrades.adoc#IUpgradeable[IUpgradeable]
:library_calls: https://docs.starknet.io/architecture-and-concepts/smart-contracts/system-calls-cairo1/#library_call[library calls]

= Upgrades

In different blockchains, multiple patterns have been developed for making a contract upgradeable including the widely adopted proxy patterns.

Starknet has native upgradeability through a syscall that updates the contract source code, removing xref:#proxies_in_starknet[the need for proxies].

WARNING: Make sure you follow xref:#security[our security recommendations] before upgrading.

== Replacing contract classes

To better comprehend how upgradeability works in Starknet, it's important to understand the difference between a contract and its contract class.

{contract_classes} represent the source code of a program. All contracts are associated to a class, and many contracts can be instances of the same one. Classes are usually represented by a {class_hash}, and before a contract of a class can be deployed, the class hash needs to be declared.

=== `replace_class_syscall`

The `{replace_class_syscall}` syscall allows a contract to update its source code by replacing its class hash once deployed.


[,cairo]
----
/// Upgrades the contract source code to the new contract class.
fn upgrade(new_class_hash: ClassHash) {
    assert(!new_class_hash.is_zero(), 'Class hash cannot be zero');
    starknet::replace_class_syscall(new_class_hash).unwrap_syscall();
}
----

NOTE: If a contract is deployed without this mechanism, its class hash can still be replaced through {library_calls}.

== `Upgradeable` component

OpenZeppelin Contracts for Cairo provides {upgradeable} to add upgradeability support to your contracts.

=== Usage

Upgrades are often very sensitive operations, and some form of access control is usually required to
avoid unauthorized upgrades. The {ownable} module is used in this example.

NOTE: We will be using the following module to implement the {i_upgradeable} interface described in the API Reference section.

[,cairo]
----
#[starknet::contract]
mod UpgradeableContract {
    use openzeppelin_access::ownable::OwnableComponent;
    use openzeppelin_upgrades::UpgradeableComponent;
    use openzeppelin_upgrades::interface::IUpgradeable;
    use starknet::ClassHash;
    use starknet::ContractAddress;

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);
    component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);

    // Ownable Mixin
    #[abi(embed_v0)]
    impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;
    impl OwnableInternalImpl = OwnableComponent::InternalImpl<ContractState>;

    // Upgradeable
    impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        ownable: OwnableComponent::Storage,
        #[substorage(v0)]
        upgradeable: UpgradeableComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        OwnableEvent: OwnableComponent::Event,
        #[flat]
        UpgradeableEvent: UpgradeableComponent::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: ContractAddress) {
        self.ownable.initializer(owner);
    }

    #[abi(embed_v0)]
    impl UpgradeableImpl of IUpgradeable<ContractState> {
        fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {
            // This function can only be called by the owner
            self.ownable.assert_only_owner();

            // Replace the class hash upgrading the contract
            self.upgradeable.upgrade(new_class_hash);
        }
    }
}
----

== Security

Upgrades can be very sensitive operations, and security should always be top of mind while performing one. Please make sure you thoroughly review the changes and their consequences before upgrading. Some aspects to consider are:

- API changes that might affect integration. For example, changing an external function's arguments might break existing contracts or offchain systems calling your contract.
- Storage changes that might result in lost data (e.g. changing a storage slot name, making existing storage inaccessible).
- Collisions (e.g. mistakenly reusing the same storage slot from another component) are also possible, although less likely if best practices are followed, for example prepending storage variables with the component's name (e.g. `ERC20_balances`).
- Always check for xref:backwards-compatibility.adoc[backwards compatibility] before upgrading between versions of OpenZeppelin Contracts.

== Proxies in Starknet

Proxies enable different patterns such as upgrades and clones. But since Starknet achieves the same in different ways is that there's no support to implement them.

In the case of contract upgrades, it is achieved by simply changing the contract's class hash. As of clones, contracts already are like clones of the class they implement.

Implementing a proxy pattern in Starknet has an important limitation: there is no fallback mechanism to be used
for redirecting every potential function call to the implementation. This means that a generic proxy contract
can't be implemented. Instead, a limited proxy contract can implement specific functions that forward
their execution to another contract class.
This can still be useful for example to upgrade the logic of some functions.
// llmstxt-short-description: API of the Upgrades module, providing interfaces and utilities related to upgradeability

:github-icon: pass:[<svg class="icon"><use href="#github-icon"/></svg>]
:class_hash: https://docs.starknet.io/architecture-and-concepts/smart-contracts/class-hash/[class hash]

= Upgrades

This crate provides interfaces and utilities related to upgradeability.

== Core

[.contract]
[[IUpgradeable]]
=== `++IUpgradeable++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/upgrades/src/interface.cairo[{github-icon},role=heading-link]

:Upgraded: xref:UpgradeableComponent-Upgraded[Upgraded]

```cairo
use openzeppelin_upgrades::interface::IUpgradeable;
```

Interface of an upgradeable contract.

[.contract-index]
.Functions
--
* xref:#IUpgradeable-upgrade[`++upgrade(new_class_hash)++`]
--

[#IUpgradeable-Functions]
==== Functions

[.contract-item]
[[IUpgradeable-upgrade]]
==== `[.contract-item-name]#++upgrade++#++(new_class_hash: ClassHash)++` [.item-kind]#external#

Upgrades the contract code by updating its {class_hash}.

NOTE: This function is usually protected by an xref:access.adoc[Access Control] mechanism.

[.contract]
[[IUpgradeAndCall]]
=== `++IUpgradeAndCall++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/upgrades/src/interface.cairo[{github-icon},role=heading-link]

:Upgraded: xref:UpgradeableComponent-Upgraded[Upgraded]

```cairo
use openzeppelin::upgrades::interface::IUpgradeAndCall;
```

Interface for an upgradeable contract that couples an upgrade with a function call in the upgraded context.

[.contract-index]
.Functions
--
* xref:#IUpgradeAndCall-upgrade_and_call[`++upgrade_and_call(new_class_hash, selector, calldata)++`]
--

[#IUpgradeAndCall-Functions]
==== Functions

[.contract-item]
[[IUpgradeAndCall-upgrade_and_call]]
==== `[.contract-item-name]#++upgrade_and_call++#++(new_class_hash: ClassHash, selector: felt252, calldata: Span<felt252>) → Span<felt252>++` [.item-kind]#external#

Upgrades the contract code by updating its {class_hash} and calls `selector` with the upgraded context.

NOTE: This function is usually protected by an xref:access.adoc[Access Control] mechanism.

[.contract]
[[UpgradeableComponent]]
=== `++UpgradeableComponent++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/upgrades/src/upgradeable.cairo[{github-icon},role=heading-link]

```cairo
use openzeppelin_upgrades::upgradeable::UpgradeableComponent;
```

Upgradeable component.

[.contract-index]
.Internal Implementations
--
.InternalImpl

* xref:#UpgradeableComponent-upgrade[`++upgrade(self, new_class_hash)++`]
* xref:#UpgradeableComponent-upgrade_and_call[`++upgrade_and_call(self, new_class_hash, selector, calldata)++`]
--

[.contract-index]
.Events
--
* xref:#UpgradeableComponent-Upgraded[`++Upgraded(class_hash)++`]
--

[#UpgradeableComponent-Internal-Functions]
==== Internal Functions

:snip6: https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-6.md[SNIP-6]

[.contract-item]
[[UpgradeableComponent-upgrade]]
==== `[.contract-item-name]#++upgrade++#++(ref self: ContractState, new_class_hash: ClassHash)++` [.item-kind]#internal#

Upgrades the contract by updating the contract {class_hash}.

Requirements:

- `new_class_hash` must be different from zero.

Emits an {Upgraded} event.

[.contract-item]
[[UpgradeableComponent-upgrade_and_call]]
==== `[.contract-item-name]#++upgrade_and_call++#++(ref self: ContractState, new_class_hash: ClassHash, selector: felt252, calldata: Span<felt252>) → Span<felt252>++` [.item-kind]#internal#

Replaces the contract's class hash with `new_class_hash` and then calls `selector`
from the upgraded context.
This function returns the unwrapped `call_contract_syscall` return value(s), if available, of the `selector` call.

Requirements:

- `new_class_hash` must be different from zero.

NOTE: The function call comes from the upgraded contract itself and not the account.

NOTE: A similar behavior to `upgrade_and_call` can also be achieved with a list of calls from an account since the {snip6} account standard supports multicall.
An account can execute a list of calls with xref:IUpgradeable-upgrade[upgrade] being the first element in the list and the extra function call as the second.
With this approach, the calls will execute from the account's context and can't be front-ran.

Emits an {Upgraded} event.

[#UpgradeableComponent-Events]
==== Events

[.contract-item]
[[UpgradeableComponent-Upgraded]]
==== `[.contract-item-name]#++Upgraded++#++(class_hash: ClassHash)++` [.item-kind]#event#

Emitted when the {class_hash} is upgraded.
// llmstxt-short-description: API of the Utilities module, containing core utilities of the library

= Utilities

:deploy_syscall: link:https://docs.starknet.io/architecture-and-concepts/smart-contracts/system-calls-cairo1/#deploy[deploy_syscall]

This crate provides miscellaneous components and libraries containing utility functions to handle common tasks.

== Core

[.contract]
[[utils]]
=== `++utils++`

```cairo
use openzeppelin_utils;
```

Module containing core utilities of the library.

[.contract-index]
.Members
--
.Inner modules
* xref:#utils-cryptography[`++cryptography++`]
* xref:#utils-deployments[`++deployments++`]
* xref:#utils-math[`++math++`]
* xref:#utils-serde[`++serde++`]
--

[#utils-Inner-Modules]
==== Inner modules

[.contract-item]
[[utils-cryptography]]
==== `[.contract-item-name]#++cryptography++#` [.item-kind]#module#

See xref:#cryptography[`openzeppelin_utils::cryptography`].

[.contract-item]
[[utils-deployments]]
==== `[.contract-item-name]#++deployments++#` [.item-kind]#module#

See xref:#deployments[`openzeppelin_utils::deployments`].

[.contract-item]
[[utils-math]]
==== `[.contract-item-name]#++math++#` [.item-kind]#module#

See xref:#math[`openzeppelin_utils::math`].

[.contract-item]
[[utils-serde]]
==== `[.contract-item-name]#++serde++#` [.item-kind]#module#

See xref:#serde[`openzeppelin_utils::serde`].

[.contract]
[[cryptography]]
=== `++cryptography++`

:snip12: https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md[SNIP12]

```cairo
use openzeppelin_utils::cryptography;
```

Module containing utilities related to cryptography.

[.contract-index]
.Members
--
.Inner modules
* xref:#cryptography-nonces[`++nonces++`]
* xref:#cryptography-snip12[`++snip12++`]
--

[#cryptography-Inner modules]
==== Inner modules

[.contract-item]
[[cryptography-nonces]]
==== `[.contract-item-name]#++nonces++#` [.item-kind]#module#

See xref:#NoncesComponent[`openzeppelin_utils::cryptography::nonces::NoncesComponent`].

[.contract-item]
[[cryptography-snip12]]
==== `[.contract-item-name]#++snip12++#` [.item-kind]#module#

See xref:#snip12[`openzeppelin_utils::cryptography::snip12`].

[.contract]
[[deployments]]
=== `++deployments++`

:udc-doc: xref:/udc.adoc[Universal Deployer Contract]

```cairo
use openzeppelin_utils::deployments;
```

Module containing utility functions for calculating contract addresses through {deploy_syscall} and the {udc-doc} (UDC).

[.contract-index]
.Members
--
.Structs
* xref:deployments-DeployerInfo[`++DeployerInfo(caller_address, udc_address)++`]

.Functions
* xref:deployments-calculate_contract_address_from_deploy_syscall[`++calculate_contract_address_from_deploy_syscall(salt, class_hash, constructor_calldata, deployer_address)++`]
* xref:deployments-compute_hash_on_elements[`++compute_hash_on_elements(data)++`]
* xref:deployments-calculate_contract_address_from_udc[`++calculate_contract_address_from_udc(salt, class_hash, constructor_calldata, deployer_info)++`]
--

[#deployments-Structs]
==== Structs

:calculate_contract_address_from_udc: xref:deployments-calculate_contract_address_from_udc[utils::calculate_contract_address_from_udc]

[.contract-item]
[[deployments-DeployerInfo]]
==== `[.contract-item-name]#++DeployerInfo++#++(caller_address: ContractAddress, udc_address: ContractAddress)++` [.item-kind]#struct#

Struct containing arguments necessary in {calculate_contract_address_from_udc} for origin-dependent deployment calculations.

[#deployments-Functions]
==== Functions

:deployer-info: xref:deployments-DeployerInfo[DeployerInfo]

[.contract-item]
[[deployments-calculate_contract_address_from_deploy_syscall]]
==== `[.contract-item-name]#++calculate_contract_address_from_deploy_syscall++#++(salt: felt252, class_hash: ClassHash, constructor_calldata: Span<felt252>, deployer_address: ContractAddress) → ContractAddress++` [.item-kind]#function#

Returns the contract address when passing the given arguments to {deploy_syscall}.

[.contract-item]
[[deployments-compute_hash_on_elements]]
==== `[.contract-item-name]#++compute_hash_on_elements++#++(data: Span<felt252>) → felt252++` [.item-kind]#function#

Creates a Pedersen hash chain with the elements of `data` and returns the finalized hash.

[.contract-item]
[[deployments-calculate_contract_address_from_udc]]
==== `[.contract-item-name]#++calculate_contract_address_from_udc++#++(salt: felt252, class_hash: ClassHash, constructor_calldata: Span<felt252>, deployer_info: Option<DeployerInfo>) → ContractAddress++` [.item-kind]#function#

Returns the calculated contract address for UDC deployments.

Origin-independent deployments (deployed from zero) should pass `Option::None` as `deployer_info`.

Origin-dependent deployments hash `salt` with `caller_address` (member of {deployer-info}) and pass the hashed salt to the inner {deploy_syscall} as the `contract_address_salt` argument.

[.contract]
[[math]]
=== `++math++`

```cairo
use openzeppelin_utils::math;
```

Module containing math utilities.

[.contract-index]
.Members
--
.Functions
* xref:#math-average[`++average(a, b)++`]
--

[#math-Functions]
==== Functions

[.contract-item]
[[math-average]]
==== `[.contract-item-name]#++average++#++(a: T, b: T) → T++` [.item-kind]#function#

Returns the average of two unsigned integers. The result is rounded down.

NOTE: `T` is a generic value matching different numeric implementations.

[.contract]
[[serde]]
=== `++serde++`

```cairo
use openzeppelin_utils::serde;
```

Module containing utilities related to serialization and deserialization of Cairo data structures.

[.contract-index]
.Members
--
.Traits
* xref:#serde-SerializedAppend[`++SerializedAppend++`]
--

[#serde-Traits]
==== Traits

[.contract-item]
[[serde-SerializedAppend]]
==== `[.contract-item-name]#++SerializedAppend++#` [.item-kind]#trait#

Importing this trait allows the ability to append a serialized representation of a Cairo data structure already
implementing the `Serde` trait to a `felt252` buffer.

Usage example:

```cairo
use openzeppelin_utils::serde::SerializedAppend;
use starknet::ContractAddress;

fn to_calldata(recipient: ContractAddress, amount: u256) -> Array<felt252> {
    let mut calldata = array![];
    calldata.append_serde(recipient);
    calldata.append_serde(amount);
    calldata
}
```

Note that the `append_serde` method is automatically available for arrays of felts, and it accepts any data structure
that implements the `Serde` trait.

== Cryptography

[.contract]
[[NoncesComponent]]
=== `++NoncesComponent++`

```cairo
use openzeppelin_utils::cryptography::nonces::NoncesComponent;
```

This component provides a simple mechanism for handling incremental
nonces for a set of addresses. It is commonly used to prevent replay attacks
when contracts accept signatures as input.

[.contract-index#NoncesComponent-Embeddable-Impls]
.Embeddable Implementations
--
[.sub-index#NoncesComponent-Embeddable-Impls-NoncesImpl]
.NoncesImpl

* xref:#NoncesComponent-nonces[`++nonces(self, owner)++`]
--

[.contract-index]
.Internal Implementations
--
.InternalImpl

* xref:#NoncesComponent-use_nonce[`++use_nonce(self, owner)++`]
* xref:#NoncesComponent-use_checked_nonce[`++use_checked_nonce(self, owner, nonce)++`]
--

[#NoncesComponent-Embeddable-Functions]
==== Embeddable functions

[.contract-item]
[[NoncesComponent-nonces]]
==== `[.contract-item-name]#++nonces++#++(self: @ContractState, owner: ContractAddress) → felt252++` [.item-kind]#external#

Returns the next unused nonce for an `owner`.

[#NoncesComponent-Internal-Functions]
==== Internal functions

[.contract-item]
[[NoncesComponent-use_nonce]]
==== `[.contract-item-name]#++use_nonce++#++(ref self: ComponentState, owner: ContractAddress) → felt252++` [.item-kind]#internal#

Consumes a nonce, returns the current value, and increments nonce.

For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be
decremented or reset. This guarantees that the nonce never overflows.

[.contract-item]
[[NoncesComponent-use_checked_nonce]]
==== `[.contract-item-name]#++use_checked_nonce++#++(ref self: ComponentState, owner: ContractAddress, nonce: felt252) → felt252++` [.item-kind]#internal#

Same as `use_nonce` but checking that `nonce` is the next valid one for `owner`.

[.contract]
[[snip12]]
=== `++snip12++`

```cairo
use openzeppelin_utils::snip12;
```

Supports on-chain generation of message hashes compliant with {snip12}.

NOTE: For a full walkthrough on how to use this module, see the
xref:/guides/snip12.adoc[SNIP12 and Typed Messages] guide.
// llmstxt-short-description: API of the Testing module, providing helper functions for testing smart contracts using the `snforge` toolchain from Starknet Foundry

= Testing

:stark: https://docs.starknet.io/architecture-and-concepts/cryptography/stark-curve/[Stark]
:secp256k1: https://github.com/starkware-libs/cairo/blob/main/corelib/src/starknet/secp256k1.cairo[Secp256k1]
:secp256r1: https://www.nervos.org/knowledge-base/what_is_secp256r1[Secp256r1]

This crate provides various helper functions for declaring, deploying,
and testing smart contracts using the `snforge` toolchain from Starknet Foundry.

```cairo
use openzeppelin_testing;
```

The module isn't part of the `openzeppelin` package and to be accessible has to
be added as a separate dependency in `Scarb.toml`:

```
[dev-dependencies]
openzeppelin_testing = "1.0.0"
```

== Test Utilities

[.contract]
[[testing-common]]
=== `++common++`

A module providing common test helpers.

```cairo
use openzeppelin_testing::common;
```

[.contract-index]
.Members
--
.Functions
* xref:#testing-common-panic_data_to_byte_array[`++panic_data_to_byte_array(panic_data)++`]
* xref:#testing-common-to_base_16_string[`++to_base_16_string(value)++`]
* xref:#testing-common-to_base_16_string_no_padding[`++to_base_16_string_no_padding(value)++`]
* xref:#testing-common-assert_entrypoint_not_found_error[`++assert_entrypoint_not_found_error(result, selector, contract_address)++`]

.Traits
* xref:#testing-common-IntoBase16StringTrait[`++IntoBase16StringTrait++`]
--

[#testing-common-Functions]
==== Functions

[.contract-item]
[[testing-common-panic_data_to_byte_array]]
==== `[.contract-item-name]#++panic_data_to_byte_array++#++(panic_data: Array<felt252>) → ByteArray++` [.item-kind]#function#

Converts panic data into a string (`ByteArray`).

`panic_data` is expected to be a valid serialized `ByteArray` with an extra `felt252` at the beginning, which is the BYTE_ARRAY_MAGIC.

[.contract-item]
[[testing-common-to_base_16_string]]
==== `[.contract-item-name]#++to_base_16_string++#++(value: felt252) → ByteArray++` [.item-kind]#function#

Converts a `felt252` to a `base16` string padded to 66 characters (including the `0x` prefix).

[.contract-item]
[[testing-common-to_base_16_string_no_padding]]
==== `[.contract-item-name]#++to_base_16_string_no_padding++#++(value: felt252) → ByteArray++` [.item-kind]#function#

Converts a `felt252` to a `base16` (hexadecimal) string without padding, but including the `0x`
prefix.

[.contract-item]
[[testing-common-assert_entrypoint_not_found_error]]
==== `[.contract-item-name]#++assert_entrypoint_not_found_error++#<T, +Drop<T>>(result: SyscallResult<T>, selector: felt252, contract_address: ContractAddress)` [.item-kind]#function#

Asserts that the syscall result of a call failed with an "Entrypoint not found" error,
following the Starknet Foundry emitted error format.

[#testing-common-Traits]
==== Traits

[.contract-item]
[[testing-common-IntoBase16StringTrait]]
==== `[.contract-item-name]#++IntoBase16StringTrait++#` [.item-kind]#trait#

A helper trait that enables a value to be represented as a `base16`(hexadecimal) string padded to 66 characters
(including the `0x` prefix). The type of the value must implement `Into<T, felt252>` to be
convertible to `felt252`.

Usage example:

```cairo
use openzeppelin_testing::common::IntoBase16String;

let expected_panic_message = format!(
    "Entry point selector {} not found in contract {}",
    selector.into_base_16_string(),
    contract_address.into_base_16_string()
);
```

NOTE: The no-padding version can be used in the same way by calling `selector.into_base_16_string_no_padding()`.

[.contract]
[[testing-deployment]]
=== `++deployment++`

```cairo
use openzeppelin_testing::deployment;
```

A module containing utilities that simplify declaring and deploying contracts using the `snforge` toolchain.

[.contract-index]
.Members
--
.Functions
* xref:#testing-deployment-declare_class[`++declare_class(contract_name)++`]
* xref:#testing-deployment-deploy[`++deploy(contract_class, calldata)++`]
* xref:#testing-deployment-deploy_at[`++deploy_at(contract_class, contract_address, calldata)++`]
* xref:#testing-deployment-deploy_another_at[`++deploy_another_at(existing, target_address, calldata)++`]
* xref:#testing-deployment-declare_and_deploy[`++declare_and_deploy(contract_name, calldata)++`]
* xref:#testing-deployment-declare_and_deploy_at[`++declare_and_deploy_at(contract_name, target_address, calldata)++`]
--

[#testing-deployment-Functions]
==== Functions

[.contract-item]
[[testing-deployment-declare_class]]
==== `[.contract-item-name]#++declare_class++#++(contract_name: ByteArray) → ContractClass++` [.item-kind]#function#

Declares a contract with a `snforge_std::declare` call and unwraps the result. This function will skip declaration and just return the `ContractClass` if the contract is already declared (the result of `snforge_std::declare` call is of type `DeclareResult::AlreadyDeclared`).

[.contract-item]
[[testing-deployment-deploy]]
==== `[.contract-item-name]#++deploy++#++(contract_class: ContractClass, calldata: Array<felt252>) → ContractAddress++` [.item-kind]#function#

Deploys an instance of a contract and unwraps the result.

[.contract-item]
[[testing-deployment-deploy_at]]
==== `[.contract-item-name]#++deploy_at++#++(contract_class: ContractClass, target_address: ContractAddress, calldata: Array<felt252>)++` [.item-kind]#function#

Deploys an instance of a contract at a given address.

[.contract-item]
[[testing-deployment-deploy_another_at]]
==== `[.contract-item-name]#++deploy_another_at++#++(existing: ContractAddress, target_address: ContractAddress, calldata: Array<felt252>)++` [.item-kind]#function#

Deploys a contract using the class hash from another already-deployed contract.

Note that currently, `snforge` does not support redeclaring a contract class. Consequently,
there is no direct method to deploy a second instance of a contract if neither its `ContractClass`
nor its `class_hash` is available in the context. This helper function provides a solution by retrieving
the class hash from an existing contract and using it to facilitate the deployment.

```cairo
use openzeppelin_testing::deploy_another_at;

let alice_address = setup_account(array!['ALICE_PUBKEY']);
let bob_address = contract_address_const::<'BOB'>();
deploy_another_at(alice_address, bob_address, array!['BOB_PUBKEY']);
```

[.contract-item]
[[testing-deployment-declare_and_deploy]]
==== `[.contract-item-name]#++declare_and_deploy++#++(contract_name: ByteArray, calldata: Array<felt252>) → ContractAddress++` [.item-kind]#function#

Combines the declaration of a class and the deployment of a contract into one function call. This function will skip declaration if the contract is already declared (the result of `snforge_std::declare` call is of type `DeclareResult::AlreadyDeclared`).

[.contract-item]
[[testing-deployment-declare_and_deploy_at]]
==== `[.contract-item-name]#++declare_and_deploy_at++#++(contract_name: ByteArray, target_address: ContractAddress, calldata: Array<felt252>)++` [.item-kind]#function#

Combines the declaration of a class and the deployment of a contract at the given address into one function call. This function will skip declaration if the contract is already declared (the result of `snforge_std::declare` call is of type `DeclareResult::AlreadyDeclared`).

[.contract]
[[testing-events]]
=== `++events++`

```cairo
use openzeppelin_testing::events;
use openzeppelin_testing::events::EventSpyExt;
```

A module offering an extended set of functions for handling emitted events, enhancing the default
event utilities provided by `snforge`. These functions are accessible via the `EventSpyExt`
trait implemented on the `EventSpy` struct.

[.contract-index]
.Members
--
.Functions
* xref:#testing-events-assert_only_event[`++assert_only_event(self, from_address, event)++`]
* xref:#testing-events-assert_emitted_single[`++assert_emitted_single(self, from_address, expected_event)++`]
* xref:#testing-events-drop_event[`++drop_event(self)++`]
* xref:#testing-events-drop_n_events[`++drop_n_events(self, number_to_drop)++`]
* xref:#testing-events-drop_all_events[`++drop_all_events(self)++`]
* xref:#testing-events-assert_no_events_left[`++assert_no_events_left(self)++`]
* xref:#testing-events-assert_no_events_left_from[`++assert_no_events_left_from(self, from_address)++`]
* xref:#testing-events-count_events_from[`++count_events_from(self, from_address)++`]
--

[#testing-events-Functions]
==== Functions

[.contract-item]
[[testing-events-assert_only_event]]
==== `[.contract-item-name]#++assert_only_event++#++<T, +starknet::Event<T>, +Drop<T>>(ref self: EventSpy, from_address: ContractAddress, expected_event: T)++` [.item-kind]#function#

Ensures that `from_address` has emitted only the `expected_event` and no additional events.

[.contract-item]
[[testing-events-assert_emitted_single]]
==== `[.contract-item-name]#++assert_emitted_single++#++<T, +starknet::Event<T>, +Drop<T>>(ref self: EventSpy, from_address: ContractAddress, expected_event: T)++` [.item-kind]#function#

Ensures that `from_address` has emitted the `expected_event`.

[.contract-item]
[[testing-events-drop_event]]
==== `[.contract-item-name]#++drop_event++#++(ref self: EventSpy)++` [.item-kind]#function#

Removes a single event from the queue. If the queue is empty, the function will panic.

[.contract-item]
[[testing-events-drop_n_events]]
==== `[.contract-item-name]#++drop_n_events++#++(ref self: EventSpy, number_to_drop: u32)++` [.item-kind]#function#

Removes `number_to_drop` events from the queue. If the queue is empty, the function will panic.

[.contract-item]
[[testing-events-drop_all_events]]
==== `[.contract-item-name]#++drop_all_events++#++(ref self: EventSpy)++` [.item-kind]#function#

Removes all events remaining on the queue. If the queue is empty already, the function will do nothing.

[.contract-item]
[[testing-events-assert_no_events_left]]
==== `[.contract-item-name]#++assert_no_events_left++#++(ref self: EventSpy)++` [.item-kind]#function#

Ensures that there are no events remaining on the queue.

[.contract-item]
[[testing-events-assert_no_events_left_from]]
==== `[.contract-item-name]#++assert_no_events_left_from++#++(ref self: EventSpy, from_address: ContractAddress)++` [.item-kind]#function#

Ensures that there are no events emitted from the given address remaining on the queue.

[.contract-item]
[[testing-events-count_events_from]]
==== `[.contract-item-name]#++count_events_from++#++(ref self: EventSpy, from_address: ContractAddress) → u32++` [.item-kind]#function#

Counts the number of remaining events emitted from the given address.

[.contract]
[[testing-signing]]
=== `++signing++`

```cairo
use openzeppelin_testing::signing;
```

A module offering utility functions for easier management of key pairs and signatures.

[.contract-index]
.Members
--
.Functions
* xref:#testing-signing-get_stark_keys_from[`++get_stark_keys_from(private_key)++`]
* xref:#testing-signing-get_secp256k1_keys_from[`++get_secp256k1_keys_from(private_key)++`]
* xref:#testing-signing-get_secp256r1_keys_from[`++get_secp256r1_keys_from(private_key)++`]

.Traits
* xref:#testing-signing-SerializedSigning[`++SerializedSigning++`]
--

[#testing-signing-Functions]
==== Functions

[.contract-item]
[[testing-signing-get_stark_keys_from]]
==== `[.contract-item-name]#++get_stark_keys_from++#++(private_key: felt252) → StarkKeyPair++` [.item-kind]#function#

Builds a {stark} key pair from a private key represented by a `felt252` value.

[.contract-item]
[[testing-signing-get_secp256k1_keys_from]]
==== `[.contract-item-name]#++get_secp256k1_keys_from++#++(private_key: u256) → Secp256k1KeyPair++` [.item-kind]#function#

Builds a {secp256k1} key pair from a private key represented by a `u256` value.

[.contract-item]
[[testing-signing-get_secp256r1_keys_from]]
==== `[.contract-item-name]#++get_secp256r1_keys_from++#++(private_key: u256) → Secp256r1KeyPair++` [.item-kind]#function#

Builds a {secp256r1} key pair from a private key represented by a `u256` value.

[#testing-signing-Traits]
==== Traits

[.contract-item]
[[testing-signing-SerializedSigning]]
==== `[.contract-item-name]#++SerializedSigning++#` [.item-kind]#trait#

A helper trait that facilitates signing and converting the result signature into a serialized format.

Usage example:

```cairo
use openzeppelin_testing::signing::{
    StarkKeyPair, get_stark_keys_from, StarkSerializedSigning
};

let key_pair = get_stark_keys_from('SECRET_KEY');
let serialized_signature = key_pair.serialized_sign('TX_HASH');
```// llmstxt-short-description: Describes the backwards compatibility guarantees of the library

= Backwards Compatibility

OpenZeppelin Contracts uses semantic versioning to communicate backwards compatibility of its API and storage layout. Patch and minor updates will generally be backwards compatible, with rare exceptions as detailed below. Major updates should be assumed incompatible with previous releases. On this page, we provide details about these guarantees.

Bear in mind that while releasing versions under `v1.0.0`, we treat minors as majors and patches as minors, in accordance with semantic versioning. This means that `v0.7.1` could be adding features to `v0.7.0`, while `v0.8.0` would be considered a breaking release.

== API

In backwards compatible releases, all changes should be either additions or modifications to internal implementation details. Most code should continue to compile and behave as expected. The exceptions to this rule are listed below.

=== Security

Infrequently, a patch or minor update will remove or change an API in a breaking way but only if the previous API is considered insecure. These breaking changes will be noted in the changelog and release notes, and published along with a security advisory.

=== Errors

The specific error format and data that is included with reverts should not be assumed stable unless otherwise specified.

=== Major releases

Major releases should be assumed incompatible. Nevertheless, the external interfaces of contracts will remain compatible if they are standardized, or if the maintainers judge that changing them would cause significant strain on the ecosystem.

An important aspect that major releases may break is "upgrade compatibility", in particular storage layout compatibility. It will never be safe for a live contract to upgrade from one major release to another.

== Storage layout

Patch updates will always preserve storage layout compatibility, and after `v1.0.0` minors will too. This means that a live contract can be upgraded from one minor to another without corrupting the storage layout. In some cases it may be necessary to initialize new state variables when upgrading, although we expect this to be infrequent.

== Cairo version

The minimum Cairo version required to compile the contracts will remain unchanged for patch updates, but it may change for minors.

